{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpResponse, HttpErrorResponse, HttpEventType, HttpClientModule } from '@angular/common/http';\nimport { of, throwError, Subject, map as map$1, firstValueFrom, EMPTY, Observable, forkJoin, NEVER } from 'rxjs';\nimport { tap, startWith, map, expand, concatMap, toArray, finalize, switchMap, catchError } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, InjectionToken, NgModule } from '@angular/core';\nvar PathSegmentNames = /*#__PURE__*/(() => {\n  (function (PathSegmentNames) {\n    PathSegmentNames[\"batch\"] = \"batch\";\n    PathSegmentNames[\"metadata\"] = \"metadata\";\n    PathSegmentNames[\"entitySet\"] = \"entitySet\";\n    PathSegmentNames[\"singleton\"] = \"singleton\";\n    PathSegmentNames[\"type\"] = \"type\";\n    PathSegmentNames[\"property\"] = \"property\";\n    PathSegmentNames[\"navigationProperty\"] = \"navigationProperty\";\n    PathSegmentNames[\"reference\"] = \"reference\";\n    PathSegmentNames[\"value\"] = \"value\";\n    PathSegmentNames[\"count\"] = \"count\";\n    PathSegmentNames[\"function\"] = \"function\";\n    PathSegmentNames[\"action\"] = \"action\";\n  })(PathSegmentNames || (PathSegmentNames = {}));\n\n  return PathSegmentNames;\n})();\nvar QueryOptionNames = /*#__PURE__*/(() => {\n  (function (QueryOptionNames) {\n    QueryOptionNames[\"select\"] = \"select\";\n    QueryOptionNames[\"expand\"] = \"expand\";\n    QueryOptionNames[\"compute\"] = \"compute\";\n    QueryOptionNames[\"filter\"] = \"filter\";\n    QueryOptionNames[\"search\"] = \"search\";\n    QueryOptionNames[\"transform\"] = \"transform\";\n    QueryOptionNames[\"orderBy\"] = \"orderBy\";\n    QueryOptionNames[\"top\"] = \"top\";\n    QueryOptionNames[\"skip\"] = \"skip\";\n    QueryOptionNames[\"skiptoken\"] = \"skiptoken\";\n    QueryOptionNames[\"format\"] = \"format\";\n    QueryOptionNames[\"levels\"] = \"levels\";\n    QueryOptionNames[\"count\"] = \"count\";\n  })(QueryOptionNames || (QueryOptionNames = {}));\n\n  return QueryOptionNames;\n})();\nconst NONE_PARSER = {\n  deserialize: value => value,\n  serialize: value => value,\n  encode: value => value\n}; //#endregion\n\nconst $ID = '$id';\nconst ODATA_ID = '@odata.id'; // SEGMENTS\n\nconst $METADATA = '$metadata';\nconst $BATCH = '$batch';\nconst $REF = '$ref';\nconst $VALUE = '$value';\nconst $COUNT = '$count';\nconst $QUERY = '$query';\nconst $INLINECOUNT = '$inlinecount'; // HTTP HEADERS\n\nconst IF_MATCH_HEADER = 'If-Match';\nconst IF_NONE_MATCH_HEADER = 'If-None-Match';\nconst CONTENT_TYPE = 'Content-Type';\nconst CACHE_CONTROL = 'Cache-Control';\nconst HTTP11 = 'HTTP/1.1';\nconst ACCEPT = 'Accept';\nconst PREFER = 'Prefer';\nconst ODATA_VERSION = 'OData-Version';\nconst ODATA_VERSION_HEADERS = [ODATA_VERSION, ODATA_VERSION.toLowerCase(), 'dataserviceversion'];\nconst ETAG_HEADER = 'ETag';\nconst ETAG_HEADERS = [ETAG_HEADER, ETAG_HEADER.toLowerCase()];\nconst LOCATION_HEADER = 'Location';\nconst LOCATION_HEADERS = [LOCATION_HEADER, LOCATION_HEADER.toLowerCase()];\nconst ODATA_ENTITYID = 'OData-EntityId';\nconst ODATA_ENTITYID_HEADERS = [ODATA_ENTITYID, ODATA_ENTITYID.toLowerCase()];\nconst PREFERENCE_APPLIED = 'Preference-Applied';\nconst PREFERENCE_APPLIED_HEADERS = [PREFERENCE_APPLIED, PREFERENCE_APPLIED.toLowerCase()];\nconst RETRY_AFTER = 'Retry-After';\nconst RETRY_AFTER_HEADERS = [RETRY_AFTER, RETRY_AFTER.toLowerCase()]; // HTTP HEADER VALUES\n\nconst APPLICATION_JSON = 'application/json';\nconst APPLICATION_HTTP = 'application/http';\nconst TEXT_PLAIN = 'text/plain';\nconst MULTIPART_MIXED = 'multipart/mixed';\nconst MULTIPART_MIXED_BOUNDARY = 'multipart/mixed;boundary=';\nconst CONTENT_TRANSFER_ENCODING = 'Content-Transfer-Encoding';\nconst CONTENT_ID = 'Content-ID';\nconst MAX_AGE = 'max-age'; // VERSIONS\n\nconst VERSION_4_0 = '4.0';\nconst VERSION_3_0 = '3.0';\nconst VERSION_2_0 = '2.0';\nconst DEFAULT_VERSION = VERSION_4_0;\nconst BINARY = 'binary';\nconst BOUNDARY_PREFIX_SUFFIX = '--';\nconst BATCH_PREFIX = 'batch_';\nconst CHANGESET_PREFIX = 'changeset_';\nconst DEFAULT_METADATA = 'minimal';\nconst DEFAULT_STRIP_METADATA = 'full';\nconst DEFAULT_FETCH_POLICY = 'network-only';\nconst DEFAULT_TIMEOUT = 60; // Time in seconds\n\nconst CALLABLE_BINDING_PARAMETER = 'bindingParameter';\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/; // URL PARTS\n\nconst QUERY_SEPARATOR = '?';\nconst PARAM_SEPARATOR = '&';\nconst VALUE_SEPARATOR = '=';\nconst PATH_SEPARATOR = '/';\nconst ODATA_PARAM_PREFIX = '$';\nconst ODATA_ALIAS_PREFIX = '@';\nconst NEWLINE = '\\r\\n';\nconst NEWLINE_REGEXP = /\\r?\\n/;\nconst CACHE_KEY_SEPARATOR = ':'; // Models\n\nconst CID_FIELD_NAME = '_cid'; // Standard vocabularies for annotating OData services\n// http://docs.oasis-open.org/odata/odata-vocabularies/v4.0/csprd01/odata-vocabularies-v4.0-csprd01.html\n\nconst COMPUTED = /.*Computed$/;\nconst OPTIMISTIC_CONCURRENCY = /.*OptimisticConcurrency$/;\nconst DESCRIPTION = /.*Description$/;\nconst LONG_DESCRIPTION = /.*LongDescription$/;\n\nclass ODataCache {\n  constructor({\n    timeout = DEFAULT_TIMEOUT\n  }) {\n    this.timeout = timeout;\n    this.entries = new Map();\n  }\n  /**\n   * Using the resource on the request build an array of string to identify the scope of the request\n   * @param req The request with the resource to build the scope\n   * @returns Array of string to identify the scope of the request\n   */\n\n\n  scope(req) {\n    const segments = req.resource.cloneSegments();\n    return segments.segments({\n      key: true\n    }).reduce((acc, s) => {\n      if (s.name === PathSegmentNames.entitySet) acc = [...acc, s.path()];\n      return acc;\n    }, ['request']);\n  }\n  /**\n   * Using the odata context on the response build an array of string to identify the tags of the response\n   * @param res The response to build the tags\n   * @returns Array of string to identify the tags of the response\n   */\n\n\n  tags(res) {\n    const tags = [];\n    const context = res.context;\n\n    if (context.entitySet) {\n      tags.push(context.key ? `${context.entitySet}(${context.key})` : context.entitySet);\n    }\n\n    if (context.type) tags.push(context.type);\n    return tags;\n  }\n  /**\n   * Build an entry from a payload and some options\n   * @param payload The payload to store in the cache\n   * @param timeout The timeout for the entry\n   * @param tags The tags for the entry\n   * @returns The entry to store in the cache\n   */\n\n\n  buildEntry(payload, {\n    timeout,\n    tags\n  }) {\n    return {\n      payload,\n      lastRead: Date.now(),\n      timeout: timeout || this.timeout,\n      tags: tags || []\n    };\n  }\n  /**\n   * Build a key from store an entry in the cache\n   * @param names The names of the entry\n   * @returns The key for the entry\n   */\n\n\n  buildKey(names) {\n    return names.join(CACHE_KEY_SEPARATOR);\n  }\n  /**\n   * Put some payload in the cache\n   * @param name The name for the entry\n   * @param payload The payload to store in the cache\n   * @param timeout The timeout for the entry\n   * @param scope The scope for the entry\n   * @param tags The tags for the entry\n   */\n\n\n  put(name, payload, {\n    timeout,\n    scope,\n    tags\n  } = {}) {\n    const entry = this.buildEntry(payload, {\n      timeout,\n      tags\n    });\n    const key = this.buildKey([...(scope || []), name]);\n    this.entries.set(key, entry);\n    this.forget();\n  }\n  /**\n   * Return the payload from the cache if it exists and is not expired\n   * @param name The name of the entry\n   * @param scope The scope of the entry\n   * @returns The payload of the entry\n   */\n\n\n  get(name, {\n    scope\n  } = {}) {\n    const key = this.buildKey([...(scope || []), name]);\n    const entry = this.entries.get(key);\n    return entry !== undefined && !this.isExpired(entry) ? entry.payload : undefined;\n  }\n  /**\n   * Remove all cache entries that are matching with the given options\n   * @param options The options to forget\n   */\n\n\n  forget({\n    name,\n    scope = [],\n    tags = []\n  } = {}) {\n    if (name !== undefined) scope.push(name);\n    const key = scope.length > 0 ? this.buildKey(scope) : undefined;\n    this.entries.forEach((entry, k) => {\n      if (this.isExpired(entry) || // Expired\n      key !== undefined && k.startsWith(key) || // Key\n      tags.length > 0 && tags.some(t => entry.tags.indexOf(t) !== -1) // Tags\n      ) {\n        this.entries.delete(k);\n      }\n    });\n  }\n  /**\n   * Remove all cache entries\n   */\n\n\n  flush() {\n    this.entries = new Map();\n  }\n  /**\n   * Check if the entry is expired\n   * @param entry The cache entry\n   * @returns Boolean indicating if the entry is expired\n   */\n\n\n  isExpired(entry) {\n    return entry.lastRead < Date.now() - (entry.timeout || this.timeout) * 1000;\n  }\n  /**\n   * Using the request, handle the fetching of the response\n   * @param req The request to fetch\n   * @param res$ Observable of the response\n   * @returns\n   */\n\n\n  handleRequest(req, res$) {\n    return req.isFetch() ? this.handleFetch(req, res$) : req.isMutate() ? this.handleMutate(req, res$) : res$;\n  }\n\n  handleFetch(req, res$) {\n    const policy = req.fetchPolicy;\n    const cached = this.getResponse(req);\n\n    if (policy === 'no-cache') {\n      return res$;\n    }\n\n    if (policy === 'cache-only') {\n      if (cached) {\n        return of(cached);\n      } else {\n        return throwError(() => new Error('No Cached'));\n      }\n    }\n\n    if (policy === 'cache-first' || policy === 'cache-and-network' || policy === 'network-only') {\n      res$ = res$.pipe(tap(res => {\n        if (res.options.cacheability !== 'no-store') this.putResponse(req, res);\n      }));\n    }\n\n    return cached !== undefined && policy !== 'network-only' ? policy === 'cache-and-network' ? res$.pipe(startWith(cached)) : of(cached) : res$;\n  }\n\n  handleMutate(req, res$) {\n    const requests = req.isBatch() ? req.resource.requests().filter(r => r.isMutate()) : [req];\n\n    for (var r of requests) {\n      const scope = this.scope(r);\n      this.forget({\n        scope\n      });\n    }\n\n    return res$;\n  }\n\n}\n\nclass ODataInMemoryCache extends ODataCache {\n  constructor({\n    timeout\n  } = {}) {\n    super({\n      timeout\n    });\n  }\n  /**\n   * Store the response in the cache\n   * @param req The request with the resource to store the response\n   * @param res The response to store in the cache\n   */\n\n\n  putResponse(req, res) {\n    let scope = this.scope(req);\n    let tags = this.tags(res);\n    this.put(req.cacheKey, res, {\n      timeout: res.options.maxAge,\n      scope,\n      tags\n    });\n  }\n  /**\n   * Restore the response from the cache\n   * @param req The request with the resource to get the response\n   * @returns The response from the cache\n   */\n\n\n  getResponse(req) {\n    let scope = this.scope(req);\n    return this.get(req.cacheKey, {\n      scope\n    });\n  }\n\n}\n\nconst COMPARISON_OPERATORS = ['eq', 'ne', 'gt', 'ge', 'lt', 'le'];\nconst LOGICAL_OPERATORS = ['and', 'or', 'not'];\nconst COLLECTION_OPERATORS = ['any', 'all'];\nconst BOOLEAN_FUNCTIONS = ['startswith', 'endswith', 'contains'];\nconst SUPPORTED_EXPAND_PROPERTIES = ['expand', 'levels', 'select', 'top', 'count', 'orderby', 'filter'];\nconst FUNCTION_REGEX = /\\((.*)\\)/;\nconst INDEXOF_REGEX = /(?!indexof)\\((\\w+)\\)/;\nvar StandardAggregateMethods = /*#__PURE__*/(() => {\n  (function (StandardAggregateMethods) {\n    StandardAggregateMethods[\"sum\"] = \"sum\";\n    StandardAggregateMethods[\"min\"] = \"min\";\n    StandardAggregateMethods[\"max\"] = \"max\";\n    StandardAggregateMethods[\"average\"] = \"average\";\n    StandardAggregateMethods[\"countdistinct\"] = \"countdistinct\";\n  })(StandardAggregateMethods || (StandardAggregateMethods = {}));\n\n  return StandardAggregateMethods;\n})();\nvar QueryCustomTypes = /*#__PURE__*/(() => {\n  (function (QueryCustomTypes) {\n    QueryCustomTypes[QueryCustomTypes[\"Raw\"] = 0] = \"Raw\";\n    QueryCustomTypes[QueryCustomTypes[\"Alias\"] = 1] = \"Alias\";\n    QueryCustomTypes[QueryCustomTypes[\"Duration\"] = 2] = \"Duration\";\n    QueryCustomTypes[QueryCustomTypes[\"Binary\"] = 3] = \"Binary\";\n  })(QueryCustomTypes || (QueryCustomTypes = {}));\n\n  return QueryCustomTypes;\n})();\n\n//https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_QueryOptions\nconst raw = value => ({\n  type: QueryCustomTypes.Raw,\n  value\n});\n\nconst alias = (value, name) => ({\n  type: QueryCustomTypes.Alias,\n  value,\n  name\n});\n\nconst duration = value => ({\n  type: QueryCustomTypes.Duration,\n  value\n});\n\nconst binary = value => ({\n  type: QueryCustomTypes.Binary,\n  value\n});\n\nconst isQueryCustomType = value => typeof value === 'object' && 'type' in value && value.type in QueryCustomTypes;\n\nconst ITEM_ROOT = '';\n\nfunction builder({\n  select,\n  search,\n  skiptoken,\n  format,\n  top,\n  skip,\n  filter,\n  transform,\n  orderBy,\n  key,\n  count,\n  expand,\n  action,\n  func,\n  aliases,\n  escape\n} = {}) {\n  const [path, params] = buildPathAndQuery({\n    select,\n    search,\n    skiptoken,\n    format,\n    top,\n    skip,\n    filter,\n    transform,\n    orderBy,\n    key,\n    count,\n    expand,\n    action,\n    func,\n    aliases,\n    escape\n  });\n  return buildUrl(path, params);\n}\n\nfunction buildPathAndQuery({\n  select,\n  search,\n  skiptoken,\n  format,\n  top,\n  skip,\n  filter,\n  transform,\n  orderBy,\n  key,\n  count,\n  expand,\n  action,\n  func,\n  aliases,\n  escape\n} = {}) {\n  let path = '';\n  aliases = aliases || [];\n  const query = {}; // key is not (null, undefined)\n\n  if (key != undefined) {\n    path += `(${normalizeValue(key, {\n      aliases,\n      escape\n    })})`;\n  }\n\n  if (select) {\n    query.$select = Array.isArray(select) ? select.join(',') : select;\n  }\n\n  if (search) {\n    query.$search = search;\n  }\n\n  if (skiptoken) {\n    query.$skiptoken = skiptoken;\n  }\n\n  if (format) {\n    query.$format = format;\n  }\n\n  if (filter || typeof count === 'object') {\n    query.$filter = buildFilter(typeof count === 'object' ? count : filter, {\n      aliases,\n      escape\n    });\n  }\n\n  if (transform) {\n    query.$apply = buildTransforms(transform, {\n      aliases,\n      escape\n    });\n  }\n\n  if (expand) {\n    query.$expand = buildExpand(expand, {\n      aliases,\n      escape\n    });\n  }\n\n  if (orderBy) {\n    query.$orderby = buildOrderBy(orderBy);\n  }\n\n  if (count) {\n    if (typeof count === 'boolean') {\n      query.$count = true;\n    } else {\n      path += '/$count';\n    }\n  }\n\n  if (typeof top === 'number') {\n    query.$top = top;\n  }\n\n  if (typeof skip === 'number') {\n    query.$skip = skip;\n  }\n\n  if (action) {\n    path += `/${action}`;\n  }\n\n  if (func) {\n    if (typeof func === 'string') {\n      path += `/${func}()`;\n    } else if (typeof func === 'object') {\n      const [funcName] = Object.keys(func);\n      const funcArgs = normalizeValue(func[funcName], {\n        aliases,\n        escape\n      });\n      path += `/${funcName}(${funcArgs})`;\n    }\n  }\n\n  if (aliases.length > 0) {\n    Object.assign(query, aliases.reduce((acc, alias) => Object.assign(acc, {\n      [`@${alias.name}`]: normalizeValue(alias.value, {\n        escape\n      })\n    }), {}));\n  } // Filter empty values\n\n\n  const params = Object.entries(query).filter(([, value]) => value !== undefined && value !== '').reduce((acc, [key, value]) => Object.assign(acc, {\n    [key]: value\n  }), {});\n  return [path, params];\n}\n\nfunction renderPrimitiveValue(key, val, {\n  aliases,\n  escape\n}) {\n  return `${key} eq ${normalizeValue(val, {\n    aliases,\n    escape\n  })}`;\n}\n\nfunction buildFilter(filters = {}, {\n  aliases,\n  propPrefix,\n  escape\n}) {\n  return (Array.isArray(filters) ? filters : [filters]).reduce((acc, filter) => {\n    if (filter) {\n      const builtFilter = buildFilterCore(filter, {\n        aliases,\n        propPrefix,\n        escape\n      });\n\n      if (builtFilter) {\n        acc.push(builtFilter);\n      }\n    }\n\n    return acc;\n  }, []).join(' and ');\n\n  function buildFilterCore(filter = {}, {\n    aliases,\n    propPrefix,\n    escape\n  }) {\n    let filterExpr = '';\n\n    if (typeof filter === 'string') {\n      // Use raw filter string\n      filterExpr = filter;\n    } else if (filter && typeof filter === 'object') {\n      const filtersArray = Object.keys(filter).reduce((result, filterKey) => {\n        const value = filter[filterKey];\n        let propName = '';\n\n        if (propPrefix) {\n          if (filterKey === ITEM_ROOT) {\n            propName = propPrefix;\n          } else if (INDEXOF_REGEX.test(filterKey)) {\n            propName = filterKey.replace(INDEXOF_REGEX, (_, $1) => $1.trim() === ITEM_ROOT ? `(${propPrefix})` : `(${propPrefix}/${$1.trim()})`);\n          } else if (FUNCTION_REGEX.test(filterKey)) {\n            propName = filterKey.replace(FUNCTION_REGEX, (_, $1) => $1.trim() === ITEM_ROOT ? `(${propPrefix})` : `(${propPrefix}/${$1.trim()})`);\n          } else {\n            propName = `${propPrefix}/${filterKey}`;\n          }\n        } else {\n          propName = filterKey;\n        }\n\n        if (filterKey === ITEM_ROOT && Array.isArray(value)) {\n          return result.concat(value.map(arrayValue => renderPrimitiveValue(propName, arrayValue, {\n            escape,\n            aliases\n          })));\n        }\n\n        if (['number', 'string', 'boolean'].indexOf(typeof value) !== -1 || value instanceof Date || value === null) {\n          // Simple key/value handled as equals operator\n          result.push(renderPrimitiveValue(propName, value, {\n            aliases,\n            escape\n          }));\n        } else if (Array.isArray(value)) {\n          const op = filterKey;\n          const builtFilters = value.map(v => buildFilter(v, {\n            aliases,\n            propPrefix,\n            escape\n          })).filter(f => f).map(f => LOGICAL_OPERATORS.indexOf(op) !== -1 ? `(${f})` : f);\n\n          if (builtFilters.length) {\n            if (LOGICAL_OPERATORS.indexOf(op) !== -1) {\n              if (builtFilters.length) {\n                if (op === 'not') {\n                  result.push(parseNot(builtFilters));\n                } else {\n                  result.push(`(${builtFilters.join(` ${op} `)})`);\n                }\n              }\n            } else {\n              result.push(builtFilters.join(` ${op} `));\n            }\n          }\n        } else if (LOGICAL_OPERATORS.indexOf(propName) !== -1) {\n          const op = propName;\n          const builtFilters = Object.keys(value).map(valueKey => buildFilterCore({\n            [valueKey]: value[valueKey]\n          }, {\n            aliases,\n            escape\n          }));\n\n          if (builtFilters.length) {\n            if (op === 'not') {\n              result.push(parseNot(builtFilters));\n            } else {\n              result.push(`${builtFilters.join(` ${op} `)}`);\n            }\n          }\n        } else if (typeof value === 'object') {\n          if ('type' in value) {\n            result.push(renderPrimitiveValue(propName, value, {\n              aliases,\n              escape\n            }));\n          } else {\n            const operators = Object.keys(value);\n            operators.forEach(op => {\n              if (COMPARISON_OPERATORS.indexOf(op) !== -1) {\n                result.push(`${propName} ${op} ${normalizeValue(value[op], {\n                  aliases,\n                  escape\n                })}`);\n              } else if (LOGICAL_OPERATORS.indexOf(op) !== -1) {\n                if (Array.isArray(value[op])) {\n                  result.push(value[op].map(v => '(' + buildFilterCore(v, {\n                    aliases,\n                    propPrefix: propName,\n                    escape\n                  }) + ')').join(` ${op} `));\n                } else {\n                  result.push('(' + buildFilterCore(value[op], {\n                    aliases,\n                    propPrefix: propName,\n                    escape\n                  }) + ')');\n                }\n              } else if (COLLECTION_OPERATORS.indexOf(op) !== -1) {\n                const collectionClause = buildCollectionClause(filterKey.toLowerCase(), value[op], op, propName);\n\n                if (collectionClause) {\n                  result.push(collectionClause);\n                }\n              } else if (op === 'has') {\n                result.push(`${propName} ${op} ${normalizeValue(value[op], {\n                  aliases,\n                  escape\n                })}`);\n              } else if (op === 'in') {\n                const resultingValues = Array.isArray(value[op]) ? value[op] : value[op].value.map(typedValue => ({\n                  type: value[op].type,\n                  value: typedValue\n                }));\n                result.push(propName + ' in (' + resultingValues.map(v => normalizeValue(v, {\n                  aliases,\n                  escape\n                })).join(',') + ')');\n              } else if (BOOLEAN_FUNCTIONS.indexOf(op) !== -1) {\n                // Simple boolean functions (startswith, endswith, contains)\n                result.push(`${op}(${propName},${normalizeValue(value[op], {\n                  aliases,\n                  escape\n                })})`);\n              } else {\n                // Nested property\n                const filter = buildFilterCore(value, {\n                  aliases,\n                  propPrefix: propName,\n                  escape\n                });\n\n                if (filter) {\n                  result.push(filter);\n                }\n              }\n            });\n          }\n        } else if (value === undefined) {// Ignore/omit filter if value is `undefined`\n        } else {\n          throw new Error(`Unexpected value type: ${value}`);\n        }\n\n        return result;\n      }, []);\n      filterExpr = filtersArray.join(' and ');\n    }\n    /* else {\n      throw new Error(`Unexpected filters type: ${filter}`);\n    } */\n\n\n    return filterExpr;\n  }\n\n  function buildCollectionClause(lambdaParameter, value, op, propName) {\n    let clause = '';\n\n    if (typeof value === 'string' || value instanceof String) {\n      clause = getStringCollectionClause(lambdaParameter, value, op, propName);\n    } else if (value) {\n      // normalize {any:[{prop1: 1}, {prop2: 1}]} --> {any:{prop1: 1, prop2: 1}}; same for 'all',\n      // simple values collection: {any:[{'': 'simpleVal1'}, {'': 'simpleVal2'}]} --> {any:{'': ['simpleVal1', 'simpleVal2']}}; same for 'all',\n      const filterValue = Array.isArray(value) ? value.reduce((acc, item) => {\n        if (item.hasOwnProperty(ITEM_ROOT)) {\n          if (!acc.hasOwnProperty(ITEM_ROOT)) {\n            acc[ITEM_ROOT] = [];\n          }\n\n          acc[ITEM_ROOT].push(item[ITEM_ROOT]);\n          return acc;\n        }\n\n        return Object.assign(Object.assign({}, acc), item);\n      }, {}) : value;\n      const filter = buildFilterCore(filterValue, {\n        aliases,\n        propPrefix: lambdaParameter,\n        escape\n      });\n      clause = `${propName}/${op}(${filter ? `${lambdaParameter}:${filter}` : ''})`;\n    }\n\n    return clause;\n  }\n}\n\nfunction getStringCollectionClause(lambdaParameter, value, collectionOperator, propName) {\n  let clause = '';\n  const conditionOperator = collectionOperator == 'all' ? 'ne' : 'eq';\n  clause = `${propName}/${collectionOperator}(${lambdaParameter}: ${lambdaParameter} ${conditionOperator} '${value}')`;\n  return clause;\n}\n\nfunction escapeIllegalChars(string) {\n  string = string.replace(/%/g, '%25');\n  string = string.replace(/\\+/g, '%2B');\n  string = string.replace(/\\//g, '%2F');\n  string = string.replace(/\\?/g, '%3F');\n  string = string.replace(/#/g, '%23');\n  string = string.replace(/&/g, '%26');\n  string = string.replace(/'/g, \"''\");\n  return string;\n}\n\nfunction normalizeValue(value, {\n  aliases,\n  escape = false\n} = {}) {\n  if (typeof value === 'string') {\n    return escape ? `'${escapeIllegalChars(value)}'` : `'${value}'`;\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } else if (typeof value === 'number') {\n    return value;\n  } else if (Array.isArray(value)) {\n    return `[${value.map(d => normalizeValue(d, {\n      aliases,\n      escape\n    })).join(',')}]`;\n  } else if (value === null) {\n    return value;\n  } else if (typeof value === 'object') {\n    switch (value.type) {\n      case QueryCustomTypes.Raw:\n        return value.value;\n\n      case QueryCustomTypes.Duration:\n        return `duration'${value.value}'`;\n\n      case QueryCustomTypes.Binary:\n        return `binary'${value.value}'`;\n\n      case QueryCustomTypes.Alias:\n        // Store\n        if (Array.isArray(aliases)) {\n          if (value.name === undefined) {\n            value.name = `a${aliases.length + 1}`;\n          }\n\n          aliases.push(value);\n        }\n\n        return `@${value.name}`;\n\n      default:\n        return Object.entries(value).filter(([, v]) => v !== undefined).map(([k, v]) => `${k}=${normalizeValue(v, {\n          aliases,\n          escape\n        })}`).join(',');\n    }\n  }\n\n  return value;\n}\n\nfunction buildExpand(expands, {\n  aliases,\n  escape = false\n}) {\n  if (typeof expands === 'number') {\n    return expands;\n  } else if (typeof expands === 'string') {\n    if (expands.indexOf('/') === -1) {\n      return expands;\n    } // Change `Foo/Bar/Baz` to `Foo($expand=Bar($expand=Baz))`\n\n\n    return expands.split('/').reverse().reduce((results, item, index, arr) => {\n      if (index === 0) {\n        // Inner-most item\n        return `$expand=${item}`;\n      } else if (index === arr.length - 1) {\n        // Outer-most item, don't add `$expand=` prefix (added above)\n        return `${item}(${results})`;\n      } else {\n        // Other items\n        return `$expand=${item}(${results})`;\n      }\n    }, '');\n  } else if (Array.isArray(expands)) {\n    return `${expands.map(e => buildExpand(e, {\n      aliases,\n      escape\n    })).join(',')}`;\n  } else if (typeof expands === 'object') {\n    const expandKeys = Object.keys(expands);\n\n    if (expandKeys.some(key => SUPPORTED_EXPAND_PROPERTIES.indexOf(key.toLowerCase()) !== -1)) {\n      return expandKeys.map(key => {\n        let value;\n\n        switch (key) {\n          case 'filter':\n            value = buildFilter(expands[key], {\n              aliases,\n              escape\n            });\n            break;\n\n          case 'orderBy':\n            value = buildOrderBy(expands[key]);\n            break;\n\n          case 'levels':\n          case 'count':\n          case 'top':\n          case 'skip':\n            value = `${expands[key]}`;\n            break;\n\n          default:\n            value = buildExpand(expands[key], {\n              aliases,\n              escape\n            });\n        }\n\n        return `$${key.toLowerCase()}=${value}`;\n      }).join(';');\n    } else {\n      return expandKeys.map(key => {\n        const builtExpand = buildExpand(expands[key], {\n          aliases,\n          escape\n        });\n        return builtExpand ? `${key}(${builtExpand})` : key;\n      }).join(',');\n    }\n  }\n\n  return '';\n}\n\nfunction buildTransforms(transforms, {\n  aliases,\n  escape = false\n}) {\n  // Wrap single object an array for simplified processing\n  const transformsArray = Array.isArray(transforms) ? transforms : [transforms];\n  const transformsResult = transformsArray.reduce((result, transform) => {\n    const {\n      aggregate,\n      filter,\n      groupBy\n    } = transform,\n          rest = __rest(transform, [\"aggregate\", \"filter\", \"groupBy\"]); // TODO: support as many of the following:\n    //   topcount, topsum, toppercent,\n    //   bottomsum, bottomcount, bottompercent,\n    //   identity, concat, expand, search, compute, isdefined\n\n\n    const unsupportedKeys = Object.keys(rest);\n\n    if (unsupportedKeys.length) {\n      throw new Error(`Unsupported transform(s): ${unsupportedKeys}`);\n    }\n\n    if (aggregate) {\n      result.push(`aggregate(${buildAggregate(aggregate)})`);\n    }\n\n    if (filter) {\n      const builtFilter = buildFilter(filter, {\n        aliases,\n        escape\n      });\n\n      if (builtFilter) {\n        result.push(`filter(${buildFilter(builtFilter, {\n          aliases,\n          escape\n        })})`);\n      }\n    }\n\n    if (groupBy) {\n      result.push(`groupby(${buildGroupBy(groupBy, {\n        aliases,\n        escape\n      })})`);\n    }\n\n    return result;\n  }, []);\n  return transformsResult.join('/') || undefined;\n}\n\nfunction buildAggregate(aggregate) {\n  // Wrap single object in an array for simplified processing\n  const aggregateArray = Array.isArray(aggregate) ? aggregate : [aggregate];\n  return aggregateArray.map(aggregateItem => {\n    return typeof aggregateItem === 'string' ? aggregateItem : Object.keys(aggregateItem).map(aggregateKey => {\n      const aggregateValue = aggregateItem[aggregateKey]; // TODO: Are these always required?  Can/should we default them if so?\n\n      if (!aggregateValue.with) {\n        throw new Error(`'with' property required for '${aggregateKey}'`);\n      }\n\n      if (!aggregateValue.as) {\n        throw new Error(`'as' property required for '${aggregateKey}'`);\n      }\n\n      return `${aggregateKey} with ${aggregateValue.with} as ${aggregateValue.as}`;\n    });\n  }).join(',');\n}\n\nfunction buildGroupBy(groupBy, {\n  aliases,\n  escape = false\n}) {\n  if (!groupBy.properties) {\n    throw new Error(`'properties' property required for groupBy`);\n  }\n\n  let result = `(${groupBy.properties.join(',')})`;\n\n  if (groupBy.transform) {\n    result += `,${buildTransforms(groupBy.transform, {\n      aliases,\n      escape\n    })}`;\n  }\n\n  return result;\n}\n\nfunction buildOrderBy(orderBy, prefix = '') {\n  if (Array.isArray(orderBy)) {\n    return orderBy.map(value => Array.isArray(value) && value.length === 2 && ['asc', 'desc'].indexOf(value[1]) !== -1 ? value.join(' ') : value).map(v => `${prefix}${v}`).join(',');\n  } else if (typeof orderBy === 'object') {\n    return Object.entries(orderBy).map(([k, v]) => buildOrderBy(v, `${k}/`)).map(v => `${prefix}${v}`).join(',');\n  }\n\n  return `${prefix}${orderBy}`;\n}\n\nfunction buildUrl(path, params) {\n  // This can be refactored using URL API. But IE does not support it.\n  const queries = Object.entries(params).map(([key, value]) => `${key}=${value}`);\n  return queries.length ? `${path}?${queries.join('&')}` : path;\n}\n\nfunction parseNot(builtFilters) {\n  return `not(${builtFilters.join(' and ')})`;\n}\n\nconst ISO_REGEX = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\nconst Dates = {\n  isoStringToDate(value) {\n    if (typeof value === 'string' && value.search(ISO_REGEX) === 0) {\n      return new Date(value);\n    } else if (Array.isArray(value)) {\n      return value.map(v => this.isoStringToDate(v));\n    } else if (value && value.constructor === Object) {\n      return Object.keys(value).map(key => [key, this.isoStringToDate(value[key])]).reduce((acc, v) => Object.assign(acc, {\n        [v[0]]: v[1]\n      }), {});\n    }\n\n    return value;\n  }\n\n};\nconst DURATION_REGEX = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\nconst Durations = {\n  toDuration(v) {\n    const matches = DURATION_REGEX.exec(v);\n\n    if (!matches || v.length < 3) {\n      throw new TypeError(`duration invalid: \"${v}\". Must be a ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations`);\n    }\n\n    let duration = {};\n    duration.sign = matches[1] === '-' ? -1 : 1;\n    return ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'].reduce((acc, name, index) => {\n      const v = parseFloat(matches[index + 2]);\n      if (!Number.isNaN(v)) acc[name] = v;\n      return acc;\n    }, duration);\n  },\n\n  toString(v) {\n    return [v.sign === -1 ? '-' : '', 'P', v.years ? v.years + 'Y' : '', v.months ? v.months + 'M' : '', v.weeks ? v.weeks + 'W' : '', v.days ? v.days + 'D' : '', 'T', v.hours ? v.hours + 'H' : '', v.minutes ? v.minutes + 'M' : '', v.seconds ? v.seconds + 'S' : ''].join('');\n  }\n\n};\nconst Enums = {\n  names(Enum) {\n    return Object.values(Enum).filter(v => typeof v === 'string');\n  },\n\n  values(Enum) {\n    return Object.values(Enum).filter(v => typeof v === 'number');\n  },\n\n  toValue(Enum, value) {\n    if (value in Enum) return typeof value === 'string' ? Enum[value] : value;\n    return undefined;\n  },\n\n  toValues(Enum, value) {\n    if (typeof value === 'number') {\n      return this.values(Enum).filter(v => (value & v) === v);\n    }\n\n    if (typeof value === 'string') {\n      value = value.split(',').map(o => o.trim());\n    }\n\n    if (Array.isArray(value) && value.every(v => v in Enum)) {\n      return value.map(o => this.toValue(Enum, o));\n    }\n\n    return [];\n  },\n\n  toName(Enum, value) {\n    if (value in Enum) return typeof value === 'number' ? Enum[value] : value;\n    return undefined;\n  },\n\n  toNames(Enum, value) {\n    if (typeof value === 'number') {\n      return this.values(Enum).filter(v => (value & v) === v).map(v => this.toName(Enum, v));\n    }\n\n    if (typeof value === 'string') {\n      value = value.split(',').map(o => o.trim());\n    }\n\n    if (Array.isArray(value) && value.every(v => v in Enum)) {\n      return value.map(o => this.toName(Enum, o));\n    }\n\n    return [];\n  }\n\n};\n\nfunction cloneSymbol(targe) {\n  return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n  const reFlags = /\\w*$/;\n  const result = new targe.constructor(targe.source, reFlags.exec(targe));\n  result.lastIndex = targe.lastIndex;\n  return result;\n}\n\nconst Types = {\n  rawType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n  },\n\n  isObject(value) {\n    var type = typeof value;\n    return value != null && (type === 'object' || type === 'function');\n  },\n\n  isPlainObject(value) {\n    if (this.rawType(value) !== 'Object') {\n      return false;\n    }\n\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n  },\n\n  isFunction(value) {\n    return typeof value === 'function';\n  },\n\n  isArray(value) {\n    return Array.isArray(value);\n  },\n\n  isMap(value) {\n    return this.rawType(value) === 'Map';\n  },\n\n  isEmpty(value) {\n    return value === undefined || value === null || typeof value === 'string' && !value.length || Types.isMap(value) && !value.size || Types.isArray(value) && !value.length || Types.isFunction(value.isEmpty) && value.isEmpty() || Types.isArray(value) && value.every(v => Types.isEmpty(v)) || Types.isObject(value) && !Object.keys(value).filter(k => value.hasOwnProperty(k)).length || Types.isPlainObject(value) && !Object.keys(value).filter(k => value.hasOwnProperty(k)).length;\n  },\n\n  isEqual(value1, value2) {\n    function getType(obj) {\n      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n    }\n\n    function areDatesEqual() {\n      return value1.getTime() === value2.getTime();\n    }\n\n    function areArraysBufferEqual() {\n      if (value1.byteLength !== value2.byteLength) {\n        return false;\n      }\n\n      var view1 = new DataView(value1);\n      var view2 = new DataView(value2);\n      var i = value1.byteLength;\n\n      while (i--) {\n        if (view1.getUint8(i) !== view2.getUint8(i)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function areArraysEqual() {\n      // Check length\n      if (value1.length !== value2.length) return false; // Check each item in the array\n\n      for (let i = 0; i < value1.length; i++) {\n        if (!Types.isEqual(value1[i], value2[i])) return false;\n      } // If no errors, return true\n\n\n      return true;\n    }\n\n    function areObjectsEqual() {\n      if (Object.keys(value1).length !== Object.keys(value2).length) return false; // Check each item in the object\n\n      for (let key in value1) {\n        if (Object.prototype.hasOwnProperty.call(value1, key)) {\n          if (!Types.isEqual(value1[key], value2[key])) return false;\n        }\n      } // If no errors, return true\n\n\n      return true;\n    }\n\n    function areFunctionsEqual() {\n      return value1.toString() === value2.toString();\n    }\n\n    function arePrimativesEqual() {\n      return value1 === value2;\n    } // Get the object type\n\n\n    let type = getType(value1); // If the two items are not the same type, return false\n\n    if (type !== getType(value2)) return false; // Compare based on type\n\n    if (type === 'date') return areDatesEqual();\n    if (type === 'arraybuffer') return areArraysBufferEqual();\n    if (type === 'array') return areArraysEqual();\n    if (type === 'object') return areObjectsEqual();\n    if (type === 'function') return areFunctionsEqual();\n    return arePrimativesEqual();\n  },\n\n  clone(target) {\n    const constrFun = target.constructor;\n\n    switch (this.rawType(target)) {\n      case 'Boolean':\n      case 'Number':\n      case 'String':\n      case 'Error':\n      case 'Date':\n        return new constrFun(target);\n\n      case 'RegExp':\n        return cloneReg(target);\n\n      case 'Symbol':\n        return cloneSymbol(target);\n\n      case 'Function':\n        return target;\n\n      default:\n        return null;\n    }\n  }\n\n};\nconst Http = {\n  //Merge Headers\n  mergeHttpHeaders(...values) {\n    let headers = new HttpHeaders();\n    values.forEach(value => {\n      if (value instanceof HttpHeaders) {\n        value.keys().forEach(key => {\n          headers = (value.getAll(key) || []).reduce((acc, v) => acc.append(key, v), headers);\n        });\n      } else if (Types.isPlainObject(value)) {\n        Object.entries(value).forEach(([key, value]) => {\n          headers = (Array.isArray(value) ? value : [value]).reduce((acc, v) => acc.append(key, v), headers);\n        });\n      }\n    });\n    return headers;\n  },\n\n  // Merge Params\n  mergeHttpParams(...values) {\n    let params = new HttpParams();\n    values.forEach(value => {\n      if (value instanceof HttpParams) {\n        value.keys().forEach(key => {\n          params = (value.getAll(key) || []).reduce((acc, v) => acc.append(key, v), params);\n        });\n      } else if (Types.isPlainObject(value)) {\n        Object.entries(value).forEach(([key, value]) => {\n          params = (Array.isArray(value) ? value : [value]).reduce((acc, v) => acc.append(key, v), params);\n        });\n      }\n    });\n    return params;\n  },\n\n  // Split Params\n  splitHttpParams(params, keys) {\n    let other = new HttpParams();\n    params.keys().forEach(key => {\n      if (keys.includes(key)) {\n        other = (params.getAll(key) || []).reduce((acc, v) => acc.append(key, v), other);\n        params = params.delete(key);\n      }\n    });\n    return [params, other];\n  },\n\n  // Without Params\n  withoutHttpParams(params, keys) {\n    return keys.reduce((acc, key) => acc.delete(key), params);\n  },\n\n  resolveHeaderKey(headers, options) {\n    if (headers instanceof HttpHeaders) {\n      return headers.keys().find(k => options.indexOf(k) !== -1);\n    } else if (Types.isPlainObject(headers)) {\n      return Object.keys(headers).find(k => options.indexOf(k) !== -1);\n    }\n\n    return undefined;\n  },\n\n  headerValue(header) {\n    let res = header.split(';')[0].trim();\n    res = res.split(':')[1].trim();\n    return res;\n  },\n\n  parseResponseStatus(statusLine) {\n    const status = statusLine.split(' ')[0];\n    const code = parseInt(statusLine.split(' ')[1], 10);\n    const message = statusLine.split(' ')[2];\n    return {\n      status,\n      code,\n      message\n    };\n  },\n\n  boundaryDelimiter(contentType) {\n    const contentTypeParts = contentType.split(';');\n\n    if (contentTypeParts.length === 2) {\n      const boundary = contentType.split(';')[1].trim();\n      const boundaryDelimiter = BOUNDARY_PREFIX_SUFFIX + boundary.split('=')[1];\n      return boundaryDelimiter;\n    } else {\n      return '';\n    }\n  },\n\n  boundaryEnd(boundaryDelimiter) {\n    if (!boundaryDelimiter.length) {\n      return '';\n    }\n\n    const boundaryEnd = boundaryDelimiter + BOUNDARY_PREFIX_SUFFIX;\n    return boundaryEnd;\n  }\n\n};\n\nfunction forEach(array, iteratee) {\n  let index = -1;\n  const length = array.length;\n\n  while (++index < length) {\n    iteratee(array[index], index);\n  }\n\n  return array;\n}\n\nconst Objects = {\n  set(obj, path, value) {\n    // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    pathArray.reduce((acc, key, i) => {\n      if (acc[key] === undefined) acc[key] = {};\n      if (i === pathArray.length - 1) acc[key] = value;\n      return acc[key];\n    }, obj);\n  },\n\n  get(obj, path, def) {\n    // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g); // Find value if exist return otherwise return undefined value;\n\n    return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], obj) || def;\n  },\n\n  unset(obj, path) {\n    // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    pathArray.reduce((acc, key, i) => {\n      if (i === pathArray.length - 1) delete acc[key];\n      return acc[key];\n    }, obj);\n  },\n\n  has(obj, path) {\n    // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    return !!pathArray.reduce((prevObj, key) => prevObj && prevObj[key], obj);\n  },\n\n  merge(target, source) {\n    const merge = (target, source) => {\n      for (let attr in source) {\n        let value = source[attr];\n\n        if (value !== null && Types.isPlainObject(value) && attr in target) {\n          merge(target[attr], value);\n        } else if (target[attr] !== value) {\n          target[attr] = value;\n        }\n      }\n    };\n\n    merge(target, source);\n    return target;\n  },\n\n  equal(object1, object2) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n      const val2 = object2[key];\n      const areObjects = Types.isPlainObject(val1) && Types.isPlainObject(val2);\n\n      if (areObjects && !Objects.equal(val1, val2) || !areObjects && val1 !== val2) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  difference(object1, object2) {\n    if (!object2 || !Types.isPlainObject(object2)) {\n      return object1;\n    }\n\n    var diffs = {};\n    var key;\n\n    var arraysMatch = function (arr1, arr2) {\n      if (arr1.length !== arr2.length) return false;\n\n      for (var i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) return false;\n      }\n\n      return true;\n    };\n\n    var compare = function (item1, item2, key) {\n      if (item2 === undefined) {\n        diffs[key] = null;\n        return;\n      }\n\n      if (typeof item1 !== typeof item2) {\n        diffs[key] = item2;\n        return;\n      }\n\n      if (Types.isPlainObject(item1)) {\n        var objDiff = Objects.difference(item1, item2);\n\n        if (Object.keys(objDiff).length > 0) {\n          diffs[key] = objDiff;\n        }\n\n        return;\n      }\n\n      if (Array.isArray(item1)) {\n        if (!arraysMatch(item1, item2)) {\n          diffs[key] = item2;\n        }\n\n        return;\n      }\n\n      if (item1 !== item2) {\n        diffs[key] = item2;\n      }\n    };\n\n    for (key in object1) {\n      if (object1.hasOwnProperty(key)) {\n        compare(object1[key], object2[key], key);\n      }\n    }\n\n    for (key in object2) {\n      if (object2.hasOwnProperty(key)) {\n        if (!object1[key] && object1[key] !== object2[key]) {\n          diffs[key] = object2[key];\n        }\n      }\n    }\n\n    return diffs;\n  },\n\n  resolveKey(key, {\n    single = true\n  } = {}) {\n    const type = Types.rawType(key);\n    if (['number', 'string'].indexOf(type) !== -1) return key;\n\n    if (type !== 'Map' && type !== 'Object') {\n      return undefined;\n    }\n\n    const values = type === 'Map' ? Array.from(key.values()) : Object.values(key);\n\n    if (values.length === 1 && single) {\n      // Single primitive key value\n      key = values[0];\n      return !Types.isEmpty(key) ? key : undefined;\n    } else if (values.some(v => v === undefined)) {\n      // Compose key, needs all values\n      return undefined;\n    } else {\n      const obj = type === 'Map' ? Object.fromEntries(key) : key;\n      return !Types.isEmpty(obj) ? obj : undefined;\n    }\n  },\n\n  clone(target, map) {\n    if (map === undefined) map = new WeakMap(); // clone primitive types\n\n    if (typeof target != 'object' || target == null) {\n      return target;\n    }\n\n    if (Types.isObject(target) && 'clone' in target) {\n      // target is a cloneable object\n      return target.clone();\n    }\n\n    const type = Types.rawType(target);\n    let cloneTarget = null;\n\n    if (map.get(target)) {\n      return map.get(target);\n    }\n\n    map.set(target, cloneTarget);\n\n    if (type != 'Set' && type != 'Map' && type != 'Array' && type != 'Object') {\n      return Types.clone(target);\n    } // clone Set\n\n\n    if (type == 'Set') {\n      cloneTarget = new Set();\n      target.forEach(value => {\n        cloneTarget.add(this.clone(value, map));\n      });\n      return cloneTarget;\n    } // clone Map\n\n\n    if (type == 'Map') {\n      cloneTarget = new Map();\n      target.forEach((value, key) => {\n        cloneTarget.set(key, this.clone(value, map));\n      });\n      return cloneTarget;\n    } // clone Array\n\n\n    if (type == 'Array') {\n      cloneTarget = new Array();\n      forEach(target, (value, index) => {\n        cloneTarget[index] = this.clone(value, map);\n      });\n    } // clone normal Object\n\n\n    if (type == 'Object') {\n      cloneTarget = new Object();\n      forEach(Object.keys(target), (key, index) => {\n        cloneTarget[key] = this.clone(target[key], map);\n      });\n    }\n\n    return cloneTarget;\n  }\n\n};\nconst OData = {\n  // Merge callables parameters\n  mergeCallableParameters(callables) {\n    const areEqual = (a, b) => a.name === b.name && Objects.equal((a.parameters || {})[CALLABLE_BINDING_PARAMETER] || {}, (b.parameters || {})[CALLABLE_BINDING_PARAMETER] || {});\n\n    return callables.reduce((acc, config) => {\n      if (acc.every(c => !areEqual(c, config))) {\n        config = callables.filter(c => areEqual(c, config)).reduce((acc, c) => {\n          acc.parameters = Object.assign(acc.parameters || {}, c.parameters || {});\n          return acc;\n        }, config);\n        return [...acc, config];\n      }\n\n      return acc;\n    }, []);\n  }\n\n}; // From https://github.com/adamhalasz/uniqid\n\nvar glast;\n\nfunction now() {\n  let time = Date.now();\n  let last = glast || time;\n  return glast = time > last ? time : last + 1;\n}\n\nconst Strings = {\n  uniqueId(prefix, suffix) {\n    return (prefix ? prefix : '') + now().toString(36) + (suffix ? suffix : '');\n  },\n\n  titleCase(text) {\n    const result = text.replace(/([a-z])([A-Z])/g, '$1 $2');\n    return result.split(' ').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ');\n  }\n\n};\nconst Urls = {\n  parseQueryString(query) {\n    return query.split(PARAM_SEPARATOR).reduce((acc, param) => {\n      let index = param.indexOf(VALUE_SEPARATOR);\n      if (index !== -1) Object.assign(acc, {\n        [param.substring(0, index)]: param.substring(index + 1)\n      });\n      return acc;\n    }, {});\n  },\n\n  escapeIllegalChars(string) {\n    string = string.replace(/%/g, '%25');\n    string = string.replace(/\\+/g, '%2B');\n    string = string.replace(/\\//g, '%2F');\n    string = string.replace(/\\?/g, '%3F');\n    string = string.replace(/#/g, '%23');\n    string = string.replace(/&/g, '%26');\n    string = string.replace(/'/g, \"''\");\n    return string;\n  }\n\n};\n\nclass Expression {\n  constructor({\n    children\n  } = {}) {\n    this._children = children || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Expression';\n  }\n\n  children() {\n    return this._children;\n  }\n\n  length() {\n    return this._children.length;\n  }\n\n  toJSON() {\n    return {\n      children: this._children.map(c => c.toJSON())\n    };\n  }\n\n}\n\nclass Field$1 {\n  constructor(name = '') {\n    this.name = name;\n  }\n\n  static factory(name = '') {\n    return new Proxy({\n      _name: name\n    }, new Field$1());\n  }\n\n  get(target, key) {\n    let name = target['_name'];\n\n    if (key === 'render') {\n      return ({\n        prefix\n      }) => prefix ? `${prefix}/${name}` : name;\n    } else if (key === 'clone') {\n      return () => Field$1.factory(name);\n    } else if (key === Symbol.toStringTag) {\n      return () => 'Field';\n    } else if (key === 'toJSON') {\n      return () => ({\n        $type: Types.rawType(this),\n        name: name\n      });\n    } else {\n      name = name ? `${name}/${key}` : key;\n      return new Proxy({\n        _name: name\n      }, this);\n    }\n  }\n\n  has(target, key) {\n    return ['toJSON', 'clone', 'render'].includes(key) || key in target;\n  }\n\n}\n\nfunction applyMixins(derivedCtor, constructors) {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));\n    });\n  });\n}\n\nfunction render(value, {\n  aliases,\n  normalize,\n  escape,\n  prefix\n} = {}) {\n  if (typeof value === 'function') {\n    return render(value(syntax), {\n      aliases,\n      normalize,\n      prefix\n    });\n  }\n\n  if (typeof value === 'object' && value !== null && value.render !== undefined) {\n    return render(value.render({\n      aliases,\n      escape,\n      prefix\n    }), {\n      aliases,\n      normalize,\n      escape,\n      prefix\n    });\n  }\n\n  return normalize ? normalizeValue(value, {\n    aliases,\n    escape\n  }) : value;\n}\n\nclass Function {\n  constructor(name, values, normalize = true, escape = false) {\n    this.name = name;\n    this.values = values;\n    this.normalize = normalize;\n    this.escape = escape;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Function';\n  }\n\n  toJSON() {\n    return {\n      $type: Types.rawType(this),\n      name: this.name,\n      values: this.values,\n      normalize: this.normalize\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    let [field, ...values] = this.values;\n    field = render(field, {\n      aliases,\n      escape,\n      prefix\n    });\n    const params = [field, ...values.map(v => render(v, {\n      aliases,\n      escape,\n      prefix,\n      normalize: this.normalize\n    }))];\n    return `${this.name}(${params.join(', ')})`;\n  }\n\n  clone() {\n    return new Function(this.name, this.values.map(v => Objects.clone(v)), this.normalize, this.escape);\n  }\n\n}\n\nclass StringAndCollectionFunctions {\n  concat(field, value, normalize) {\n    return new Function('concat', [field, value], normalize);\n  }\n\n  contains(field, value, normalize) {\n    return new Function('contains', [field, value], normalize);\n  }\n\n  endsWith(field, value, normalize) {\n    return new Function('endswith', [field, value], normalize);\n  }\n\n  indexOf(field, value, normalize) {\n    return new Function('indexof', [field, value], normalize);\n  }\n\n  length(value, normalize) {\n    return new Function('length', [value], normalize);\n  }\n\n  startsWith(field, value, normalize) {\n    return new Function('startswith', [field, value], normalize);\n  }\n\n  subString(field, start, length) {\n    let values = [field, start];\n\n    if (length !== undefined) {\n      values.push(length);\n    }\n\n    return new Function('substring', values);\n  }\n\n}\n\nclass CollectionFunctions {\n  hasSubset(s1, s2) {\n    return new Function('hassubset', [s1, s2]);\n  }\n\n  hasSubsequence(s1, s2) {\n    return new Function('hassubsequence', [s1, s2]);\n  }\n\n}\n\nclass StringFunctions {\n  matchesPattern(value, pattern) {\n    return new Function('matchesPattern', [value, pattern]);\n  }\n\n  toLower(value) {\n    return new Function('tolower', [value]);\n  }\n\n  toUpper(value) {\n    return new Function('toupper', [value]);\n  }\n\n  trim(value) {\n    return new Function('trim', [value]);\n  }\n\n}\n\nclass DateAndTimeFunctions {\n  date(value) {\n    return new Function('date', [value]);\n  }\n\n  day(value) {\n    return new Function('day', [value]);\n  }\n\n  fractionalseconds(value) {\n    return new Function('fractionalseconds', [value]);\n  }\n\n  hour(value) {\n    return new Function('hour', [value]);\n  }\n\n  maxdatetime(value) {\n    return new Function('maxdatetime', [value]);\n  }\n\n  mindatetime(value) {\n    return new Function('mindatetime', [value]);\n  }\n\n  minute(value) {\n    return new Function('minute', [value]);\n  }\n\n  month(value) {\n    return new Function('month', [value]);\n  }\n\n  now() {\n    return new Function('now', []);\n  }\n\n  second(value) {\n    return new Function('second', [value]);\n  }\n\n  time(value) {\n    return new Function('time', [value]);\n  }\n\n  totaloffsetminutes(value) {\n    return new Function('totaloffsetminutes', [value]);\n  }\n\n  totalseconds(value) {\n    return new Function('totalseconds', [value]);\n  }\n\n  year(value) {\n    return new Function('year', [value]);\n  }\n\n}\n\nclass ArithmeticFunctions {\n  ceiling(value) {\n    return new Function('ceiling', [value]);\n  }\n\n  floor(value) {\n    return new Function('floor', [value]);\n  }\n\n  round(value) {\n    return new Function('round', [value]);\n  }\n\n}\n\nclass TypeFunctions {\n  cast(value, type) {\n    return new Function('cast', [value, type]);\n  }\n\n  isof(value, type) {\n    return new Function('isof', [value, type]);\n  }\n\n}\n\nclass GeoFunctions {\n  geoDistance(value, point, normalize) {\n    return new Function('geo.distance', [value, point], normalize);\n  }\n\n  geoIntersects(value, polygon, normalize) {\n    return new Function('geo.intersects', [value, polygon], normalize);\n  }\n\n  geoLength(line, normalize) {\n    return new Function('geo.length', [line], normalize);\n  }\n\n}\n\nclass ConditionalFunctions {\n  case(condition, value) {\n    return new Function('case', [condition, value]);\n  }\n\n}\n\nclass Operator {\n  constructor(op, values, normalize = true) {\n    this.op = op;\n    this.values = values;\n    this.normalize = normalize;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Operator';\n  }\n\n  toJSON() {\n    return {\n      $type: Types.rawType(this),\n      op: this.op,\n      values: this.values,\n      normalize: this.normalize\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    let [left, right] = this.values;\n    left = render(left, {\n      aliases,\n      escape,\n      prefix\n    });\n\n    if (right !== undefined) {\n      right = Array.isArray(right) ? `(${right.map(v => render(v, {\n        aliases,\n        escape,\n        prefix,\n        normalize: this.normalize\n      })).join(',')})` : render(right, {\n        aliases,\n        escape,\n        prefix,\n        normalize: this.normalize\n      });\n      return `${left} ${this.op} ${right}`;\n    }\n\n    return `${this.op}(${left})`;\n  }\n\n  clone() {\n    return new Operator(this.op, this.values.map(v => Objects.clone(v)), this.normalize);\n  }\n\n}\n\nclass LogicalOperators {\n  eq(left, right, normalize) {\n    return new Operator('eq', [left, right], normalize);\n  }\n\n  ne(left, right, normalize) {\n    return new Operator('ne', [left, right], normalize);\n  }\n\n  gt(left, right, normalize) {\n    return new Operator('gt', [left, right], normalize);\n  }\n\n  ge(left, right, normalize) {\n    return new Operator('ge', [left, right], normalize);\n  }\n\n  lt(left, right, normalize) {\n    return new Operator('lt', [left, right], normalize);\n  }\n\n  le(left, right, normalize) {\n    return new Operator('le', [left, right], normalize);\n  }\n  /*\n  and(left: any, right: any, normalize?: boolean) {\n    return new Operator('and', [left, right], normalize);\n  }\n  or(left: any, right: any, normalize?: boolean) {\n    return new Operator('or', [left, right], normalize);\n  }\n  */\n\n\n  not(value, normalize) {\n    return new Operator('not', [value], normalize);\n  }\n\n  has(left, right, normalize) {\n    return new Operator('has', [left, right], normalize);\n  }\n\n  in(left, right, normalize) {\n    return new Operator('in', [left, right], normalize);\n  }\n\n}\n\nclass ArithmeticOperators {\n  add(left, right, normalize) {\n    return new Operator('add', [left, right], normalize);\n  }\n\n  sub(left, right, normalize) {\n    return new Operator('sub', [left, right], normalize);\n  }\n\n  mul(left, right, normalize) {\n    return new Operator('mul', [left, right], normalize);\n  }\n\n  div(left, right, normalize) {\n    return new Operator('div', [left, right], normalize);\n  }\n\n  mod(left, right, normalize) {\n    return new Operator('mod', [left, right], normalize);\n  }\n\n  neg(value, normalize) {\n    return new Operator('-', [value], normalize);\n  }\n\n}\n\nclass Grouping {\n  constructor(group) {\n    this.group = group;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Grouping';\n  }\n\n  toJSON() {\n    return {\n      $type: Types.rawType(this),\n      group: this.group.toJSON()\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    return `(${render(this.group, {\n      aliases,\n      escape,\n      prefix\n    })})`;\n  }\n\n  clone() {\n    return new Grouping(Objects.clone(this.group));\n  }\n\n}\n\nclass Lambda {\n  constructor(op, values, alias) {\n    this.op = op;\n    this.values = values;\n    this.alias = alias;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lambda';\n  }\n\n  toJSON() {\n    return {\n      $type: Types.rawType(this),\n      op: this.op,\n      values: this.values,\n      alias: this.alias\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    let [left, right] = this.values;\n    left = render(left, {\n      aliases,\n      escape,\n      prefix\n    });\n    let alias = this.alias || left.split('/').pop().toLowerCase()[0];\n    return `${left}/${this.op}(${alias}:${render(right, {\n      aliases,\n      escape,\n      prefix: alias\n    })})`;\n  }\n\n  clone() {\n    return new Lambda(this.op, this.values.map(v => Objects.clone(v)), this.alias);\n  }\n\n}\n\nclass LambdaOperators {\n  any(field, value, alias) {\n    return new Lambda('any', [field, value], alias);\n  }\n\n  all(field, value, alias) {\n    return new Lambda('all', [field, value], alias);\n  }\n\n}\n\nclass ODataOperators {}\n\napplyMixins(ODataOperators, [LogicalOperators, ArithmeticOperators, LambdaOperators]);\nconst operators = new ODataOperators();\n\nclass ODataFunctions {}\n\napplyMixins(ODataFunctions, [StringAndCollectionFunctions, CollectionFunctions, StringFunctions, DateAndTimeFunctions, ArithmeticFunctions, TypeFunctions, GeoFunctions, ConditionalFunctions]);\nconst functions = new ODataFunctions();\n\nclass ODataSyntax {}\n\napplyMixins(ODataSyntax, [ODataOperators, ODataFunctions]);\nconst syntax = new ODataSyntax();\n\nclass ComputeExpression extends Expression {\n  constructor({\n    children,\n    names\n  } = {}) {\n    super({\n      children\n    });\n    this.names = names || [];\n  }\n\n  static e() {\n    return new ComputeExpression();\n  }\n\n  static s() {\n    return Field$1.factory();\n  }\n\n  static compute(opts, current) {\n    return opts({\n      s: ComputeExpression.s(),\n      e: ComputeExpression.e\n    }, current);\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    let children = this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    }));\n\n    return this.names.map((name, index) => `${children[index]} as ${name}`).join(',');\n  }\n\n  clone() {\n    return new ComputeExpression({\n      children: this._children.map(c => c.clone()),\n      names: [...this.names]\n    });\n  }\n\n  _add(name, node) {\n    this.names.push(name);\n\n    this._children.push(node);\n\n    return this;\n  }\n\n  field(name, opts) {\n    const node = opts({\n      o: operators,\n      f: functions\n    });\n    return this._add(name, node);\n  }\n\n}\n\nclass FilterExpression extends Expression {\n  constructor({\n    children,\n    connector,\n    negated\n  } = {}) {\n    super({\n      children\n    });\n    this._connector = connector || 'and';\n    this._negated = negated || false;\n  }\n\n  static s() {\n    return Field$1.factory();\n  }\n\n  static e(connector = 'and') {\n    return new FilterExpression({\n      connector\n    });\n  }\n\n  static filter(opts, current) {\n    return opts({\n      s: FilterExpression.s(),\n      e: FilterExpression.e,\n      o: operators,\n      f: functions\n    }, current);\n  }\n\n  toJSON() {\n    return {\n      children: this._children.map(c => c.toJSON()),\n      connector: this._connector,\n      negated: this._negated\n    };\n  }\n\n  connector() {\n    return this._connector;\n  }\n\n  negated() {\n    return this._negated;\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    let content = this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    })).join(` ${this._connector} `);\n\n    if (this._negated) {\n      content = `not (${content})`;\n    }\n\n    return content;\n  }\n\n  clone() {\n    return new FilterExpression({\n      children: this._children.map(c => c.clone()),\n      connector: this._connector,\n      negated: this._negated\n    });\n  }\n\n  _add(node, connector) {\n    if (connector !== undefined && this._connector !== connector) {\n      let children = [];\n\n      if (this._children.length > 0) {\n        if (this._children.length === 1) {\n          children = [...this._children];\n        } else {\n          let exp = new FilterExpression({\n            children: this._children,\n            connector: this._connector,\n            negated: this._negated\n          });\n\n          if (exp.length() > 1) {\n            children.push(new Grouping(exp));\n          } else {\n            children.push(exp);\n          }\n        }\n      }\n\n      if (node instanceof FilterExpression && (node.connector() === connector || node.length() === 1)) {\n        children = [...children, ...node.children()];\n      } else {\n        children.push(new Grouping(node));\n      }\n\n      this._connector = connector;\n      this._children = children;\n    } else if (node instanceof FilterExpression && !node.negated() && (node.connector() === connector || node.length() === 1)) {\n      this._children = [...this._children, ...node.children()];\n    } else {\n      this._children.push(node instanceof FilterExpression && !node.negated() ? new Grouping(node) : node);\n    }\n\n    return this;\n  }\n\n  or(exp) {\n    return this._add(exp, 'or');\n  }\n\n  and(exp) {\n    return this._add(exp, 'and');\n  }\n\n  not(exp) {\n    const notExp = new FilterExpression({\n      children: exp.children(),\n      connector: exp.connector(),\n      negated: true\n    });\n    return this._add(notExp, this._connector);\n  }\n\n  eq(left, right, normalize) {\n    return this._add(operators.eq(left, right, normalize));\n  }\n\n  ne(left, right, normalize) {\n    return this._add(operators.ne(left, right, normalize));\n  }\n\n  gt(left, right, normalize) {\n    return this._add(operators.gt(left, right, normalize));\n  }\n\n  ge(left, right, normalize) {\n    return this._add(operators.ge(left, right, normalize));\n  }\n\n  lt(left, right, normalize) {\n    return this._add(operators.lt(left, right, normalize));\n  }\n\n  le(left, right, normalize) {\n    return this._add(operators.le(left, right, normalize));\n  }\n\n  has(left, right, normalize) {\n    return this._add(operators.has(left, right, normalize));\n  }\n\n  in(left, right, normalize) {\n    return this._add(operators.in(left, right, normalize));\n  }\n\n  contains(left, right, normalize) {\n    return this._add(functions.contains(left, right, normalize));\n  }\n\n  startsWith(left, right, normalize) {\n    return this._add(functions.startsWith(left, right, normalize));\n  }\n\n  endsWith(left, right, normalize) {\n    return this._add(functions.endsWith(left, right, normalize));\n  }\n\n  any(left, opts, alias) {\n    const exp = opts({\n      s: Field$1.factory(),\n      e: FilterExpression.e\n    });\n    return this._add(syntax.any(left, exp, alias));\n  }\n\n  all(left, opts, alias) {\n    const exp = opts({\n      s: Field$1.factory(),\n      e: FilterExpression.e\n    });\n    return this._add(syntax.all(left, exp, alias));\n  }\n\n  isof(left, type) {\n    return this._add(syntax.isof(left, type));\n  }\n\n}\n\nclass OrderByField {\n  constructor(field, order) {\n    this.field = field;\n    this.order = order;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'OrderByField';\n  }\n\n  toJSON() {\n    return {\n      field: this.field.toJSON(),\n      order: this.order\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    return `${render(this.field, {\n      aliases,\n      escape,\n      prefix\n    })} ${this.order}`;\n  }\n\n  clone() {\n    return new OrderByField(this.field.clone(), this.order);\n  }\n\n}\n\nclass OrderByExpression extends Expression {\n  constructor({\n    children\n  } = {}) {\n    super({\n      children\n    });\n  }\n\n  static e() {\n    return new OrderByExpression();\n  }\n\n  static s() {\n    return Field$1.factory();\n  }\n\n  static orderBy(opts, current) {\n    return opts({\n      s: OrderByExpression.s(),\n      e: OrderByExpression.e\n    }, current);\n  }\n\n  _add(node) {\n    this._children.push(node);\n\n    return this;\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    let content = this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    })).join(`,`);\n\n    return content;\n  }\n\n  clone() {\n    return new OrderByExpression({\n      children: this._children.map(c => c.clone())\n    });\n  }\n\n  ascending(field) {\n    return this._add(new OrderByField(field, 'asc'));\n  }\n\n  descending(field) {\n    return this._add(new OrderByField(field, 'desc'));\n  }\n\n}\n\nclass SearchTerm {\n  constructor(value) {\n    this.value = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SearchTerm';\n  }\n\n  toJSON() {\n    return {\n      $type: Types.rawType(this),\n      value: this.value\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    return `${render(this.value, {\n      aliases,\n      escape,\n      prefix\n    })}`;\n  }\n\n  clone() {\n    return new SearchTerm(this.value);\n  }\n\n}\n\nclass SearchExpression extends Expression {\n  constructor({\n    children,\n    connector,\n    negated\n  } = {}) {\n    super({\n      children\n    });\n    this._connector = connector || 'AND';\n    this._negated = negated || false;\n  }\n\n  static e(connector = 'AND') {\n    return new SearchExpression({\n      connector\n    });\n  }\n\n  static search(opts, current) {\n    return opts({\n      e: SearchExpression.e\n    }, current);\n  }\n\n  _add(node, connector) {\n    if (connector !== undefined && this._connector !== connector) {\n      let children = [];\n\n      if (this._children.length > 0) {\n        if (this._children.length === 1) {\n          children = [...this._children];\n        } else {\n          let exp = new SearchExpression({\n            children: this._children,\n            connector: this._connector,\n            negated: this._negated\n          });\n\n          if (exp.length() > 1) {\n            children.push(new Grouping(exp));\n          } else {\n            children.push(exp);\n          }\n        }\n      }\n\n      if (node instanceof SearchExpression && (node.connector() === connector || node.length() === 1)) {\n        children = [...children, ...node.children()];\n      } else {\n        children.push(new Grouping(node));\n      }\n\n      this._connector = connector;\n      this._children = children;\n    } else if (node instanceof SearchExpression && !node.negated() && (node.connector() === connector || node.length() === 1)) {\n      this._children = [...this._children, ...node.children()];\n    } else {\n      this._children.push(node instanceof SearchExpression && !node.negated() ? new Grouping(node) : node);\n    }\n\n    return this;\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    let content = this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    })).join(` ${this._connector} `);\n\n    return content;\n  }\n\n  clone() {\n    return new SearchExpression({\n      children: this._children.map(c => c.clone()),\n      connector: this._connector,\n      negated: this._negated\n    });\n  }\n\n  toJSON() {\n    return {\n      children: this._children.map(c => c.toJSON()),\n      connector: this._connector,\n      negated: this._negated\n    };\n  }\n\n  connector() {\n    return this._connector;\n  }\n\n  negated() {\n    return this._negated;\n  }\n\n  or(exp) {\n    return this._add(exp, 'OR');\n  }\n\n  and(exp) {\n    return this._add(exp, 'AND');\n  }\n\n  not(exp) {\n    const notExp = new SearchExpression({\n      children: exp.children(),\n      connector: exp.connector(),\n      negated: true\n    });\n    return this._add(notExp, this._connector);\n  }\n\n  term(value) {\n    return this._add(new SearchTerm(value));\n  }\n\n}\n\nclass SelectExpression extends Expression {\n  constructor({\n    children\n  } = {}) {\n    super({\n      children\n    });\n  }\n\n  static e() {\n    return new SelectExpression();\n  }\n\n  static s() {\n    return Field$1.factory();\n  }\n\n  static select(builder, current) {\n    return builder({\n      s: SelectExpression.s(),\n      e: SelectExpression.e\n    }, current);\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    return this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    })).join(',');\n  }\n\n  clone() {\n    return new SelectExpression({\n      children: this._children.map(c => c.clone())\n    });\n  }\n\n  _add(node) {\n    this._children.push(node);\n\n    return this;\n  }\n\n  field(field) {\n    return this._add(field);\n  }\n\n}\n\nclass ExpandField {\n  constructor(field, values = {}) {\n    this.field = field;\n    this.values = values;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ExpandField';\n  }\n\n  toJSON() {\n    return {\n      field: this.field.toJSON()\n    };\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  }) {\n    const params = [QueryOptionNames.select, QueryOptionNames.expand, QueryOptionNames.filter, QueryOptionNames.search, QueryOptionNames.orderBy, QueryOptionNames.skip, QueryOptionNames.top, QueryOptionNames.levels].filter(key => !Types.isEmpty(this.values[key])).reduce((acc, key) => {\n      let value = this.values[key];\n\n      if (Types.rawType(value).endsWith('Expression')) {\n        value = value.render({\n          aliases,\n          prefix,\n          escape\n        });\n      }\n\n      return Object.assign(acc, {\n        [key]: value\n      });\n    }, {});\n    let expand = `${render(this.field, {\n      aliases,\n      escape,\n      prefix\n    })}`;\n\n    if (!Types.isEmpty(params)) {\n      expand = `${expand}(${Object.keys(params).map(key => `$${key}=${params[key]}`).join(';')})`;\n    }\n\n    return expand;\n  }\n\n  clone() {\n    const values = Object.keys(this.values).reduce((acc, key) => Object.assign(acc, {\n      [key]: Objects.clone(this.values[key])\n    }), {});\n    return new ExpandField(this.field.clone(), values);\n  }\n\n  select(opts) {\n    return this.option(QueryOptionNames.select, SelectExpression.select(opts, this.values[QueryOptionNames.select]));\n  }\n\n  expand(opts) {\n    return this.option(QueryOptionNames.expand, ExpandExpression.expand(opts, this.values[QueryOptionNames.expand]));\n  }\n\n  filter(opts) {\n    return this.option(QueryOptionNames.filter, FilterExpression.filter(opts, this.values[QueryOptionNames.filter]));\n  }\n\n  search(opts) {\n    return this.option(QueryOptionNames.search, SearchExpression.search(opts, this.values[QueryOptionNames.search]));\n  }\n\n  orderBy(opts) {\n    return this.option(QueryOptionNames.orderBy, OrderByExpression.orderBy(opts, this.values[QueryOptionNames.orderBy]));\n  }\n\n  skip(n) {\n    return this.option(QueryOptionNames.skip, n);\n  }\n\n  top(n) {\n    return this.option(QueryOptionNames.top, n);\n  }\n\n  levels(n) {\n    return this.option(QueryOptionNames.levels, n);\n  } // Option Handler\n\n\n  option(name, opts) {\n    if (opts !== undefined) this.values[name] = opts;\n    return this.values[name];\n  }\n\n}\n\nclass ExpandExpression extends Expression {\n  constructor({\n    children\n  } = {}) {\n    super({\n      children\n    });\n  }\n\n  static e() {\n    return new ExpandExpression();\n  }\n\n  static s() {\n    return Field$1.factory();\n  }\n\n  static expand(opts, current) {\n    return opts({\n      s: ExpandExpression.s(),\n      e: ExpandExpression.e\n    }, current);\n  }\n\n  render({\n    aliases,\n    escape,\n    prefix\n  } = {}) {\n    return this._children.map(n => n.render({\n      aliases,\n      escape,\n      prefix\n    })).join(',');\n  }\n\n  clone() {\n    return new ExpandExpression({\n      children: this._children.map(c => c.clone())\n    });\n  }\n\n  _add(node) {\n    this._children.push(node);\n\n    return this;\n  }\n\n  field(field, opts) {\n    let node = new ExpandField(field);\n    if (opts !== undefined) opts(node);\n    return this._add(node);\n  }\n\n}\n\nclass ODataQueryOptionHandler {\n  constructor(o, n) {\n    this.o = o;\n    this.n = n;\n  }\n  /**\n   * The name of the managed odata query option.\n   */\n\n\n  get name() {\n    return this.n;\n  }\n  /**\n   * Converts the managed odata query option to a json object.\n   * @returns {any}\n   */\n\n\n  toJSON() {\n    return this.o.get(this.n);\n  }\n  /**\n   * Returns a boolean indicating if the managed odata query option is empty.\n   * @returns True if the managed odata query option is empty.\n   */\n\n\n  empty() {\n    return Types.isEmpty(this.o.get(this.n));\n  } //#region Primitive Value\n\n  /**\n   * Get or Set the value of the managed odata query option.\n   * @param v The value to set.\n   * @returns\n   */\n\n\n  value(v) {\n    if (v !== undefined) this.o.set(this.n, v);\n    return this.o.get(this.n);\n  } //#endregion\n  //#region Array Value\n\n\n  assertArray() {\n    if (!Types.isArray(this.o.get(this.n))) this.o.set(this.n, this.o.has(this.n) ? [this.o.get(this.n)] : []);\n    return this.o.get(this.n);\n  }\n  /**\n   * Push value to the managed odata query option.\n   * @param value Value to push\n   */\n\n\n  push(value) {\n    this.assertArray().push(value);\n  }\n  /**\n   * Remove value from the managed odata query option.\n   * @param value Value to remove\n   */\n\n\n  remove(value) {\n    this.o.set(this.n, this.assertArray().filter(v => v !== value)); // If only one and not is array... down to value\n\n    if (this.o.get(this.n).length === 1 && !Types.isArray(this.o.get(this.n)[0])) this.o.set(this.n, this.o.get(this.n)[0]);\n  }\n  /**\n   * Return value at index of the managed odata query option.\n   * @param index Index of the value\n   * @returns The value\n   */\n\n\n  at(index) {\n    return this.assertArray()[index];\n  }\n\n  some(predicate) {\n    return this.assertArray().some(predicate);\n  }\n\n  every(predicate) {\n    return this.assertArray().every(predicate);\n  }\n\n  find(predicate) {\n    return this.assertArray().find(predicate);\n  } //#endregion\n  //#region HashMap Value\n\n\n  assertObject(create) {\n    if (!Types.isArray(this.o.get(this.n)) && Types.isPlainObject(this.o.get(this.n))) {\n      return this.o.get(this.n);\n    }\n\n    let arr = this.assertArray();\n    let obj = arr.find(v => Types.isPlainObject(v));\n\n    if (!obj && create) {\n      obj = {};\n      arr.push(obj);\n    }\n\n    return obj;\n  }\n  /**\n   * Set the value for path in the managed odata query option.\n   * @param path Path for set the value\n   * @param value Value to set\n   */\n\n\n  set(path, value) {\n    let obj = this.assertObject(true);\n    Objects.set(obj, path, value);\n  }\n  /**\n   * Get the value for path from the managed odata query option.\n   * @param path The path from get the value\n   * @param def Default if not found\n   * @returns\n   */\n\n\n  get(path, def) {\n    let obj = this.assertObject(false) || {};\n    return Objects.get(obj, path, def);\n  }\n  /**\n   * Unset the value for path in the managed odata query option.\n   * @param path\n   */\n\n\n  unset(path) {\n    let obj = this.assertObject(true);\n    Objects.unset(obj, path);\n\n    if (Types.isArray(this.o.get(this.n))) {\n      this.o.set(this.n, this.o.get(this.n).filter(v => !Types.isEmpty(v)));\n      if (this.o.get(this.n).length === 1) this.o.set(this.n, this.o.get(this.n)[0]);\n    }\n  }\n  /**\n   * Test if the managed odata query option has the value.\n   * @param path The path fot test if the value is set\n   * @returns Boolean indicating if the value is set\n   */\n\n\n  has(path) {\n    let obj = this.assertObject(false) || {};\n    return Objects.has(obj, path);\n  }\n  /**\n   * Merge values from object into the managed odata query option.\n   * @param values Object to merge\n   * @returns\n   */\n\n\n  assign(values) {\n    let obj = this.assertObject(true);\n    return Objects.merge(obj, values);\n  } //#endregion\n\n  /**\n   * Clear the managed odata query option.\n   */\n\n\n  clear() {\n    this.o.delete(this.n);\n  }\n\n}\n\nclass ODataQueryOptionsHandler {\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Create a raw odata value\n   * @param value The value to raw\n   * @returns The raw value\n   */\n\n\n  raw(value) {\n    return raw(value);\n  }\n  /**\n   * Create a new odata alias parameter\n   * @link https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_ParameterAliases\n   * @param value The value of the alias\n   * @param name The name of the alias\n   * @returns The alias\n   */\n\n\n  alias(value, name) {\n    return alias(value, name);\n  }\n  /**\n   * Create a duration odata value\n   * @param value The value to duration\n   * @returns The duration value\n   */\n\n\n  duration(value) {\n    return duration(value);\n  }\n  /**\n   * Create a binary odata value\n   * @param value The value to binary\n   * @returns The binary value\n   */\n\n\n  binary(value) {\n    return binary(value);\n  }\n  /**\n   * Normalize the given value to a valid odata value\n   * @param value The value to normalize\n   * @returns The normalized value\n   */\n\n\n  normalize(value) {\n    return normalizeValue(value);\n  }\n\n  select(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.expression(QueryOptionNames.select, SelectExpression.select(opts, this.options.expression(QueryOptionNames.select)));\n    }\n\n    return this.options.option(QueryOptionNames.select, opts);\n  }\n\n  expand(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.expression(QueryOptionNames.expand, ExpandExpression.expand(opts, this.options.expression(QueryOptionNames.expand)));\n    }\n\n    return this.options.option(QueryOptionNames.expand, opts);\n  }\n\n  compute(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.expression(QueryOptionNames.compute, ComputeExpression.compute(opts, this.options.expression(QueryOptionNames.compute)));\n    }\n\n    return this.options.option(QueryOptionNames.compute, opts);\n  }\n\n  format(opts) {\n    return this.options.option(QueryOptionNames.format, opts);\n  }\n\n  transform(opts) {\n    return this.options.option(QueryOptionNames.transform, opts);\n  }\n\n  search(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.expression(QueryOptionNames.search, SearchExpression.search(opts, this.options.expression(QueryOptionNames.search)));\n    }\n\n    return this.options.option(QueryOptionNames.search, opts);\n  }\n\n  filter(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.expression(QueryOptionNames.filter, FilterExpression.filter(opts, this.options.expression(QueryOptionNames.filter)));\n    }\n\n    return this.options.option(QueryOptionNames.filter, opts);\n  }\n\n  orderBy(opts) {\n    if (Types.isFunction(opts)) {\n      return this.options.option(QueryOptionNames.orderBy, OrderByExpression.orderBy(opts, this.options.expression(QueryOptionNames.orderBy)));\n    }\n\n    return this.options.option(QueryOptionNames.orderBy, opts);\n  }\n\n  top(opts) {\n    return this.options.option(QueryOptionNames.top, opts);\n  }\n\n  skip(opts) {\n    return this.options.option(QueryOptionNames.skip, opts);\n  }\n\n  skiptoken(opts) {\n    return this.options.option(QueryOptionNames.skiptoken, opts);\n  }\n  /**\n   * Shortcut for set $top, $skip, $skiptoken.\n   * @param param0 skip or top or skiptoken\n   */\n\n\n  paging({\n    skip,\n    skiptoken,\n    top\n  } = {}) {\n    if (skiptoken !== undefined) {\n      if (skiptoken !== null) {\n        this.skiptoken(skiptoken);\n      } else {\n        this.options.remove(QueryOptionNames.skiptoken);\n      }\n    }\n\n    if (skip !== undefined) {\n      if (skip !== null) {\n        this.skip(skip);\n      } else {\n        this.options.remove(QueryOptionNames.skip);\n      }\n    }\n\n    if (top !== undefined) {\n      if (top !== null) {\n        this.top(top);\n      } else {\n        this.options.remove(QueryOptionNames.top);\n      }\n    }\n  }\n  /**\n   * Shortcut for clear pagination by unset $top, $skip, $skiptoken.\n   */\n\n\n  clearPaging() {\n    this.options.remove(QueryOptionNames.skip);\n    this.options.remove(QueryOptionNames.top);\n    this.options.remove(QueryOptionNames.skiptoken);\n  }\n  /**\n   * Shortcut for clear query.\n   */\n\n\n  clear() {\n    this.options.clear();\n  }\n  /**\n   * Retrun the query.\n   */\n\n\n  query() {\n    return this.options.toQueryArguments();\n  }\n  /**\n   * Apply the given query options to the current query.\n   * @param query The query to be applied.\n   */\n\n\n  apply(query) {\n    if (query.select !== undefined) {\n      if (query.select instanceof SelectExpression) {\n        this.options.expression(QueryOptionNames.select, query.select);\n      } else if (query.select !== null) {\n        this.options.option(QueryOptionNames.select, query.select);\n      } else {\n        this.options.remove(QueryOptionNames.select);\n      }\n    }\n\n    if (query.expand !== undefined) {\n      if (query.expand instanceof ExpandExpression) {\n        this.options.expression(QueryOptionNames.expand, query.expand);\n      } else if (query.expand !== null) {\n        this.options.option(QueryOptionNames.expand, query.expand);\n      } else {\n        this.options.remove(QueryOptionNames.expand);\n      }\n    }\n\n    if (query.compute !== undefined) {\n      if (query.compute instanceof ComputeExpression) {\n        this.options.expression(QueryOptionNames.compute, query.compute);\n      } else if (query.compute !== null) {\n        this.options.option(QueryOptionNames.compute, query.compute);\n      } else {\n        this.options.remove(QueryOptionNames.compute);\n      }\n    }\n\n    if (query.transform !== undefined) {\n      if (query.transform !== null) {\n        this.options.option(QueryOptionNames.transform, query.transform);\n      } else {\n        this.options.remove(QueryOptionNames.transform);\n      }\n    }\n\n    if (query.search !== undefined) {\n      if (query.search instanceof SearchExpression) {\n        this.options.expression(QueryOptionNames.search, query.search);\n      } else if (query.search !== null) {\n        this.options.option(QueryOptionNames.search, query.search);\n      } else {\n        this.options.remove(QueryOptionNames.search);\n      }\n    }\n\n    if (query.filter !== undefined) {\n      if (query.filter instanceof FilterExpression) {\n        this.options.expression(QueryOptionNames.filter, query.filter);\n      } else if (query.filter !== null) {\n        this.options.option(QueryOptionNames.filter, query.filter);\n      } else {\n        this.options.remove(QueryOptionNames.filter);\n      }\n    }\n\n    if (query.orderBy !== undefined) {\n      if (query.orderBy instanceof OrderByExpression) {\n        this.options.expression(QueryOptionNames.orderBy, query.orderBy);\n      } else if (query.orderBy !== null) {\n        this.options.option(QueryOptionNames.orderBy, query.orderBy);\n      } else {\n        this.options.remove(QueryOptionNames.orderBy);\n      }\n    }\n\n    this.paging(query);\n  }\n\n}\n\nclass ODataQueryOptions {\n  constructor(values) {\n    this.values = values instanceof Map ? values : new Map(Object.entries(values || {}));\n  } // Params\n\n\n  pathAndParams(escape = false) {\n    let aliases = [];\n    let options = [QueryOptionNames.select, QueryOptionNames.filter, QueryOptionNames.search, QueryOptionNames.compute, QueryOptionNames.transform, QueryOptionNames.orderBy, QueryOptionNames.top, QueryOptionNames.skip, QueryOptionNames.skiptoken, QueryOptionNames.expand, QueryOptionNames.format, QueryOptionNames.levels, QueryOptionNames.count].filter(key => !Types.isEmpty(this.values.get(key))).reduce((acc, key) => {\n      let value = this.values.get(key);\n\n      if (Types.rawType(value).endsWith('Expression')) {\n        value = value.render({\n          aliases\n        });\n      }\n\n      return Object.assign(acc, {\n        [key]: value\n      });\n    }, {});\n    return buildPathAndQuery(Object.assign(Object.assign({}, options), {\n      aliases,\n      escape\n    }));\n  }\n\n  toString() {\n    const [path, params] = this.pathAndParams();\n    return path + Object.entries(params).filter(([, value]) => !Types.isEmpty(value)).map(([key, value]) => `${key}=${value}`).join('&');\n  }\n\n  toJSON() {\n    return [...this.values.keys()].reduce((acc, key) => {\n      let value = this.values.get(key);\n      value = Types.isObject(value) && 'toJSON' in value ? value.toJSON() : value;\n      return Object.assign(acc, {\n        [key]: value\n      });\n    }, {});\n  }\n\n  toQueryArguments() {\n    return {\n      select: this.values.get(QueryOptionNames.select) || null,\n      expand: this.values.get(QueryOptionNames.expand) || null,\n      transform: this.values.get(QueryOptionNames.transform) || null,\n      compute: this.values.get(QueryOptionNames.compute) || null,\n      search: this.values.get(QueryOptionNames.search) || null,\n      filter: this.values.get(QueryOptionNames.filter) || null,\n      orderBy: this.values.get(QueryOptionNames.orderBy) || null,\n      top: this.values.get(QueryOptionNames.top) || null,\n      skip: this.values.get(QueryOptionNames.skip) || null,\n      skiptoken: this.values.get(QueryOptionNames.skiptoken) || null,\n      levels: this.values.get(QueryOptionNames.levels) || null,\n      count: this.values.get(QueryOptionNames.count) || null\n    };\n  }\n\n  clone() {\n    return new ODataQueryOptions(Objects.clone(this.values));\n  } // Set Renderable\n\n\n  expression(key, exp) {\n    if (exp !== undefined) this.values.set(key, exp);\n    return this.values.get(key);\n  } // Option Handler\n\n\n  option(key, opts) {\n    if (opts !== undefined) this.values.set(key, opts);\n    return new ODataQueryOptionHandler(this.values, key);\n  } // Query Options tools\n\n\n  has(key) {\n    return this.values.has(key);\n  }\n\n  remove(...keys) {\n    [...this.values.keys()].filter(k => keys.indexOf(k) !== -1).forEach(key => {\n      this.values.delete(key);\n    });\n  }\n\n  keep(...keys) {\n    [...this.values.keys()].filter(k => keys.indexOf(k) === -1).forEach(key => {\n      this.values.delete(key);\n    });\n  } // Clear\n\n\n  clear() {\n    this.values.clear();\n  }\n\n}\n\nclass SegmentHandler {\n  constructor(segment) {\n    this.segment = segment;\n  }\n\n  get name() {\n    return this.segment.name;\n  }\n\n  type(value) {\n    if (value !== undefined) this.segment.type = value;\n    return this.segment.type;\n  }\n\n  path(value) {\n    if (value !== undefined) this.segment.path = value;\n    return this.segment.path;\n  }\n\n  key(value) {\n    if (value !== undefined) this.segment.key = value;\n    return this.segment.key;\n  }\n\n  hasKey() {\n    return !Types.isEmpty(this.segment.key);\n  }\n\n  clearKey() {\n    delete this.segment.key;\n  }\n\n  parameters(value) {\n    if (value !== undefined) this.segment.parameters = value;\n    return this.segment.parameters;\n  }\n\n  hasParameters() {\n    return !Types.isEmpty(this.segment.parameters);\n  }\n\n  clearParameters() {\n    delete this.segment.parameters;\n  }\n\n}\n\nclass ODataPathSegmentsHandler {\n  constructor(segments) {\n    this.segments = segments;\n  }\n\n  entitySet() {\n    return this.segments.get(PathSegmentNames.entitySet);\n  }\n\n  singleton() {\n    return this.segments.get(PathSegmentNames.singleton);\n  }\n\n  action() {\n    return this.segments.get(PathSegmentNames.action);\n  }\n\n  function() {\n    return this.segments.get(PathSegmentNames.function);\n  }\n\n  keys(values) {\n    return this.segments.keys(values);\n  }\n\n  property() {\n    return this.segments.get(PathSegmentNames.property);\n  }\n\n  navigationProperty() {\n    return this.segments.get(PathSegmentNames.navigationProperty);\n  }\n\n}\n\nfunction pathSegmentsBuilder(segment, escape = false) {\n  if (segment.name === PathSegmentNames.function) {\n    let [path, params] = segment.parameters ? buildPathAndQuery({\n      func: {\n        [segment.path]: segment.parameters\n      },\n      escape\n    }) : buildPathAndQuery({\n      func: segment.path,\n      escape\n    });\n\n    if (path.startsWith(PATH_SEPARATOR)) {\n      path = path.slice(1);\n    }\n\n    return [path, params];\n  } else {\n    let key = segment.key; // HACK: Check guid string\n\n    if (typeof key === 'string' && /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(key)) {\n      key = raw(key);\n    }\n\n    let [path, params] = key ? buildPathAndQuery({\n      key,\n      escape\n    }) : ['', {}];\n    return [segment.path + path, params];\n  }\n}\n\nclass ODataPathSegments {\n  constructor(segments) {\n    this._segments = segments || [];\n  }\n\n  pathAndParams(escape = false) {\n    const result = this._segments.reduce((acc, segment) => {\n      const [path, params] = pathSegmentsBuilder(segment, escape);\n      acc.paths.push(path);\n      acc.params = Object.assign(acc.params, params);\n      return acc;\n    }, {\n      paths: [],\n      params: {}\n    });\n\n    return [result.paths.join(PATH_SEPARATOR), result.params];\n  }\n\n  types({\n    key = false\n  } = {}) {\n    return this.segments({\n      key\n    }).map(s => s.type()).filter(t => t !== undefined);\n  }\n\n  keys(values) {\n    const segments = this.segments({\n      key: true\n    });\n\n    if (values !== undefined) {\n      segments.forEach((segment, index) => {\n        const key = values[index];\n\n        if (key === undefined) {\n          segment.clearKey();\n        } else {\n          segment.key(key);\n        }\n      });\n    }\n\n    return segments.map(s => s.key());\n  }\n\n  toString() {\n    const [path, params] = this.pathAndParams();\n    return path + Object.entries(params).filter(([, value]) => value).map(([key, value]) => `${key}=${value}`).join('&');\n  }\n\n  toJSON() {\n    return this._segments.map(s => {\n      let json = {\n        name: s.name,\n        path: s.path\n      };\n      if (s.type !== undefined) json.type = s.type;\n      if (s.key !== undefined) json.key = s.key;\n      if (s.parameters !== undefined) json.parameters = s.parameters;\n      return json;\n    });\n  }\n\n  clone() {\n    const segments = Objects.clone(this._segments);\n    return new ODataPathSegments(segments);\n  }\n\n  find(predicate) {\n    //Backward Find\n    return [...this._segments].reverse().find(predicate);\n  }\n\n  segments({\n    key = false\n  } = {}) {\n    let segments = [...this._segments];\n    if (key) segments = segments.filter(s => [PathSegmentNames.entitySet, PathSegmentNames.navigationProperty, PathSegmentNames.property].indexOf(s.name) !== -1);\n    return segments.map(s => new SegmentHandler(s));\n  }\n\n  first({\n    key = false\n  } = {}) {\n    const segments = this.segments({\n      key\n    });\n    return segments.length > 0 ? segments[0] : undefined;\n  }\n\n  last({\n    key = false\n  } = {}) {\n    const segments = this.segments({\n      key\n    });\n    return segments.length > 0 ? segments[segments.length - 1] : undefined;\n  }\n\n  add(name, path) {\n    const segment = {\n      name,\n      path\n    };\n\n    this._segments.push(segment);\n\n    return new SegmentHandler(segment);\n  }\n\n  get(name) {\n    let segment = this.find(s => s.name === name);\n    if (segment === undefined) throw Error(`No Segment for name ${name} was found`);\n    return new SegmentHandler(segment);\n  }\n\n}\n\nclass ODataRequest {\n  constructor(init) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this._method = init.method;\n    this.resource = init.resource;\n    this.api = init.api;\n    this.reportProgress = init.reportProgress;\n    this.observe = init.observe; // Response Type\n\n    this._responseType = init.responseType; // The Body\n\n    this._body = init.body !== undefined ? init.body : null;\n    if (this._body !== null) this._body = this.resource.serialize(this._body);\n    this.withCredentials = init.withCredentials === undefined ? this.api.options.withCredentials : init.withCredentials;\n    this.fetchPolicy = init.fetchPolicy || this.api.options.fetchPolicy;\n    this.bodyQueryOptions = [...(this.api.options.bodyQueryOptions || []), ...(init.bodyQueryOptions || [])]; // The Path and Params from resource\n\n    const [resourcePath, resourceParams] = this.resource.pathAndParams();\n    this._path = resourcePath; //#region Headers\n\n    const customHeaders = {};\n\n    if (typeof init.etag === 'string') {\n      if (this.api.options.etag.ifMatch && ['PUT', 'PATCH', 'DELETE'].indexOf(this._method) !== -1) customHeaders[IF_MATCH_HEADER] = init.etag;else if (this.api.options.etag.ifNoneMatch && ['GET'].indexOf(this._method) !== -1) customHeaders[IF_NONE_MATCH_HEADER] = init.etag;\n    }\n\n    const accept = []; // Metadata\n\n    if (((_a = this.api.options.accept) === null || _a === void 0 ? void 0 : _a.metadata) !== undefined) accept.push(`odata.metadata=${(_b = this.api.options.accept) === null || _b === void 0 ? void 0 : _b.metadata}`); // IEEE754\n\n    if (((_c = this.api.options.accept) === null || _c === void 0 ? void 0 : _c.ieee754Compatible) !== undefined) accept.push(`IEEE754Compatible=${(_d = this.api.options.accept) === null || _d === void 0 ? void 0 : _d.ieee754Compatible}`); // streaming\n\n    if (((_e = this.api.options.accept) === null || _e === void 0 ? void 0 : _e.streaming) !== undefined) accept.push(`streaming=${(_f = this.api.options.accept) === null || _f === void 0 ? void 0 : _f.streaming}`); // ExponentialDecimals\n\n    if (((_g = this.api.options.accept) === null || _g === void 0 ? void 0 : _g.exponentialDecimals) !== undefined) accept.push(`ExponentialDecimals=${(_h = this.api.options.accept) === null || _h === void 0 ? void 0 : _h.exponentialDecimals}`);\n    if (accept.length > 0) customHeaders[ACCEPT] = [`application/json;${accept.join(';')}`, 'text/plain', '*/*'];\n    const prefer = []; // Return\n\n    if (((_j = this.api.options.prefer) === null || _j === void 0 ? void 0 : _j.return) !== undefined && ['POST', 'PUT', 'PATCH'].indexOf(this._method) !== -1) prefer.push(`return=${(_k = this.api.options.prefer) === null || _k === void 0 ? void 0 : _k.return}`); // MaxPageSize\n\n    if (((_l = this.api.options.prefer) === null || _l === void 0 ? void 0 : _l.maxPageSize) !== undefined && ['GET'].indexOf(this._method) !== -1) prefer.push(`odata.maxpagesize=${(_m = this.api.options.prefer) === null || _m === void 0 ? void 0 : _m.maxPageSize}`); // Annotations\n\n    if (((_o = this.api.options.prefer) === null || _o === void 0 ? void 0 : _o.includeAnnotations) !== undefined && ['GET'].indexOf(this._method) !== -1) prefer.push(`odata.include-annotations=${(_p = this.api.options.prefer) === null || _p === void 0 ? void 0 : _p.includeAnnotations}`);\n    if (((_q = this.api.options.prefer) === null || _q === void 0 ? void 0 : _q.continueOnError) === true && ['POST'].indexOf(this._method) !== -1) prefer.push(`odata.continue-on-error`);\n    if (prefer.length > 0) customHeaders[PREFER] = prefer;\n    this._headers = Http.mergeHttpHeaders(this.api.options.headers, customHeaders, init.headers || {}); //#endregion\n    //#region Params\n\n    const customParams = {};\n\n    if (['POST', 'PUT', 'PATCH'].indexOf(this._method) !== -1 && '$select' in resourceParams) {\n      customParams['$select'] = resourceParams['$select'];\n    }\n\n    if (['POST'].indexOf(this._method) !== -1 && '$expand' in resourceParams) {\n      customParams['$expand'] = resourceParams['$expand'];\n    }\n\n    if (['GET'].indexOf(this._method) !== -1) {\n      Object.assign(customParams, resourceParams);\n    }\n\n    const params = Http.mergeHttpParams(this.api.options.params, customParams, init.params || {});\n    this._params = this._responseType === 'entity' ? Http.withoutHttpParams(params, ['$filter', '$orderby', '$count', '$skip', '$top']) : params; //#endregion\n  }\n\n  get responseType() {\n    return this._responseType && ['property', 'entity', 'entities'].indexOf(this._responseType) !== -1 ? 'json' : this._responseType === 'value' ? 'text' : this._responseType;\n  }\n\n  get path() {\n    return this.isQueryBody() ? `${this._path}/${$QUERY}` : this._path;\n  }\n\n  get method() {\n    return this.isQueryBody() ? 'POST' : this._method;\n  }\n\n  get body() {\n    return this.isQueryBody() ? Http.splitHttpParams(this._params, this.bodyQueryOptions.map(name => `$${name}`))[1].toString() : this._body;\n  }\n\n  get params() {\n    return this.isQueryBody() ? Http.splitHttpParams(this._params, this.bodyQueryOptions.map(name => `$${name}`))[0] : this._params;\n  }\n\n  get headers() {\n    return this.isQueryBody() ? Http.mergeHttpHeaders(this._headers, {\n      CONTENT_TYPE: TEXT_PLAIN\n    }) : this._headers;\n  }\n\n  get pathWithParams() {\n    return this.params.keys().length > 0 ? `${this.path}?${this.params}` : this.path;\n  }\n\n  get url() {\n    return `${this.api.serviceRootUrl}${this.path}`;\n  }\n\n  get urlWithParams() {\n    return `${this.api.serviceRootUrl}${this.pathWithParams}`;\n  }\n\n  get cacheKey() {\n    return this._params.keys().length > 0 ? `${this._path}?${this._params}` : this._path;\n  }\n\n  isQueryBody() {\n    return this._method === 'GET' && this.bodyQueryOptions.length > 0 && this.bodyQueryOptions.some(name => this._params.has(`$${name}`));\n  }\n\n  isBatch() {\n    return this.path.endsWith($BATCH);\n  }\n\n  isFetch() {\n    return ['GET'].indexOf(this._method) !== -1;\n  }\n\n  isMutate() {\n    return ['PUT', 'PATCH', 'POST', 'DELETE'].indexOf(this._method) !== -1;\n  }\n\n}\n\nconst COLLECTION = /Collection\\(([\\w\\.]+)\\)/;\nconst PROPERTY = /([\\w\\d\\-_]+)\\(([\\'\\w\\d\\-_=]+)\\)/;\nconst EXPAND = /([\\w\\d\\-_]+)\\(([\\w\\d\\,\\(\\)]+)\\)/;\nconst ODataVersionBaseHelper = {\n  entity(data) {\n    return data;\n  },\n\n  entities(data) {\n    return data[this.VALUE];\n  },\n\n  property(data) {\n    return this.VALUE in data ? data[this.VALUE] : data;\n  },\n\n  functions(annots) {\n    const funcs = new Map();\n    [...annots.keys()].filter(key => key.startsWith(this.ODATA_FUNCTION_PREFIX)).forEach(key => funcs.set(key.substring(this.ODATA_FUNCTION_PREFIX.length), annots.get(key)));\n    return funcs;\n  },\n\n  properties(annots) {\n    const props = new Map();\n    [...annots.keys()].filter(key => key.indexOf(this.ODATA_ANNOTATION_PREFIX) > 0).forEach(key => {\n      let name = key.substring(0, key.indexOf(this.ODATA_ANNOTATION_PREFIX));\n      let prop = props.has(name) ? props.get(name) : new Map();\n      prop.set(key.substring(key.indexOf(this.ODATA_ANNOTATION_PREFIX)), annots.get(key));\n      props.set(name, prop);\n    });\n    return props;\n  },\n\n  id(annots) {\n    return annots instanceof Map ? annots.get(this.ODATA_ID) : annots[this.ODATA_ID];\n  },\n\n  etag(annots) {\n    return annots instanceof Map ? annots.get(this.ODATA_ETAG) : annots[this.ODATA_ETAG];\n  },\n\n  type(annots) {\n    let type = annots instanceof Map ? annots.get(this.ODATA_TYPE) : annots[this.ODATA_TYPE];\n    if (!type) return undefined;\n    type = type.substring(1);\n    const matches = COLLECTION.exec(type);\n    if (matches) return matches[1].indexOf('.') === -1 ? `Edm.${matches[1]}` : matches[1];\n    return type;\n  },\n\n  mediaEtag(annots) {\n    return annots.has(this.ODATA_MEDIA_ETAG) ? decodeURIComponent(annots.get(this.ODATA_MEDIA_ETAG)) : undefined;\n  },\n\n  metadataEtag(annots) {\n    return annots.has(this.ODATA_METADATA_ETAG) ? decodeURIComponent(annots.get(this.ODATA_METADATA_ETAG)) : undefined;\n  },\n\n  count(annots) {\n    return annots.has(this.ODATA_COUNT) ? Number(annots.get(this.ODATA_COUNT)) : undefined;\n  },\n\n  annotations(value) {\n    const annots = new Map();\n    Object.entries(value).filter(([key]) => key.indexOf(this.ODATA_ANNOTATION_PREFIX) !== -1 || key.startsWith(this.ODATA_FUNCTION_PREFIX)).forEach(([key, value]) => annots.set(key, value));\n    return annots;\n  },\n\n  attributes(value, metadata) {\n    return Object.entries(value).filter(([k]) => metadata === 'none' || metadata === 'minimal' && (k.indexOf(this.ODATA_ANNOTATION_PREFIX) === -1 || k.startsWith(this.ODATA_ANNOTATION_PREFIX)) && !k.startsWith(this.ODATA_FUNCTION_PREFIX) || metadata === 'full' && k.indexOf(this.ODATA_ANNOTATION_PREFIX) === -1 && !k.startsWith(this.ODATA_FUNCTION_PREFIX)).reduce((acc, e) => Object.assign(Object.assign({}, acc), {\n      [e[0]]: e[1]\n    }), {});\n  },\n\n  nextLink(annots) {\n    return annots.has(this.ODATA_NEXTLINK) ? decodeURIComponent(annots.get(this.ODATA_NEXTLINK)) : undefined;\n  },\n\n  readLink(annots) {\n    return annots.has(this.ODATA_READLINK) ? decodeURIComponent(annots.get(this.ODATA_READLINK)) : undefined;\n  },\n\n  mediaReadLink(annots) {\n    return annots.has(this.ODATA_MEDIA_READLINK) ? decodeURIComponent(annots.get(this.ODATA_MEDIA_READLINK)) : undefined;\n  },\n\n  editLink(annots) {\n    return annots.has(this.ODATA_EDITLINK) ? decodeURIComponent(annots.get(this.ODATA_EDITLINK)) : undefined;\n  },\n\n  mediaEditLink(annots) {\n    return annots.has(this.ODATA_MEDIA_EDITLINK) ? decodeURIComponent(annots.get(this.ODATA_MEDIA_EDITLINK)) : undefined;\n  },\n\n  deltaLink(annots) {\n    return annots.has(this.ODATA_DELTALINK) ? decodeURIComponent(annots.get(this.ODATA_DELTALINK)) : undefined;\n  },\n\n  mediaContentType(annots) {\n    return annots.has(this.ODATA_MEDIA_CONTENTTYPE) ? decodeURIComponent(annots.get(this.ODATA_MEDIA_CONTENTTYPE)) : undefined;\n  }\n\n};\nconst ODataHelper = {\n  //#region Version 4.0\n  [VERSION_4_0]: Object.assign({}, ODataVersionBaseHelper, {\n    VALUE: 'value',\n    ODATA_ANNOTATION_PREFIX: '@odata',\n    ODATA_FUNCTION_PREFIX: '#',\n    //odata.id: the ID of the entity\n    ODATA_ID: '@odata.id',\n    //odata.count: the total count of a collection of entities or collection of entity references, if requested.\n    ODATA_COUNT: '@odata.count',\n    //odata.context: the context URL for a collection, entity, primitive value, or service document.\n    ODATA_CONTEXT: '@odata.context',\n    //odata.etag: the ETag of the entity\n    ODATA_ETAG: '@odata.etag',\n    ODATA_METADATA_ETAG: '@odata.metadataEtag',\n    //odata.type: the type of the containing {[key: string]: any} or targeted property if the type of the {[key: string]: any} or targeted property cannot be heuristically determined\n    ODATA_TYPE: '@odata.type',\n    //odata.nextLink: the next link of a collection with partial results\n    ODATA_NEXTLINK: '@odata.nextLink',\n    //odata.deltaLink: the delta link for obtaining changes to the result, if requested\n    ODATA_DELTALINK: '@odata.deltaLink',\n    //odata.readLink: the link used to read the entity, if the edit link cannot be used to read the entity\n    ODATA_READLINK: '@odata.readLink',\n    //odata.editLink: the link used to edit/update the entity, if the entity is updatable and the odata.id does not represent a URL that can be used to edit the entity\n    ODATA_EDITLINK: '@odata.editLink',\n    //odata.associationLink: the link used to describe the relationship between this entity and related entities\n    ODATA_ASSOCIATIONLINK: '@odata.associationLink',\n    //odata.navigationLink: the link used to retrieve the values of a navigation property\n    ODATA_NAVIGATIONLINK: '@odata.navigationLink',\n    //Media entities and stream properties may in addition contain the following annotations:\n    //odata.mediaEtag: the ETag of the stream, as appropriate\n    ODATA_MEDIA_ETAG: '@odata.mediaEtag',\n    //odata.mediaContentType: the content type of the stream\n    ODATA_MEDIA_CONTENTTYPE: '@odata.mediaContentType',\n    //odata.mediaReadLink: the link used to read the stream\n    ODATA_MEDIA_READLINK: '@odata.mediaReadLink',\n    //odata.mediaEditLink: the link used to edit/update the stream\n    ODATA_MEDIA_EDITLINK: '@odata.mediaEditLink',\n\n    //http://nb-mdp-dev01:57970/$metadata#recursos/$entity\n    //http://nb-mdp-dev01:57970/$metadata#categorias\n    //http://nb-mdp-dev01:57970/$metadata#juzgados\n    //http://nb-mdp-dev01:57970/$metadata#Collection(SIU.Recursos.RecursoEntry)\n    //http://nb-mdp-dev01:57970/$metadata#categorias/$entity\n    //http://nb-mdp-dev01:57970/$metadata#categorias(children(children(children(children(children(children(children(children(children(children()))))))))))/$entity\n    //http://nb-mdp-dev01:57970/$metadata#recursos/SIU.Documentos.Documento/$entity\n    //http://nb-mdp-dev01:57970/$metadata#SIU.Api.Infrastructure.Storage.Backend.SiuUrls\n    context(annots) {\n      let ctx = {};\n      const str = annots instanceof Map ? annots.get(this.ODATA_CONTEXT) : annots[this.ODATA_CONTEXT];\n\n      if (typeof str === 'string') {\n        let index = str.indexOf('$metadata');\n        ctx.serviceRootUrl = str.substring(0, index);\n        index = str.indexOf('#');\n        ctx.metadataUrl = str.substring(0, index);\n        const parts = str.substring(index + 1).split('/');\n        const col = COLLECTION.exec(parts[0]);\n\n        if (col) {\n          ctx.type = col[1];\n        } else if (parts[0].indexOf('.') !== -1) {\n          ctx.type = parts[0];\n        } else {\n          const property = parts[0].match(PROPERTY);\n          const expand = parts[0].match(EXPAND);\n          ctx.entity = parts[1] === '$entity';\n\n          if (property) {\n            ctx.entitySet = property[1];\n            ctx.key = property[2];\n            ctx.property = parts[1];\n          } else if (expand) {\n            ctx.entitySet = expand[1];\n            ctx.expand = expand[2];\n          } else {\n            ctx.entitySet = parts[0];\n          }\n        }\n      }\n\n      return ctx;\n    },\n\n    countParam() {\n      return {\n        [$COUNT]: 'true'\n      };\n    }\n\n  }),\n  //#endregion\n  //#region Version 3.0\n  [VERSION_3_0]: Object.assign({}, ODataVersionBaseHelper, {\n    ODATA_ANNOTATION_PREFIX: 'odata.',\n    ODATA_FUNCTION_PREFIX: '',\n    ODATA_ID: 'odata.id',\n    ODATA_ETAG: 'odata.etag',\n    ODATA_CONTEXT: 'odata.metadata',\n    ODATA_NEXTLINK: 'odata.nextLink',\n    ODATA_TYPE: 'odata.type',\n    ODATA_COUNT: 'odata.count',\n    VALUE: 'value',\n\n    context(annots) {\n      let ctx = {};\n      const str = annots instanceof Map ? annots.get(this.ODATA_CONTEXT) : annots[this.ODATA_CONTEXT];\n\n      if (typeof str === 'string') {\n        let index = str.indexOf('$metadata');\n        ctx.serviceRootUrl = str.substring(0, index);\n        index = str.indexOf('#');\n        ctx.metadataUrl = str.substring(0, index);\n        const parts = str.substring(index + 1).split('/');\n        ctx.entitySet = parts[0];\n      }\n\n      return ctx;\n    },\n\n    countParam() {\n      return {\n        [$INLINECOUNT]: 'allpages'\n      };\n    }\n\n  }),\n  //#endregion\n  //#region Version 2.0\n  [VERSION_2_0]: Object.assign({}, ODataVersionBaseHelper, {\n    ODATA_ID: 'id',\n    ODATA_ETAG: 'etag',\n    ODATA_ANNOTATION: '__metadata',\n    ODATA_NEXTLINK: '__next',\n    ODATA_COUNT: '__count',\n    ODATA_DEFERRED: '__deferred',\n    ODATA_TYPE: 'type',\n    VALUE: 'results',\n\n    annotations(value) {\n      const annots = new Map();\n\n      if (this.ODATA_ANNOTATION in value) {\n        Object.entries(value[this.ODATA_ANNOTATION]).forEach(([key, value]) => annots.set(key, value));\n      }\n\n      return annots;\n    },\n\n    attributes(value, metadata) {\n      return value;\n    },\n\n    countParam() {\n      return {\n        [$INLINECOUNT]: 'allpages'\n      };\n    }\n\n  }) //#endregion\n\n};\n\nclass ODataAnnotation {\n  constructor(annot) {\n    this.term = annot.term;\n    Object.assign(this, annot);\n  }\n\n}\n\nclass ODataAnnotatable {\n  constructor(config) {\n    this.annotations = (config.annotations || []).map(annot => new ODataAnnotation(annot));\n  }\n  /**\n   * Find an annotation inside the annotatable.\n   * @param predicate Function that returns true if the annotation match.\n   * @returns The annotation that matches the predicate.\n   */\n\n\n  findAnnotation(predicate) {\n    return this.annotations.find(predicate);\n  }\n  /**\n   * Find an annotation inside the annotatable and return its value.\n   * @param term The term of the annotation to find.\n   * @returns The value of the annotation.\n   */\n\n\n  annotatedValue(term) {\n    const reg = term instanceof RegExp ? term : new RegExp(`^${term}$`);\n    const annot = this.findAnnotation(a => reg.test(a.term));\n\n    if (!annot) {\n      return undefined;\n    }\n\n    return annot.string || annot.bool || annot.int || annot.permissions || annot.properties;\n  }\n\n}\n\nclass ODataSchemaElement extends ODataAnnotatable {\n  constructor(config, schema) {\n    super(config);\n    this.schema = schema;\n    this.name = config.name;\n  }\n\n  get api() {\n    return this.schema.api;\n  }\n  /**\n   * Create a nicer looking title.\n   * Titleize is meant for creating pretty output.\n   * @param term The term of the annotation to find.\n   * @returns The titleized string.\n   */\n\n\n  titleize(term) {\n    return term && this.annotatedValue(term) || Strings.titleCase(this.name);\n  }\n  /**\n   * Returns a full type of the structured type including the namespace/alias.\n   * @param alias Use the alias of the namespace instead of the namespace.\n   * @returns The string representation of the type.\n   */\n\n\n  type({\n    alias = false\n  } = {}) {\n    return `${alias ? this.schema.alias : this.schema.namespace}.${this.name}`;\n  }\n  /**\n   * Returns a boolean indicating if the structured type is of the given type.\n   * @param type String representation of the type\n   * @returns True if the callable is type of the given type\n   */\n\n\n  isTypeOf(type) {\n    var names = [`${this.schema.namespace}.${this.name}`];\n    if (this.schema.alias) names.push(`${this.schema.alias}.${this.name}`);\n    return names.indexOf(type) !== -1;\n  }\n  /**\n   * Returns a boolean indicating if the structured type is a subtype of the given type.\n   * @param type String representation of the type\n   * @returns True if the callable is type of the given type\n   */\n\n\n  isSubtypeOf(schema) {\n    if (this.isTypeOf(schema.type())) return true;\n    return false;\n  }\n  /**\n   * Returns a boolean indicating if the structured type is a supertype of the given type.\n   * @param type String representation of the type\n   * @returns True if the callable is type of the given type\n   */\n\n\n  isSupertypeOf(schema) {\n    if (this.isTypeOf(schema.type())) return true;\n    return false;\n  }\n\n} //https://github.com/niklasvh/base64-arraybuffer\n\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.\n\nconst lookup = new Uint8Array(256);\n\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\n\nconst ArrayBuffers = {\n  toArrayBuffer(v) {\n    var bufferLength = v.length * 0.75,\n        len = v.length,\n        i,\n        p = 0,\n        encoded1,\n        encoded2,\n        encoded3,\n        encoded4;\n\n    if (v[v.length - 1] === '=') {\n      bufferLength--;\n\n      if (v[v.length - 2] === '=') {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i += 4) {\n      encoded1 = lookup[v.charCodeAt(i)];\n      encoded2 = lookup[v.charCodeAt(i + 1)];\n      encoded3 = lookup[v.charCodeAt(i + 2)];\n      encoded4 = lookup[v.charCodeAt(i + 3)];\n      bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n\n    return arraybuffer;\n  },\n\n  toString(v) {\n    var bytes = new Uint8Array(v),\n        i,\n        len = bytes.length,\n        base64 = '';\n\n    for (i = 0; i < len; i += 3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if (len % 3 === 2) {\n      base64 = base64.substring(0, base64.length - 1) + '=';\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n\n    return base64;\n  }\n\n}; // Core EdmTypeParserBuilder\n\nconst EdmParser = (_d, _s, _e) => ({\n  deserialize(value, options) {\n    return Array.isArray(value) ? value.map(v => _d(v, options)) : _d(value, options);\n  },\n\n  serialize(value, options) {\n    return Array.isArray(value) ? value.map(v => _s(v, options)) : _s(value, options);\n  },\n\n  encode(value, options) {\n    return Array.isArray(value) ? value.map(v => _e(v, options)) : _e(value, options);\n  }\n\n});\n\nconst Identity = v => v;\n\nconst toNumber = v => Number(v);\n\nconst toString = v => v.toString();\n\nconst toBoolean = v => Boolean(v);\n\nconst toDate = v => new Date(v);\n\nconst EDM_PARSERS = {\n  //Edm.Guid 16-byte (128-bit) unique identifier\n  'Edm.Guid': EdmParser(Identity, Identity, v => raw(v)),\n  //Edm.Int16 Signed 16-bit integer\n  'Edm.Int16': EdmParser(toNumber, toNumber, toNumber),\n  //Edm.String Sequence of UTF-8 characters\n  'Edm.String': EdmParser(toString, toString, toString),\n  //Edm.Boolean Binary-valued logic\n  'Edm.Boolean': EdmParser(toBoolean, toBoolean, toBoolean),\n  //Edm.Byte Unsigned 8-bit integer\n  'Edm.Byte': EdmParser(toNumber, toNumber, toNumber),\n  //Edm.SByte Signed 8-bit integer\n  'Edm.SByte': EdmParser(toNumber, toNumber, toNumber),\n  //Edm.Int32 Signed 16-bit integer\n  'Edm.Int32': EdmParser(toNumber, toNumber, toNumber),\n  //Edm.Int64 Signed 16-bit integer\n  'Edm.Int64': EdmParser(toNumber, toNumber, toNumber),\n  //Edm.Date Date without a time-zone offset\n  'Edm.Date': EdmParser(v => new Date(`${v}T00:00:00.000Z`), v => toDate(v).toISOString().substring(0, 10), v => toDate(v).toISOString().substring(0, 10)),\n  //Edm.TimeOfDay Clock time 00:00-23:59:59.999999999999\n  'Edm.TimeOfDay': EdmParser(v => new Date(`1970-01-01T${v}Z`), v => toDate(v).toISOString().substring(11, 23), v => toDate(v).toISOString().substring(11, 23)),\n  //Edm.DateTimeOffset Date and time with a time-zone offset, no leap seconds\n  'Edm.DateTimeOffset': EdmParser(toDate, v => toDate(v).toISOString(), v => toDate(v).toISOString()),\n  //Edm.Duration Signed duration in days, hours, minutes, and (sub)seconds\n  'Edm.Duration': EdmParser(v => Durations.toDuration(v), v => Durations.toString(v), v => Durations.toString(v)),\n  //Edm.Decimal Numeric values with fixed precision and scale\n  'Edm.Decimal': EdmParser((v, o) => {\n    if (typeof v === 'string' && o.ieee754Compatible) {\n      return parseFloat(v);\n    }\n\n    return v;\n  }, (v, o) => {\n    if (o.ieee754Compatible) {\n      return parseFloat(v.toPrecision(o.field.precision)).toFixed(o.field.scale);\n    }\n\n    return v;\n  }, (v, o) => {\n    if (o.ieee754Compatible) {\n      return parseFloat(v.toPrecision(o.field.precision)).toFixed(o.field.scale);\n    }\n\n    return v;\n  }),\n  //Edm.Double IEEE 754 binary64 floating-point number (15-17 decimal digits)\n  'Edm.Double': EdmParser(v => v === 'INF' ? Infinity : v, v => v === Infinity ? 'INF' : v, v => v === Infinity ? 'INF' : v),\n  //Edm.Single IEEE 754 binary32 floating-point number (6-9 decimal digits)\n  'Edm.Single': EdmParser(v => v === 'INF' ? Infinity : v, v => v === Infinity ? 'INF' : v, v => v === Infinity ? 'INF' : v),\n  //Edm.Binary Binary data\n  'Edm.Binary': EdmParser(v => ArrayBuffers.toArrayBuffer(v), v => ArrayBuffers.toString(v), v => ArrayBuffers.toString(v))\n};\n/*\nEdm.Stream Binary data stream\nEdm.Geography Abstract base type for all Geography types\nEdm.GeographyPoint A point in a round-earth coordinate system\nEdm.GeographyLineString Line string in a round-earth coordinate system\nEdm.GeographyPolygon Polygon in a round-earth coordinate system\nEdm.GeographyMultiPoint Collection of points in a round-earth coordinate system\nEdm.GeographyMultiLineString Collection of line strings in a round-earth coordinate system\nEdm.GeographyMultiPolygon Collection of polygons in a round-earth coordinate system\nEdm.GeographyCollection Collection of arbitrary Geography values\nEdm.Geometry Abstract base type for all Geometry types\nEdm.GeometryPoint Point in a flat-earth coordinate system\nEdm.GeometryLineString Line string in a flat-earth coordinate system\nEdm.GeometryPolygon Polygon in a flat-earth coordinate system\nEdm.GeometryMultiPoint Collection of points in a flat-earth coordinate system\nEdm.GeometryMultiLineString Collection of line strings in a flat-earth coordinate system\nEdm.GeometryMultiPolygon Collection of polygons in a flat-earth coordinate system\nEdm.GeometryCollection Collection of arbitrary Geometry values\n*/\n\nclass ODataEnumTypeFieldParser extends ODataAnnotatable {\n  constructor(name, field) {\n    super(field);\n    this.name = name;\n    this.value = field.value;\n  }\n\n  titleize(term) {\n    return term && this.annotatedValue(term) || this.name;\n  }\n\n}\n\nclass ODataEnumTypeParser extends ODataAnnotatable {\n  constructor(config, namespace, alias) {\n    super(config);\n    this.name = config.name;\n    this.namespace = namespace;\n    this.alias = alias;\n    this.flags = config.flags;\n    this.members = config.members;\n    this.fields = Object.entries(config.fields).map(([name, f]) => new ODataEnumTypeFieldParser(name, f));\n  }\n  /**\n   * Create a nicer looking title.\n   * Titleize is meant for creating pretty output.\n   * @param term The term of the annotation to find.\n   * @returns The titleized string.\n   */\n\n\n  ttitelize(term) {\n    return term && this.annotatedValue(term) || Strings.titleCase(this.name);\n  }\n\n  configure({\n    stringAsEnum,\n    options\n  }) {\n    this.stringAsEnum = stringAsEnum;\n    this.parserOptions = options;\n  }\n\n  isTypeOf(type) {\n    var names = [`${this.namespace}.${this.name}`];\n    if (this.alias) names.push(`${this.alias}.${this.name}`);\n    return names.indexOf(type) !== -1;\n  } // Deserialize\n\n\n  deserialize(value, options) {\n    // string -> number\n    const parserOptions = options || this.parserOptions;\n\n    if (this.flags) {\n      return Enums.toValues(this.members, value).reduce((acc, v) => acc | v, 0);\n    } else {\n      return Enums.toValue(this.members, value);\n    }\n  } // Serialize\n\n\n  serialize(value, options) {\n    // Enum are string | number\n    // string | number -> string\n    const parserOptions = options || this.parserOptions;\n\n    if (this.flags) {\n      const names = Enums.toNames(this.members, value);\n      if (names.length === 0) return undefined;\n      return !this.stringAsEnum ? `${this.namespace}.${this.name}'${names.join(', ')}'` : names.join(', ');\n    } else {\n      const name = Enums.toName(this.members, value);\n      if (name === undefined) return undefined;\n      return !this.stringAsEnum ? `${this.namespace}.${this.name}'${name}'` : name;\n    }\n  } //Encode\n\n\n  encode(value, options) {\n    const parserOptions = options || this.parserOptions;\n    const serialized = this.serialize(value, parserOptions);\n    if (serialized === undefined) return undefined;\n    return this.stringAsEnum ? raw(`'${serialized}'`) : raw(serialized);\n  } // Json Schema\n\n\n  toJsonSchema() {\n    let property = {\n      title: this.name,\n      type: 'string'\n    };\n    property.enum = this.fields.map(f => f.name);\n    return property;\n  }\n\n  validate(member, {\n    method,\n    navigation = false\n  } = {}) {\n    if (this.flags) {\n      let members = Enums.toValues(this.members, member);\n      return members.some(member => !(member in this.members)) ? ['mismatch'] : undefined;\n    } else {\n      return !(member in this.members) ? ['mismatch'] : undefined;\n    }\n  }\n\n}\n\nclass ODataEntityTypeKey {\n  constructor({\n    name,\n    alias\n  }) {\n    this.name = name;\n    this.alias = alias;\n  }\n\n}\n\nclass ODataReferential {\n  constructor({\n    property,\n    referencedProperty\n  }) {\n    this.property = property;\n    this.referencedProperty = referencedProperty;\n  }\n\n}\n\nclass ODataStructuredTypeFieldParser extends ODataAnnotatable {\n  constructor(name, structuredType, field) {\n    super(field);\n    this.name = name;\n    this.structuredType = structuredType;\n    this.type = field.type;\n    this.parser = NONE_PARSER;\n    this.referentials = (field.referentials || []).map(referential => new ODataReferential(referential));\n    this.default = field.default;\n    this.maxLength = field.maxLength;\n    this.nullable = field.nullable !== undefined ? field.nullable : true;\n    this.collection = Boolean(field.collection);\n    this.navigation = Boolean(field.navigation);\n    this.precision = field.precision;\n    this.scale = field.scale;\n  }\n\n  validate(value, {\n    method,\n    navigation = false\n  } = {}) {\n    let errors;\n\n    if (this.collection && Array.isArray(value)) {\n      errors = value.map(v => this.validate(v, {\n        method,\n        navigation\n      }));\n    } else if (this.isStructuredType() && typeof value === 'object' && value !== null || this.navigation && value !== undefined) {\n      errors = this.structured().validate(value, {\n        method,\n        navigation\n      }) || {};\n    } else if (this.isEnumType() && (typeof value === 'string' || typeof value === 'number')) {\n      errors = this.enum().validate(value, {\n        method,\n        navigation\n      });\n    } else {\n      // IsEdmType\n      const computed = this.annotatedValue(COMPUTED);\n      errors = [];\n\n      if (!this.nullable && (value === null || value === undefined && method !== 'modify') && // Is null or undefined without patch?\n      !(computed && method === 'create') // Not (Is Computed field and create) ?\n      ) {\n        errors.push(`required`);\n      }\n\n      if (this.maxLength !== undefined && typeof value === 'string' && value.length > this.maxLength) {\n        errors.push(`maxlength`);\n      }\n    }\n\n    return !Types.isEmpty(errors) ? errors : undefined;\n  } //#region Deserialize\n\n\n  parse(parser, value, options) {\n    const type = options !== undefined && Types.isPlainObject(value) ? ODataHelper[(options === null || options === void 0 ? void 0 : options.version) || DEFAULT_VERSION].type(value) : undefined;\n\n    if (type !== undefined) {\n      return parser.childParser(c => c.isTypeOf(type)).deserialize(value, options);\n    }\n\n    return parser.deserialize(value, options);\n  }\n\n  deserialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n\n    if (this.parser instanceof ODataStructuredTypeParser) {\n      const parser = this.parser;\n      return Array.isArray(value) ? value.map(v => this.parse(parser, v, parserOptions)) : this.parse(parser, value, parserOptions);\n    }\n\n    return this.parser.deserialize(value, Object.assign({\n      field: this\n    }, parserOptions));\n  } //#endregion\n  //#region Serialize\n\n\n  toJson(parser, value, options) {\n    const type = options !== undefined && Types.isPlainObject(value) ? ODataHelper[(options === null || options === void 0 ? void 0 : options.version) || DEFAULT_VERSION].type(value) : undefined;\n\n    if (type !== undefined) {\n      return parser.childParser(c => c.isTypeOf(type)).serialize(value, options);\n    }\n\n    return parser.serialize(value, options);\n  }\n\n  serialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n\n    if (this.parser instanceof ODataStructuredTypeParser) {\n      const parser = this.parser;\n      return Array.isArray(value) ? value.map(v => this.toJson(parser, v, parserOptions)) : this.toJson(parser, value, parserOptions);\n    }\n\n    return this.parser.serialize(value, Object.assign({\n      field: this\n    }, parserOptions));\n  } //#endregion\n  //#region Encode\n\n\n  encode(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return this.parser.encode(value, Object.assign({\n      field: this\n    }, parserOptions));\n  } //#endregion\n\n\n  configure({\n    parserForType,\n    options\n  }) {\n    this.parserOptions = options;\n    this.parser = parserForType(this.type);\n\n    if (this.default !== undefined) {\n      this.default = this.deserialize(this.default, options);\n    }\n  } //#region Json Schema\n  // https://json-schema.org/\n\n\n  toJsonSchema(options = {}) {\n    let schema = this.parser instanceof ODataStructuredTypeFieldParser || this.parser instanceof ODataStructuredTypeParser || this.parser instanceof ODataEnumTypeParser ? this.parser.toJsonSchema(options) : {\n      title: this.name,\n      type: 'object'\n    };\n\n    if (['Edm.String', 'Edm.Date', 'Edm.TimeOfDay', 'Edm.DateTimeOffset', 'Edm.Guid', 'Edm.Binary'].indexOf(this.type) !== -1) {\n      schema.type = 'string';\n      if (this.type === 'Edm.Date') schema.format = 'date';else if (this.type === 'Edm.TimeOfDay') schema.format = 'time';else if (this.type === 'Edm.DateTimeOffset') schema.format = 'date-time';else if (this.type === 'Edm.Guid') schema.pattern = '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$';else if (this.type === 'Edm.Binary') schema.contentEncoding = 'base64';else if (this.type === 'Edm.String' && this.maxLength) schema.maxLength = this.maxLength;\n    } else if (['Edm.Int64', 'Edm.Int32', 'Edm.Int16', 'Edm.Byte', 'Edm.SByte'].indexOf(this.type) !== -1) {\n      //TODO: Range\n      schema.type = 'integer';\n    } else if (['Edm.Decimal', 'Edm.Double'].indexOf(this.type) !== -1) {\n      schema.type = 'number';\n    } else if (['Edm.Boolean'].indexOf(this.type) !== -1) {\n      schema.type = 'boolean';\n    }\n\n    if (this.default) schema.default = this.default;\n    if (this.nullable) schema.type = [schema.type, 'null'];\n    if (this.collection) schema = {\n      type: 'array',\n      items: schema,\n      additionalItems: false\n    };\n    return schema;\n  } //#endregion\n\n\n  isKey() {\n    var _a;\n\n    return ((_a = this.structuredType.keys) === null || _a === void 0 ? void 0 : _a.find(k => k.name === this.name)) !== undefined;\n  }\n\n  hasReferentials() {\n    return this.referentials.length !== 0;\n  }\n\n  isEdmType() {\n    return this.type.startsWith('Edm.');\n  }\n\n  isEnumType() {\n    return this.parser instanceof ODataEnumTypeParser;\n  }\n\n  enum() {\n    if (!this.isEnumType()) throw new Error('Field are not EnumType');\n    return this.parser;\n  }\n\n  isStructuredType() {\n    return this.parser instanceof ODataStructuredTypeParser;\n  }\n\n  structured() {\n    if (!this.isStructuredType()) throw new Error('Field are not StrucuturedType');\n    return this.parser;\n  }\n\n}\n\nclass ODataStructuredTypeParser extends ODataAnnotatable {\n  constructor(config, namespace, alias) {\n    super(config);\n    this.children = [];\n    this.name = config.name;\n    this.base = config.base;\n    this.open = config.open || false;\n    this.namespace = namespace;\n    this.alias = alias;\n    if (Array.isArray(config.keys)) this.keys = config.keys.map(key => new ODataEntityTypeKey(key));\n    this.fields = Object.entries(config.fields).map(([name, config]) => new ODataStructuredTypeFieldParser(name, this, config));\n  }\n  /**\n   * Create a nicer looking title.\n   * Titleize is meant for creating pretty output.\n   * @param term The term of the annotation to find.\n   * @returns The titleized string.\n   */\n\n\n  titleize(term) {\n    return term && this.annotatedValue(term) || Strings.titleCase(this.name);\n  }\n\n  isTypeOf(type) {\n    var names = [`${this.namespace}.${this.name}`];\n    if (this.alias) names.push(`${this.alias}.${this.name}`);\n    return names.indexOf(type) !== -1;\n  }\n\n  isSubtypeOf(type) {\n    if (this.isTypeOf(type)) return true;\n    if (this.parent) return this.parent.isSubtypeOf(type);\n    return false;\n  }\n\n  findChildParser(predicate) {\n    if (predicate(this)) return this;\n    let match;\n\n    for (let ch of this.children) {\n      match = ch.findChildParser(predicate);\n      if (match !== undefined) break;\n    }\n\n    return match;\n  }\n\n  childParser(predicate) {\n    return this.findChildParser(predicate) || NONE_PARSER;\n  } // Deserialize\n\n\n  deserialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    if (this.parent !== undefined) value = this.parent.deserialize(value, parserOptions);\n    const fields = this.fields.filter(f => f.name in value && value[f.name] !== undefined && value[f.name] !== null);\n    return Object.assign(Object.assign({}, value), fields.reduce((acc, f) => Object.assign(Object.assign({}, acc), {\n      [f.name]: f.deserialize(value[f.name], parserOptions)\n    }), {}));\n  } // Serialize\n\n\n  serialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    if (this.parent !== undefined) value = this.parent.serialize(value, parserOptions);\n    const fields = this.fields.filter(f => f.name in value && value[f.name] !== undefined && value[f.name] !== null);\n    return Object.assign(Object.assign({}, value), fields.reduce((acc, f) => Object.assign(Object.assign({}, acc), {\n      [f.name]: f.serialize(value[f.name], parserOptions)\n    }), {}));\n  } // Encode\n\n\n  encode(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return raw(JSON.stringify(this.serialize(value, parserOptions)));\n  }\n\n  configure({\n    parserForType,\n    options\n  }) {\n    this.parserOptions = options;\n\n    if (this.base) {\n      const parent = parserForType(this.base);\n      parent.children.push(this);\n      this.parent = parent;\n    }\n\n    this.fields.forEach(f => f.configure({\n      parserForType,\n      options\n    }));\n  }\n\n  resolveKey(value) {\n    var _a;\n\n    let key = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.resolveKey(value)) || {};\n\n    if (Array.isArray(this.keys) && this.keys.length > 0) {\n      for (var k of this.keys) {\n        let v = value;\n        let structured = this;\n        let field;\n\n        for (let name of k.name.split('/')) {\n          if (structured === undefined) break;\n          field = structured.fields.find(f => f.name === name);\n\n          if (field !== undefined) {\n            v = Types.isPlainObject(v) ? v[field.name] : v;\n            structured = field.isStructuredType() ? field.structured() : undefined;\n          }\n        }\n\n        if (field !== undefined && v !== undefined) {\n          key[k.alias || field.name] = field.encode(v);\n        }\n      }\n    }\n\n    if (Types.isEmpty(key)) return undefined;\n    return Objects.resolveKey(key);\n  }\n\n  defaults() {\n    var _a;\n\n    let value = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.defaults()) || {};\n    let fields = this.fields.filter(f => f.default !== undefined || f.isStructuredType());\n    return Object.assign(Object.assign({}, value), fields.reduce((acc, f) => {\n      let value = f.isStructuredType() ? f.structured().defaults() : f.default;\n      return Types.isEmpty(value) ? acc : Object.assign(Object.assign({}, acc), {\n        [f.name]: value\n      });\n    }, {}));\n  } // Json Schema\n\n\n  toJsonSchema(options = {}) {\n    var _a;\n\n    let schema = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.toJsonSchema(options)) || {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      $id: `${this.namespace}.${this.name}`,\n      title: this.titleize(DESCRIPTION),\n      description: this.annotatedValue(LONG_DESCRIPTION),\n      type: 'object',\n      properties: {},\n      required: []\n    };\n    const fields = this.fields.filter(f => (!f.navigation || options.expand && f.name in options.expand) && (!options.select || options.select.indexOf(f.name) !== -1));\n    schema.properties = Object.assign({}, schema.properties, fields.map(f => {\n      let expand = options.expand && f.name in options.expand ? options.expand[f.name] : undefined;\n      let schema = f.toJsonSchema(expand);\n      if (options.custom && f.name in options.custom) schema = options.custom[f.name](schema, f);\n      return {\n        [f.name]: schema\n      };\n    }).reduce((acc, v) => Object.assign(acc, v), {}));\n    schema.required = [...schema.required, ...fields.filter(f => options.required && f.name in options.required ? options.required[f.name] : !f.nullable).map(f => f.name)];\n    return schema;\n  }\n\n  validate(attrs, {\n    method,\n    navigation = false\n  } = {}) {\n    var _a;\n\n    const errors = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.validate(attrs, {\n      method,\n      navigation\n    })) || {};\n    const fields = this.fields.filter(f => !f.navigation || navigation);\n\n    for (var field of fields) {\n      const value = attrs[field.name];\n      const errs = field.validate(value, {\n        method,\n        navigation\n      });\n\n      if (errs !== undefined) {\n        errors[field.name] = errs;\n      }\n    }\n\n    return !Types.isEmpty(errors) ? errors : undefined;\n  }\n\n}\n\nclass ODataParameterParser {\n  constructor(name, parameter) {\n    this.name = name;\n    this.type = parameter.type;\n    this.parser = NONE_PARSER;\n    this.nullable = parameter.nullable;\n    this.collection = parameter.collection;\n  }\n\n  serialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return Array.isArray(value) ? value.map(v => this.parser.serialize(v, parserOptions)) : this.parser.serialize(value, parserOptions);\n  } //Encode\n\n\n  encode(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return Array.isArray(value) ? value.map(v => this.parser.encode(v, parserOptions)) : this.parser.encode(value, parserOptions);\n  }\n\n  configure({\n    parserForType,\n    options\n  }) {\n    this.parserOptions = options;\n    this.parser = parserForType(this.type);\n  }\n\n  isEdmType() {\n    return this.type.startsWith('Edm.');\n  }\n\n  isEnumType() {\n    return this.parser instanceof ODataEnumTypeParser;\n  }\n\n  enum() {\n    if (!this.isEnumType()) throw new Error('Field are not EnumType');\n    return this.parser;\n  }\n\n  isStructuredType() {\n    return this.parser instanceof ODataStructuredTypeParser;\n  }\n\n  structured() {\n    if (!this.isStructuredType()) throw new Error('Field are not StrucuturedType');\n    return this.parser;\n  }\n\n}\n\nclass ODataCallableParser {\n  constructor(config, namespace, alias) {\n    this.name = config.name;\n    this.namespace = namespace;\n    this.alias = alias;\n    this.return = config.return;\n    this.parser = NONE_PARSER;\n    this.parameters = Object.entries(config.parameters || []).map(([name, p]) => new ODataParameterParser(name, p));\n  }\n\n  isTypeOf(type) {\n    var names = [`${this.namespace}.${this.name}`];\n    if (this.alias) names.push(`${this.alias}.${this.name}`);\n    return names.indexOf(type) !== -1;\n  } // Deserialize\n\n\n  deserialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return this.parser.deserialize(value, parserOptions);\n  } // Serialize\n\n\n  serialize(params, options) {\n    const parserOptions = options || this.parserOptions;\n    const parameters = this.parameters.filter(p => p.name !== CALLABLE_BINDING_PARAMETER).filter(p => p.name in params && params[p.name] !== undefined);\n    return parameters.reduce((acc, p) => Object.assign(Object.assign({}, acc), {\n      [p.name]: p.serialize(params[p.name], parserOptions)\n    }), {});\n  } //Encode\n\n\n  encode(params, options) {\n    const parserOptions = options || this.parserOptions;\n    const parameters = this.parameters.filter(p => p.name !== CALLABLE_BINDING_PARAMETER).filter(p => p.name in params && params[p.name] !== undefined);\n    return parameters.reduce((acc, p) => Object.assign(Object.assign({}, acc), {\n      [p.name]: p.encode(params[p.name], parserOptions)\n    }), {});\n  }\n\n  configure({\n    nonParenthesisForEmptyParameterFunction,\n    parserForType,\n    options\n  }) {\n    this.nonParenthesisForEmptyParameterFunction = nonParenthesisForEmptyParameterFunction;\n    this.parserOptions = options;\n    if (this.return) this.parser = parserForType(this.return.type) || NONE_PARSER;\n    this.parameters.forEach(p => p.configure({\n      parserForType,\n      options\n    }));\n  }\n\n  binding() {\n    return this.parameters.find(p => p.name === CALLABLE_BINDING_PARAMETER);\n  }\n\n}\n\nclass ODataCallable extends ODataSchemaElement {\n  constructor(config, schema) {\n    super(config, schema);\n    this.entitySetPath = config.entitySetPath;\n    this.bound = config.bound;\n    this.composable = config.composable;\n    this.parser = new ODataCallableParser(config, schema.namespace, schema.alias);\n  }\n\n  path() {\n    var _a;\n\n    let path;\n    if (this.entitySetPath) path = this.entitySetPath;else if (this.bound) path = `${this.schema.namespace}.${this.name}`;else path = this.parser.return ? ((_a = this.api.findEntitySetForType(this.parser.return.type)) === null || _a === void 0 ? void 0 : _a.name) || this.name : this.name;\n    return path;\n  }\n\n  configure({\n    parserForType\n  }) {\n    this.parser.configure({\n      nonParenthesisForEmptyParameterFunction: this.api.options.nonParenthesisForEmptyParameterFunction,\n      options: this.api.options.parserOptions,\n      parserForType\n    });\n  }\n  /**\n   * Deseialize the given value from the callable.\n   * @param value Value to deserialize\n   * @param options Options for deserialization\n   * @returns Deserialized value\n   */\n\n\n  deserialize(value, options) {\n    return this.parser.deserialize(value, options);\n  }\n  /**\n   * Serialize the given value for the callable.\n   * @param value Value to serialize\n   * @param options Options for serialization\n   * @returns Serialized value\n   */\n\n\n  serialize(value, options) {\n    return this.parser.serialize(value, options);\n  }\n  /**\n   * Encode the given value for the callable.\n   * @param value Value to encode\n   * @param options Options for encoding\n   * @returns Encoded value\n   */\n\n\n  encode(value, options) {\n    return this.parser.encode(value, options);\n  }\n  /**\n   * Returns the binding parameter of the callable.\n   * @returns The binding parameter of the callable.\n   */\n\n\n  binding() {\n    return this.parser.binding();\n  }\n\n}\n\nclass ODataEntitySet extends ODataSchemaElement {\n  constructor(config, schema) {\n    super(config, schema);\n    this.entityType = config.entityType;\n    this.service = config.service;\n  }\n\n}\n\nclass ODataEntityContainer extends ODataSchemaElement {\n  constructor(config, schema) {\n    super(config, schema);\n    this.entitySets = (config.entitySets || []).map(config => new ODataEntitySet(config, schema));\n  }\n\n}\n\nclass ODataEnumType extends ODataSchemaElement {\n  constructor(config, schema) {\n    super(config, schema);\n    this.members = config.members;\n    this.parser = new ODataEnumTypeParser(config, schema.namespace, schema.alias);\n  }\n\n  configure() {\n    this.parser.configure({\n      stringAsEnum: this.api.options.stringAsEnum,\n      options: this.api.options.parserOptions\n    });\n  }\n  /**\n   * Returns the fields of the enum type.\n   * @returns The fields of the enum type.\n   */\n\n\n  fields() {\n    return this.parser.fields;\n  }\n  /**\n   * Find a field by name.\n   * @param name The name of the field\n   * @returns The field with the given name\n   */\n\n\n  findFieldByName(name) {\n    return this.fields().find(f => f.name === name);\n  }\n  /**\n   * Find a field by value.\n   * @param value The value of the field\n   * @returns The field with the given value\n   */\n\n\n  findFieldByValue(value) {\n    return this.fields().find(f => f.value === value);\n  }\n  /**\n   * Find a fields by flag.\n   * @param value The value of the field\n   * @returns The fields with the given flag\n   */\n\n\n  findFieldsByValue(value) {\n    return this.fields().filter(f => Boolean(f.value & value));\n  }\n  /**\n   * Map the fields of the enum type.\n   * @param mapper Function that maps the value to the new value\n   * @returns The fields mapped by the mapper\n   */\n\n\n  mapFields(mapper) {\n    return this.fields().map(mapper);\n  }\n  /**\n   * Deseialize the given value from the enum type.\n   * @param value Value to deserialize\n   * @param options Options for deserialization\n   * @returns Deserialized value\n   */\n\n\n  deserialize(value, options) {\n    return this.parser.deserialize(value, options);\n  }\n  /**\n   * Serialize the given value for the enum type.\n   * @param value Value to serialize\n   * @param options Options for serialization\n   * @returns Serialized value\n   */\n\n\n  serialize(value, options) {\n    return this.parser.serialize(value, options);\n  }\n  /**\n   * Encode the given value for the enum type.\n   * @param value Value to encode\n   * @param options Options for encoding\n   * @returns Encoded value\n   */\n\n\n  encode(value, options) {\n    return this.parser.encode(value, options);\n  }\n\n}\n\nclass ODataStructuredType extends ODataSchemaElement {\n  constructor(config, schema) {\n    super(config, schema);\n    this.children = [];\n    this.base = config.base;\n    this.open = config.open || false;\n    this.parser = new ODataStructuredTypeParser(config, schema.namespace, schema.alias);\n    this.model = config.model;\n    this.collection = config.collection;\n\n    if (this.model !== undefined) {\n      const options = this.model.hasOwnProperty('options') ? this.model.options : {\n        fields: {}\n      };\n      this.model.buildMeta({\n        options,\n        schema: this\n      });\n    }\n\n    if (this.collection !== undefined) {\n      this.collection.model = this.model;\n    }\n  }\n\n  configure({\n    parserForType,\n    findOptionsForType\n  }) {\n    if (this.base) {\n      const parent = this.api.findStructuredTypeForType(this.base);\n      parent.children.push(this);\n      this.parent = parent;\n    }\n\n    this.parser.configure({\n      parserForType,\n      options: this.api.options.parserOptions\n    });\n\n    if (this.model !== undefined && this.model.options !== null) {\n      this.model.meta.configure({\n        findOptionsForType,\n        options: this.api.options.parserOptions\n      });\n    }\n  }\n  /**\n   * Returns a boolean indicating if the structured type is a subtype of the given type.\n   * @param type String representation of the type\n   * @returns True if the callable is type of the given type\n   */\n\n\n  isSubtypeOf(schema) {\n    return super.isSubtypeOf(schema) || this.parent !== undefined && this.parent.isSubtypeOf(schema);\n  }\n  /**\n   * Returns a boolean indicating if the structured type is a supertype of the given type.\n   * @param type String representation of the type\n   * @returns True if the callable is type of the given type\n   */\n\n\n  isSupertypeOf(schema) {\n    return super.isSupertypeOf(schema) || this.children.some(c => c.isSupertypeOf(schema));\n  }\n  /**\n   * Returns a boolean indicating if the structured type has a simple key.\n   * @returns True if the structured type has a simple key\n   */\n\n\n  isSimpleKey() {\n    return this.keys().length === 1;\n  }\n  /**\n   * Returns a boolean indicating if the structured type has a compound key.\n   * @returns True if the structured type has a compound key.\n   */\n\n\n  isCompoundKey() {\n    return this.keys().length > 1;\n  }\n  /**\n   * Find the field parser for the given field name.\n   * @param name Name of the field\n   * @returns The field parser\n   */\n\n\n  findFieldByName(name) {\n    return this.fields({\n      include_parents: true,\n      include_navigation: true\n    }).find(f => f.name === name);\n  }\n  /**\n   * Find a parent schema of the structured type.\n   * @param predicate Function for evaluate the schemas in the hierarchy.\n   * @returns The schema that matches the predicate.\n   */\n\n\n  findParentSchema(predicate) {\n    if (predicate(this)) return this;\n    if (this.parent === undefined) return undefined;\n    return this.parent.findParentSchema(predicate);\n  }\n  /**\n   * Find a parent schema of the structured type for the given field.\n   * @param field Field that belongs to the structured type\n   * @returns The schema of the field\n   */\n\n\n  findSchemaForField(field) {\n    return this.findParentSchema(p => p.fields({\n      include_parents: false,\n      include_navigation: true\n    }).find(f => f === field) !== undefined);\n  }\n  /**\n   * Returns all fields of the structured type.\n   * @param include_navigation Include navigation properties in the result.\n   * @param include_parents Include the parent types in the result.\n   * @returns All fields of the structured type.\n   */\n\n\n  fields({\n    include_navigation,\n    include_parents\n  }) {\n    return [...(include_parents && this.parent !== undefined ? this.parent.fields({\n      include_parents,\n      include_navigation\n    }) : []), ...this.parser.fields.filter(field => include_navigation || !field.navigation)];\n  }\n  /**\n   * Returns the keys of the structured type.\n   * @param include_parents Include the parent fields\n   * @returns The keys of the structured type\n   */\n\n\n  keys({\n    include_parents = true\n  } = {}) {\n    return [...(include_parents && this.parent !== undefined ? this.parent.keys({\n      include_parents\n    }) : []), ...(this.parser.keys || [])];\n  }\n  /**\n   * Picks the fields from attributes.\n   * @param attrs\n   * @param include_parents Include the parent fields\n   * @param include_navigation Include the navigation fields\n   * @param include_etag Include the etag field\n   * @returns The picked fields\n   */\n\n\n  pick(attrs, {\n    include_parents = true,\n    include_navigation = false,\n    include_etag = true\n  } = {}) {\n    const names = this.fields({\n      include_parents,\n      include_navigation\n    }).map(f => f.name);\n    return Object.keys(attrs).filter(key => names.indexOf(key) !== -1 || key == this.api.options.helper.ODATA_ETAG && include_etag).reduce((acc, key) => Object.assign(acc, {\n      [key]: attrs[key]\n    }), {});\n  }\n  /**\n   * Deseialize the given value from the structured type.\n   * @param value Value to deserialize\n   * @param options Options for deserialization\n   * @returns Deserialized value\n   */\n\n\n  deserialize(value, options) {\n    return this.parser.deserialize(value, options);\n  }\n  /**\n   * Serialize the given value for the structured type.\n   * @param value Value to serialize\n   * @param options Options for serialization\n   * @returns Serialized value\n   */\n\n\n  serialize(value, options) {\n    return this.parser.serialize(value, options);\n  }\n  /**\n   * Encode the given value for the structured type.\n   * @param value Value to encode\n   * @param options Options for encoding\n   * @returns Encoded value\n   */\n\n\n  encode(value, options) {\n    return this.parser.encode(value, options);\n  }\n  /**\n   * Resolve the key of the structured type for the given value.\n   * @param attrs Attributes of the value\n   * @returns Resolved key\n   */\n\n\n  resolveKey(attrs) {\n    return this.parser.resolveKey(attrs);\n  }\n  /**\n   * Returns the defaults values for the structured type.\n   * @returns Default values for the structured type\n   */\n\n\n  defaults() {\n    return this.parser.defaults();\n  }\n  /**\n   * Convert the structured type to json schema\n   * @param options Options for json schema\n   * @returns Json Schema\n   */\n\n\n  toJsonSchema(options = {}) {\n    return this.parser.toJsonSchema(options);\n  }\n  /**\n   * Validate the given value against the structured type.\n   * @param attrs Attributes of the value\n   * @param method Method to use for the process validation\n   * @returns Object with the errors\n   */\n\n\n  validate(attrs, {\n    method,\n    navigation = false\n  } = {}) {\n    return this.parser.validate(attrs, {\n      method,\n      navigation\n    });\n  }\n\n}\n\nclass ODataSchema extends ODataAnnotatable {\n  constructor(config, api) {\n    super(config);\n    this.api = api;\n    this.namespace = config.namespace;\n    this.alias = config.alias;\n    this.enums = (config.enums || []).map(config => new ODataEnumType(config, this));\n    this.entities = (config.entities || []).map(config => new ODataStructuredType(config, this));\n    this.callables = OData.mergeCallableParameters(config.callables || []).map(config => new ODataCallable(config, this));\n    this.containers = (config.containers || []).map(config => new ODataEntityContainer(config, this));\n  }\n\n  isNamespaceOf(type) {\n    return type.startsWith(this.namespace) || this.alias && type.startsWith(this.alias);\n  }\n\n  get entitySets() {\n    return this.containers.reduce((acc, container) => [...acc, ...container.entitySets], []);\n  } //#region Find for Type\n\n\n  findEnumTypeForType(type) {\n    return this.enums.find(e => e.isTypeOf(type));\n  }\n\n  findStructuredTypeForType(type) {\n    return this.entities.find(e => e.isTypeOf(type));\n  }\n\n  findCallableForType(type, bindingType) {\n    const bindingStructuredType = bindingType !== undefined ? this.api.findStructuredTypeForType(bindingType) : undefined;\n    return this.callables.find(c => {\n      var _a;\n\n      const isCallableType = c.isTypeOf(type);\n      const callableBindingType = (_a = c.binding()) === null || _a === void 0 ? void 0 : _a.type;\n      const callableBindingStructuredType = callableBindingType !== undefined ? this.api.findStructuredTypeForType(callableBindingType) : undefined;\n      return isCallableType && (!bindingStructuredType || callableBindingStructuredType && bindingStructuredType.isSubtypeOf(callableBindingStructuredType));\n    });\n  }\n\n  findEntitySetForType(type) {\n    return this.entitySets.find(e => e.isTypeOf(type));\n  } //#endregion\n\n\n  configure({\n    parserForType,\n    findOptionsForType\n  }) {\n    // Configure Enums\n    this.enums.forEach(enu => enu.configure()); // Configure Entities\n\n    this.entities.forEach(config => config.configure({\n      parserForType,\n      findOptionsForType\n    })); // Configure callables\n\n    this.callables.forEach(callable => callable.configure({\n      parserForType\n    }));\n  }\n\n}\n\nclass ODataResource {\n  constructor(api, {\n    segments,\n    query,\n    schema\n  } = {}) {\n    this.api = api;\n    this.pathSegments = segments || new ODataPathSegments();\n    this.queryOptions = query || new ODataQueryOptions();\n    this.schema = schema;\n  }\n  /**\n   * @returns string The type of the resource\n   */\n\n\n  type() {\n    var _a;\n\n    return (_a = this.pathSegments.last()) === null || _a === void 0 ? void 0 : _a.type();\n  }\n  /**\n   * @returns string The type of the return\n   */\n\n\n  returnType() {\n    var _a;\n\n    return (_a = this.pathSegments.last()) === null || _a === void 0 ? void 0 : _a.type();\n  }\n  /**\n   * @returns string All covered types of the resource\n   */\n\n\n  types() {\n    return this.pathSegments.types();\n  }\n  /**\n   * @returns boolean The resource has key ?\n   */\n\n\n  hasKey() {\n    var _a;\n\n    return Boolean((_a = this.pathSegments.last({\n      key: true\n    })) === null || _a === void 0 ? void 0 : _a.hasKey());\n  }\n\n  hasEntityKey() {\n    var _a;\n\n    return Boolean((_a = this.pathSegments.get(PathSegmentNames.entitySet)) === null || _a === void 0 ? void 0 : _a.hasKey());\n  }\n\n  clearKey() {\n    var _a;\n\n    return (_a = this.pathSegments.last({\n      key: true\n    })) === null || _a === void 0 ? void 0 : _a.clearKey();\n  } //#region Models\n\n\n  asModel(entity, {\n    annots,\n    reset\n  } = {}) {\n    let resource = this;\n    const type = (annots === null || annots === void 0 ? void 0 : annots.type) || this.returnType();\n    if (type === undefined) throw Error('');\n    const Model = this.api.modelForType(type);\n    let entitySet = annots === null || annots === void 0 ? void 0 : annots.entitySet;\n\n    if (entitySet !== undefined) {\n      resource = this.api.entitySet(entitySet).entity(entity);\n      resource.query(q => q.apply(this.queryOptions.toQueryArguments()));\n    }\n\n    return new Model(entity, {\n      resource,\n      annots,\n      reset\n    });\n  }\n\n  asCollection(entities, {\n    annots,\n    reset\n  } = {}) {\n    let resource = this;\n    const type = (annots === null || annots === void 0 ? void 0 : annots.type) || this.returnType();\n    if (type === undefined) throw Error('');\n    const Collection = this.api.collectionForType(type);\n    let path = annots === null || annots === void 0 ? void 0 : annots.entitySet;\n\n    if (path !== undefined) {\n      resource = this.api.entitySet(path);\n      resource.query(q => q.apply(this.queryOptions.toQueryArguments()));\n    }\n\n    return new Collection(entities, {\n      resource,\n      annots,\n      reset\n    });\n  } //#endregion\n\n\n  isSubtypeOf(other) {\n    var _a;\n\n    return this.schema !== undefined && other.schema !== undefined && ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.isSubtypeOf(other.schema));\n  }\n\n  isSupertypeOf(other) {\n    var _a;\n\n    return this.schema !== undefined && other.schema !== undefined && ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.isSupertypeOf(other.schema));\n  }\n\n  isEqualTo(other, test) {\n    const [selfPath, selfParams] = this.pathAndParams();\n    const [otherPath, otherParams] = other.pathAndParams();\n    return test === 'path' ? otherPath === selfPath : test === 'params' ? Types.isEqual(selfParams, otherParams) : otherPath === selfPath && Types.isEqual(selfParams, otherParams);\n  }\n\n  pathAndParams(escape = false) {\n    const [spath, sparams] = this.pathSegments.pathAndParams(escape);\n    const [, qparams] = this.queryOptions.pathAndParams(escape);\n    return [spath, Object.assign(Object.assign({}, sparams), qparams)];\n  }\n\n  endpointUrl(params = true) {\n    if (params) {\n      return `${this.api.serviceRootUrl}${this}`;\n    } else {\n      let [path] = this.pathAndParams();\n      return `${this.api.serviceRootUrl}${path}`;\n    }\n  }\n\n  toString() {\n    let [path, params] = this.pathAndParams();\n    let queryString = Object.entries(params).map(e => `${e[0]}${VALUE_SEPARATOR}${e[1]}`).join(PARAM_SEPARATOR);\n    return queryString ? `${path}${QUERY_SEPARATOR}${queryString}` : path;\n  }\n\n  clone() {\n    const Ctor = this.constructor;\n    return new Ctor(this.api, {\n      schema: this.schema,\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n\n  __parser(value, options, type) {\n    const dataType = options !== undefined && Types.isPlainObject(value) ? ODataHelper[options.version || DEFAULT_VERSION].type(value) : undefined;\n\n    if (dataType !== undefined) {\n      // Parser from data type\n      return this.api.parserForType(dataType);\n    } else if (this.schema !== undefined && 'parser' in this.schema) {\n      // Parser from resource schema\n      return this.schema.parser;\n    } else if (type !== undefined) {\n      // Parser from resource type\n      return this.api.parserForType(type);\n    }\n\n    return undefined;\n  }\n\n  deserialize(value, options) {\n    const parserOptions = options || this.api.options.parserOptions;\n    const resourceType = this.returnType();\n\n    const _d = (value, options) => {\n      const parser = this.__parser(value, options, resourceType);\n\n      return parser !== undefined && 'deserialize' in parser ? parser.deserialize(value, options) : value;\n    };\n\n    return Array.isArray(value) ? value.map(v => _d(v, parserOptions)) : _d(value, parserOptions);\n  }\n\n  serialize(value, options) {\n    const parserOptions = options || this.api.options.parserOptions;\n    const resourceType = this.type();\n\n    const _s = (value, options) => {\n      const parser = this.__parser(value, options, resourceType);\n\n      return parser !== undefined && 'serialize' in parser ? parser.serialize(value, options) : value;\n    };\n\n    return Array.isArray(value) ? value.map(v => _s(v, parserOptions)) : _s(value, parserOptions);\n  }\n\n  encode(value, options) {\n    const parserOptions = options || this.api.options.parserOptions;\n    const resourceType = this.type();\n\n    const _e = (value, options) => {\n      const parser = this.__parser(value, options, resourceType);\n\n      return parser !== undefined && 'encode' in parser ? parser.encode(value, options) : value;\n    };\n\n    return Array.isArray(value) ? value.map(v => _e(v, parserOptions)) : _e(value, parserOptions);\n  }\n\n  toJSON() {\n    return {\n      segments: this.pathSegments.toJSON(),\n      options: this.queryOptions.toJSON()\n    };\n  }\n\n  cloneSegments() {\n    return this.pathSegments.clone();\n  } //#region Query Options\n\n\n  clearQuery() {\n    this.queryOptions.clear();\n  }\n\n  cloneQuery() {\n    return this.queryOptions.clone();\n  }\n  /**\n   * Handle the path segments of the resource\n   * Create an object handler for mutate the path segments of the resource\n   * @param f Function context for handle the segments\n   * @returns ODataActionResource\n   */\n\n\n  segment(f) {\n    /*\n    const type = this.type();\n    const schema = type ? this.api.findStructuredTypeForType<T>(type) : undefined;\n    */\n    f(new ODataPathSegmentsHandler(this.pathSegments), this.schema instanceof ODataStructuredType ? this.schema : undefined);\n    return this;\n  }\n  /**\n   * Handle the query options of the resource\n   * Create an object handler for mutate the query options of the resource\n   * @param f Function context for handle the query options\n   */\n\n\n  query(f) {\n    /*\n    const type = this.returnType();\n    const schema = type ? this.api.findStructuredTypeForType<T>(type) : undefined;\n    */\n    f(new ODataQueryOptionsHandler(this.queryOptions), this.schema instanceof ODataStructuredType ? this.schema : undefined);\n    return this;\n  }\n\n  static resolveKey(value, schema) {\n    if (isQueryCustomType(value)) {\n      return value;\n    } else if (Types.isPlainObject(value)) {\n      return schema instanceof ODataStructuredType ? schema.resolveKey(value) : Objects.resolveKey(value);\n    }\n\n    return value;\n  }\n\n  resolveKey(value) {\n    return ODataResource.resolveKey(value, this.schema);\n  } //#endregion\n  // Base Requests\n\n\n  request(method, options) {\n    const apiOptions = this.api.options;\n    let params = options.params || {};\n\n    if (options.withCount) {\n      params = Http.mergeHttpParams(params, apiOptions.helper.countParam());\n    }\n\n    let etag = options.etag;\n\n    if (etag === undefined && Types.isPlainObject(options.body)) {\n      etag = apiOptions.helper.etag(options.body);\n    }\n\n    const request = new ODataRequest({\n      method,\n      etag,\n      body: options.body,\n      api: this.api,\n      resource: this,\n      observe: 'response',\n      headers: options.headers,\n      reportProgress: options.reportProgress,\n      params: params,\n      responseType: options.responseType,\n      fetchPolicy: options.fetchPolicy,\n      withCredentials: options.withCredentials,\n      bodyQueryOptions: options.bodyQueryOptions\n    });\n    const res$ = this.api.request(request);\n\n    switch (options.responseType) {\n      case 'entities':\n        return res$.pipe(map(res => res.entities()));\n\n      case 'entity':\n        return res$.pipe(map(res => res.entity()));\n\n      case 'property':\n        return res$.pipe(map(res => res.property()));\n\n      case 'value':\n        return res$.pipe(map(res => res.value()));\n\n      default:\n        // Other responseTypes (arraybuffer, blob, json, text) return body\n        return res$.pipe(map(res => res.body));\n    }\n  }\n\n  get(options = {}) {\n    return this.request('GET', options);\n  }\n\n  post(body, options = {}) {\n    return this.request('POST', Object.assign({\n      body\n    }, options));\n  }\n\n  put(body, options = {}) {\n    return this.request('PUT', Object.assign({\n      body\n    }, options));\n  }\n\n  patch(body, options = {}) {\n    return this.request('PATCH', Object.assign({\n      body\n    }, options));\n  }\n\n  delete(options = {}) {\n    return this.request('DELETE', options);\n  }\n\n}\n\nclass ODataActionResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    schema,\n    segments,\n    query\n  }) {\n    segments = segments || new ODataPathSegments();\n    path = schema !== undefined ? schema.path() : path;\n    if (path === undefined) throw new Error(`ODataActionResource: path is required`);\n    const segment = segments.add(PathSegmentNames.action, path);\n    if (schema !== undefined) segment.type(schema.type());\n    return new ODataActionResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  static fromResource(resource, path) {\n    var _a;\n\n    const baseType = resource.type();\n    const actionSchema = resource.api.findCallableForType(path, baseType);\n    const bindingType = (_a = actionSchema === null || actionSchema === void 0 ? void 0 : actionSchema.binding()) === null || _a === void 0 ? void 0 : _a.type;\n    const action = ODataActionResource.factory(resource.api, {\n      path,\n      schema: actionSchema,\n      segments: resource.cloneSegments()\n    }); // Switch entitySet to binding type if available\n\n    if (bindingType !== undefined && bindingType !== baseType) {\n      let entitySet = resource.api.findEntitySetForType(bindingType);\n\n      if (entitySet !== undefined) {\n        action.segment(s => s.entitySet().path(entitySet.name));\n      }\n    }\n\n    return action;\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  returnType() {\n    var _a;\n\n    return this.schema instanceof ODataCallable ? (_a = this.schema.parser.return) === null || _a === void 0 ? void 0 : _a.type : undefined;\n  } //#region Requests\n\n\n  post(params, options) {\n    return super.post(params, options);\n  }\n\n  call(params, options = {}) {\n    return this.clone().post(params, options);\n  }\n  /**\n   * Execute the action and return the result as a property\n   * @param params Parameters for the action\n   * @param options Options for the request\n   * @returns Observable of the result of the action\n   */\n\n\n  callProperty(params, options = {}) {\n    return this.call(params, Object.assign({\n      responseType: 'property'\n    }, options)).pipe(map(({\n      property\n    }) => property));\n  }\n  /**\n   * Execute the action and return the result as a entity\n   * @param params Parameters for the action\n   * @param options Options for the request\n   * @returns Observable of the result of the action\n   */\n\n\n  callEntity(params, options = {}) {\n    return this.call(params, Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Execute the action and return the result as a model\n   * @param params Parameters for the action\n   * @param options Options for the request\n   * @returns Observable of the result of the action\n   */\n\n\n  callModel(params, options = {}) {\n    return this.call(params, Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Execute the action and return the result as a entities\n   * @param params Parameters for the action\n   * @param options Options for the request\n   * @returns Observable of the result of the action\n   */\n\n\n  callEntities(params, options = {}) {\n    return this.call(params, Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities\n    }) => entities));\n  }\n  /**\n   * Execute the action and return the result as a collection\n   * @param params Parameters for the action\n   * @param options Options for the request\n   * @returns Observable of the result of the action\n   */\n\n\n  callCollection(params, options = {}) {\n    return this.call(params, Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities,\n      annots\n    }) => entities ? this.asCollection(entities, {\n      annots,\n      reset: true\n    }) : null));\n  }\n\n}\n\nconst Arrays = {\n  // Zip arrays\n  // Example\n  //   Arrays.zip([1, 2, 3, 4, 5, 6], ['a', 'b', 'c', 'd', 'e', 'f'])\n  //   => [[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd'], [5, 'e'], [6, 'f']]\n  zip: (...arrays) => {\n    return arrays[0].map((_, i) => arrays.map(array => array[i]));\n  }\n};\n\nclass ODataBatchRequest extends Subject {\n  constructor(request) {\n    super();\n    this.request = request;\n  }\n\n  toString() {\n    //TODO: Relative or Absolute url ?\n    let res = [`${this.request.method} ${this.request.pathWithParams} ${HTTP11}`];\n\n    if (this.request.method === 'POST' || this.request.method === 'PATCH' || this.request.method === 'PUT') {\n      res.push(`${CONTENT_TYPE}: ${APPLICATION_JSON}`);\n    }\n\n    if (this.request.headers instanceof HttpHeaders) {\n      let headers = this.request.headers;\n      res = [...res, ...headers.keys().map(key => `${key}: ${(headers.getAll(key) || []).join(',')}`)];\n    }\n\n    return res.join(NEWLINE);\n  }\n\n  onLoad(response) {\n    if (response.ok) {\n      this.next(response);\n      this.complete();\n    } else {\n      // An unsuccessful request is delivered on the error channel.\n      this.error(response);\n    }\n  }\n\n  onError(response) {\n    this.error(response);\n  }\n\n}\n/**\n * OData Batch Resource\n * https://www.odata.org/getting-started/advanced-tutorial/#batch\n */\n\n\nclass ODataBatchResource extends ODataResource {\n  constructor() {\n    super(...arguments); // VARIABLES\n\n    this._requests = [];\n    this._responses = null;\n  }\n\n  requests() {\n    return this._requests.map(r => r.request);\n  }\n\n  responses() {\n    return this._responses;\n  } //#region Factory\n\n\n  static factory(api) {\n    let segments = new ODataPathSegments();\n    segments.add(PathSegmentNames.batch, $BATCH);\n    return new ODataBatchResource(api, {\n      segments\n    });\n  }\n\n  clone() {\n    const batch = super.clone();\n    batch._requests = [...this._requests];\n    return batch;\n  } //#endregion\n\n\n  storeRequester() {\n    const current = this.api.requester; // Switch to the batch requester\n\n    this.api.requester = req => {\n      if (req.api !== this.api) throw new Error('Batch Request are for the same api.');\n      if (req.observe === 'events') throw new Error(\"Batch Request does not allows observe == 'events'.\");\n\n      this._requests.push(new ODataBatchRequest(req));\n\n      return this._requests[this._requests.length - 1];\n    };\n\n    return current;\n  }\n\n  restoreRequester(handler) {\n    this.api.requester = handler;\n  }\n  /**\n   * Add to batch request\n   * @param ctx The context for the request\n   * @returns The result of execute the context\n   */\n\n\n  add(ctx) {\n    // Store original requester\n    var handler = this.storeRequester(); // Execute the context\n\n    const obs$ = ctx(this); // Restore original requester\n\n    this.restoreRequester(handler);\n    return obs$;\n  }\n\n  send(options) {\n    if (this._requests.length == 0) {\n      return of(null);\n    }\n\n    const bound = Strings.uniqueId(BATCH_PREFIX);\n    const headers = Http.mergeHttpHeaders(options && options.headers || {}, {\n      [ODATA_VERSION]: VERSION_4_0,\n      [CONTENT_TYPE]: MULTIPART_MIXED_BOUNDARY + bound,\n      [ACCEPT]: MULTIPART_MIXED\n    });\n    const request = new ODataRequest({\n      method: 'POST',\n      body: ODataBatchResource.buildBody(bound, this._requests),\n      api: this.api,\n      resource: this,\n      observe: 'response',\n      responseType: 'text',\n      headers: headers,\n      params: options ? options.params : undefined,\n      withCredentials: options ? options.withCredentials : undefined\n    });\n    return this.api.request(request).pipe(map$1(response => {\n      if (this._responses == null) {\n        this._responses = [];\n      }\n\n      this._responses = [...this._responses, ...ODataBatchResource.parseResponse(this._requests, response)];\n      Arrays.zip(this._requests, this._responses).forEach(tuple => {\n        if (!tuple[0].isStopped) tuple[0].onLoad(tuple[1]);\n      });\n      return response;\n    }));\n  }\n  /**\n   * Execute the batch request\n   * @param ctx The context for the request\n   * @param options The options of the batch request\n   * @returns The result of execute the context\n   */\n\n\n  exec(ctx, options) {\n    let ctx$ = this.add(ctx);\n    let send$ = this.send(options);\n    firstValueFrom(send$);\n    return ctx$; //return this.send(options).pipe(switchMap(() => ctx$));\n  }\n\n  body() {\n    return ODataBatchResource.buildBody(Strings.uniqueId(BATCH_PREFIX), this._requests);\n  }\n\n  static buildBody(batchBoundary, requests) {\n    let res = [];\n    let changesetBoundary = null;\n    let changesetId = 1;\n\n    for (const batch of requests) {\n      // if method is GET and there is a changeset boundary open then close it\n      if (batch.request.method === 'GET' && changesetBoundary !== null) {\n        res.push(`${BOUNDARY_PREFIX_SUFFIX}${changesetBoundary}${BOUNDARY_PREFIX_SUFFIX}`);\n        changesetBoundary = null;\n      } // if there is no changeset boundary open then open a batch boundary\n\n\n      if (changesetBoundary === null) {\n        res.push(`${BOUNDARY_PREFIX_SUFFIX}${batchBoundary}`);\n      } // if method is not GET and there is no changeset boundary open then open a changeset boundary\n\n\n      if (batch.request.method !== 'GET') {\n        if (changesetBoundary === null) {\n          changesetBoundary = Strings.uniqueId(CHANGESET_PREFIX);\n          res.push(`${CONTENT_TYPE}: ${MULTIPART_MIXED_BOUNDARY}${changesetBoundary}`);\n          res.push(NEWLINE);\n        }\n\n        res.push(`${BOUNDARY_PREFIX_SUFFIX}${changesetBoundary}`);\n      }\n\n      res.push(`${CONTENT_TYPE}: ${APPLICATION_HTTP}`);\n      res.push(`${CONTENT_TRANSFER_ENCODING}: ${BINARY}`);\n\n      if (batch.request.method !== 'GET') {\n        res.push(`${CONTENT_ID}: ${changesetId++}`);\n      }\n\n      res.push(NEWLINE);\n      res.push(`${batch}`);\n\n      if (batch.request.method === 'GET' || batch.request.method === 'DELETE') {\n        res.push(NEWLINE);\n      } else {\n        res.push(`${NEWLINE}${JSON.stringify(batch.request.body)}`);\n      }\n    }\n\n    if (res.length) {\n      if (changesetBoundary !== null) {\n        res.push(`${BOUNDARY_PREFIX_SUFFIX}${changesetBoundary}${BOUNDARY_PREFIX_SUFFIX}`);\n        changesetBoundary = null;\n      }\n\n      res.push(`${BOUNDARY_PREFIX_SUFFIX}${batchBoundary}${BOUNDARY_PREFIX_SUFFIX}`);\n    }\n\n    return res.join(NEWLINE);\n  }\n\n  static parseResponse(requests, response) {\n    let chunks = [];\n    const contentType = response.headers.get(CONTENT_TYPE) || '';\n    const batchBoundary = Http.boundaryDelimiter(contentType);\n    const endLine = Http.boundaryEnd(batchBoundary);\n    const lines = (response.body || '').split(NEWLINE_REGEXP);\n    let changesetResponses = null;\n    let contentId = null;\n    let changesetBoundary = null;\n    let changesetEndLine = null;\n    let startIndex = null;\n\n    for (let index = 0; index < lines.length; index++) {\n      const line = lines[index];\n\n      if (line.startsWith(CONTENT_TYPE)) {\n        const contentTypeValue = Http.headerValue(line);\n\n        if (contentTypeValue === MULTIPART_MIXED) {\n          changesetResponses = [];\n          contentId = null;\n          changesetBoundary = Http.boundaryDelimiter(line);\n          changesetEndLine = Http.boundaryEnd(changesetBoundary);\n          startIndex = null;\n        }\n\n        continue;\n      } else if (changesetResponses !== null && line.startsWith(CONTENT_ID)) {\n        contentId = Number(Http.headerValue(line));\n      } else if (line.startsWith(HTTP11)) {\n        startIndex = index;\n      } else if (line === batchBoundary || line === changesetBoundary || line === endLine || line === changesetEndLine) {\n        if (!startIndex) {\n          continue;\n        }\n\n        const chunk = lines.slice(startIndex, index);\n\n        if (changesetResponses !== null && contentId !== null) {\n          changesetResponses[contentId] = chunk;\n        } else {\n          chunks.push(chunk);\n        }\n\n        if (line === batchBoundary || line === changesetBoundary) {\n          startIndex = index + 1;\n        } else if (line === endLine || line === changesetEndLine) {\n          if (changesetResponses !== null) {\n            for (const response of changesetResponses) {\n              if (response) {\n                chunks.push(response);\n              }\n            }\n          }\n\n          changesetResponses = null;\n          changesetBoundary = null;\n          changesetEndLine = null;\n          startIndex = null;\n        }\n      }\n    }\n\n    return chunks.map((chunk, index) => {\n      let request = requests[index].request;\n      let {\n        code,\n        message\n      } = Http.parseResponseStatus(chunk[0]);\n      chunk = chunk.slice(1);\n      let headers = new HttpHeaders();\n      var index = 1;\n\n      for (; index < chunk.length; index++) {\n        const batchBodyLine = chunk[index];\n\n        if (batchBodyLine === '') {\n          break;\n        }\n\n        const batchBodyLineParts = batchBodyLine.split(': ');\n        headers = headers.append(batchBodyLineParts[0].trim(), batchBodyLineParts[1].trim());\n      }\n\n      let body = '';\n\n      for (; index < chunk.length; index++) {\n        body += chunk[index];\n      }\n\n      if (code === 0) {\n        code = !!body ? 200 : 0;\n      }\n\n      let ok = code >= 200 && code < 300;\n\n      if (request.responseType === 'json' && typeof body === 'string') {\n        const originalBody = body;\n        body = body.replace(XSSI_PREFIX, '');\n\n        try {\n          body = body !== '' ? JSON.parse(body) : null;\n        } catch (error) {\n          body = originalBody;\n\n          if (ok) {\n            ok = false;\n            body = {\n              error,\n              text: body\n            };\n          }\n        }\n      }\n\n      return ok ? new HttpResponse({\n        body,\n        headers,\n        status: code,\n        statusText: message,\n        url: request.urlWithParams\n      }) : new HttpErrorResponse({\n        // The error in this case is the response body (error from the server).\n        error: body,\n        headers,\n        status: code,\n        statusText: message,\n        url: request.urlWithParams\n      });\n    });\n  }\n\n}\n\nclass ODataCountResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    segments,\n    query\n  }) {\n    segments.add(PathSegmentNames.count, $COUNT).type('Edm.Int32');\n    query === null || query === void 0 ? void 0 : query.keep(QueryOptionNames.filter, QueryOptionNames.search);\n    return new ODataCountResource(api, {\n      segments,\n      query\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n  //#region Requests\n\n\n  get(options) {\n    return super.get(Object.assign({\n      responseType: 'value'\n    }, options));\n  } //#endregion\n  //#region Shortcuts\n\n  /**\n   * Fetch the count of the set.\n   * @param options Options for the request\n   * @returns The count of the set\n   */\n\n\n  fetch(options) {\n    return this.get(options);\n  }\n\n}\n\nclass ODataFunctionResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    schema,\n    segments,\n    query\n  }) {\n    segments = segments || new ODataPathSegments();\n    path = schema !== undefined ? schema.path() : path;\n    if (path === undefined) throw new Error(`ODataActionResource: path is required`);\n    const segment = segments.add(PathSegmentNames.function, path);\n    if (schema !== undefined) segment.type(schema.type());\n    return new ODataFunctionResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  static fromResource(resource, path) {\n    var _a;\n\n    const baseType = resource.type();\n    const schema = resource.api.findCallableForType(path, baseType);\n    const bindingType = (_a = schema === null || schema === void 0 ? void 0 : schema.binding()) === null || _a === void 0 ? void 0 : _a.type;\n    const func = ODataFunctionResource.factory(resource.api, {\n      path,\n      schema,\n      segments: resource.cloneSegments()\n    }); // Switch entitySet to binding type if available\n\n    if (bindingType !== undefined && bindingType !== baseType) {\n      let entitySet = resource.api.findEntitySetForType(bindingType);\n\n      if (entitySet !== undefined) {\n        func.segment(s => s.entitySet().path(entitySet.name));\n      }\n    }\n\n    return func;\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  returnType() {\n    var _a;\n\n    return this.schema instanceof ODataCallable ? (_a = this.schema.parser.return) === null || _a === void 0 ? void 0 : _a.type : undefined;\n  }\n\n  pathAndParams(escape = false) {\n    let [path, params] = super.pathAndParams(escape);\n\n    if (path.endsWith('()') && this.api.options.nonParenthesisForEmptyParameterFunction) {\n      path = path.substring(0, path.length - 2);\n    }\n\n    return [path, params];\n  }\n\n  parameters(params, {\n    alias\n  } = {}) {\n    let parameters = params !== null ? this.encode(params) : null;\n\n    if (alias && parameters !== null) {\n      this.query(q => {\n        parameters = Object.entries(parameters).reduce((acc, [name, param]) => {\n          return Object.assign(acc, {\n            [name]: q.alias(param, name)\n          });\n        }, {});\n      });\n    }\n\n    return this.clone().segment(s => s.function().parameters(parameters));\n  } //#region Requests\n\n\n  get(options) {\n    return super.get(options);\n  }\n\n  call(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.parameters(params, {\n      alias\n    }).get(options);\n  }\n  /**\n   * Execute the function with the given parameters and return the result as a property\n   * @param params Parameters to be sent to the function\n   * @param alias If true, the parameters will be send using aliases\n   * @param options Options for the request\n   * @returns Observable of the result of the function\n   */\n\n\n  callProperty(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.call(params, Object.assign({\n      responseType: 'property',\n      alias\n    }, options)).pipe(map(({\n      property\n    }) => property));\n  }\n  /**\n   * Execute the function with the given parameters and return the result as a entity\n   * @param params Parameters to be sent to the function\n   * @param alias If true, the parameters will be send using aliases\n   * @param options Options for the request\n   * @returns Observable of the result of the function\n   */\n\n\n  callEntity(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.call(params, Object.assign({\n      responseType: 'entity',\n      alias\n    }, options)).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Execute the function with the given parameters and return the result as a model\n   * @param params Parameters to be sent to the function\n   * @param alias If true, the parameters will be send using aliases\n   * @param options Options for the request\n   * @returns Observable of the result of the function\n   */\n\n\n  callModel(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.call(params, Object.assign({\n      responseType: 'entity',\n      alias\n    }, options)).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Execute the function with the given parameters and return the result as a entities\n   * @param params Parameters to be sent to the function\n   * @param alias If true, the parameters will be send using aliases\n   * @param options Options for the request\n   * @returns Observable of the result of the function\n   */\n\n\n  callEntities(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.call(params, Object.assign({\n      responseType: 'entities',\n      alias\n    }, options)).pipe(map(({\n      entities\n    }) => entities));\n  }\n  /**\n   * Execute the function with the given parameters and return the result as a collection\n   * @param params Parameters to be sent to the function\n   * @param alias If true, the parameters will be send using aliases\n   * @param options Options for the request\n   * @returns Observable of the result of the function\n   */\n\n\n  callCollection(params, _a = {}) {\n    var {\n      alias\n    } = _a,\n        options = __rest(_a, [\"alias\"]);\n\n    return this.call(params, Object.assign({\n      responseType: 'entities',\n      alias\n    }, options)).pipe(map(({\n      entities,\n      annots\n    }) => entities ? this.asCollection(entities, {\n      annots,\n      reset: true\n    }) : null));\n  }\n\n}\n\nclass ODataMediaResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    segments,\n    query\n  }) {\n    segments.add(PathSegmentNames.value, $VALUE);\n    return new ODataMediaResource(api, {\n      segments,\n      query\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n  //#region Requests\n\n\n  get(options) {\n    return super.get(options);\n  }\n\n  put(data, options = {}) {\n    return super.put(data, options);\n  }\n\n  fetch(options) {\n    return this.get(options);\n  }\n\n  fetchArraybuffer(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'arraybuffer'\n    }, options));\n  }\n\n  fetchBlob(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'blob'\n    }, options));\n  }\n\n  upload(data, options = {}) {\n    return this.put(data, options);\n  }\n\n  uploadArrayBuffer(data, contentType, options = {}) {\n    options.headers = Http.mergeHttpHeaders(options.headers || {}, {\n      'Content-Type': contentType\n    });\n    return this.upload(data, options);\n  }\n\n  uploadBlob(data, options = {}) {\n    return this.upload(data, options);\n  }\n\n}\n\nclass ODataValueResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    type,\n    schema,\n    segments,\n    query\n  }) {\n    const baseType = type;\n    const bindingType = schema === null || schema === void 0 ? void 0 : schema.type();\n    const segment = segments.add(PathSegmentNames.value, $VALUE);\n    if (schema !== undefined) segment.type(schema.type());else if (type !== undefined) segment.type(type);\n    query === null || query === void 0 ? void 0 : query.clear();\n    const value = new ODataValueResource(api, {\n      segments,\n      query,\n      schema\n    }); // Switch entitySet to binding type if available\n\n    if (bindingType !== undefined && bindingType !== baseType) {\n      let entitySet = api.findEntitySetForType(bindingType);\n\n      if (entitySet !== undefined) {\n        value.segment(s => s.entitySet().path(entitySet.name));\n      }\n    }\n\n    return value;\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n  //#region Requests\n\n\n  get(options) {\n    return super.get(Object.assign({\n      responseType: 'value'\n    }, options));\n  } //#endregion\n  //#region Shortcuts\n\n  /**\n   * Fetch the value of the resource.\n   * @param options OData options.\n   * @returns Observable of the value.\n   */\n\n\n  fetch(options) {\n    return this.get(options);\n  }\n\n}\n\nclass ODataPropertyResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    type,\n    schema,\n    segments,\n    query\n  }) {\n    const segment = segments.add(PathSegmentNames.property, path);\n    if (schema !== undefined) segment.type(schema.type());else if (type !== undefined) segment.type(type);\n    query === null || query === void 0 ? void 0 : query.clear();\n    return new ODataPropertyResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  static fromResource(resource, path) {\n    const baseType = resource.type();\n    let baseSchema = resource.schema;\n    let fieldType;\n    let fieldSchema;\n\n    if (baseSchema !== undefined) {\n      const field = baseSchema.findFieldByName(path);\n      fieldType = field === null || field === void 0 ? void 0 : field.type;\n      fieldSchema = fieldType !== undefined ? resource.api.findStructuredTypeForType(fieldType) : undefined;\n      baseSchema = field !== undefined ? baseSchema.findSchemaForField(field) : undefined;\n    }\n\n    const property = ODataPropertyResource.factory(resource.api, {\n      path,\n      type: fieldType,\n      schema: fieldSchema,\n      segments: resource.cloneSegments(),\n      query: resource.cloneQuery()\n    }); // Switch entitySet to binding type if available\n\n    if (baseSchema !== undefined && baseSchema.type() !== baseType) {\n      let entitySet = resource.api.findEntitySetForType(baseSchema.type());\n\n      if (entitySet !== undefined) {\n        property.segment(s => s.entitySet().path(entitySet.name));\n      }\n    }\n\n    return property;\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  key(value) {\n    const property = this.clone();\n    var key = this.resolveKey(value);\n    if (key !== undefined) property.segment(s => s.property().key(key));\n    return property;\n  }\n\n  keys(values) {\n    const property = this.clone();\n    const types = this.pathSegments.types({\n      key: true\n    });\n    const keys = values.map((value, index) => ODataResource.resolveKey(value, this.api.findStructuredTypeForType(types[index])));\n    property.segment(s => s.keys(keys));\n    return property;\n  }\n\n  value() {\n    return ODataValueResource.factory(this.api, {\n      type: this.returnType(),\n      schema: this.schema,\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n  /*\n  navigationProperty<N>(path: string) {\n    let schema: ODataStructuredType<N> | undefined;\n    if (this.schema instanceof ODataStructuredType) {\n      const field = this.schema.findFieldByName<any>(path as keyof T);\n      schema =\n        field !== undefined\n          ? this.schema.findSchemaForField<N>(field)\n          : undefined;\n    }\n    return ODataNavigationPropertyResource.factory<N>(this.api, {\n      path,\n      schema,\n      segments: this.cloneSegments(),\n      query: this.cloneQuery<N>(),\n    });\n  }\n  */\n\n\n  property(path) {\n    let type;\n    let schema;\n\n    if (this.schema instanceof ODataStructuredType) {\n      const field = this.schema.findFieldByName(path);\n      type = field === null || field === void 0 ? void 0 : field.type;\n      schema = field !== undefined ? this.schema.findSchemaForField(field) : undefined;\n    }\n\n    return ODataPropertyResource.factory(this.api, {\n      path,\n      type,\n      schema,\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  } //#region Requests\n\n\n  get(options) {\n    return super.get(options);\n  }\n\n  fetch(options = {}) {\n    return this.get(options);\n  }\n  /**\n   * Fetch the property value\n   * @param options Options for the request\n   * @returns The property value\n   */\n\n\n  fetchProperty(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'property'\n    }, options)).pipe(map(({\n      property\n    }) => property));\n  }\n  /**\n   * Fetch the entity\n   * @param options Options for the request\n   * @returns The entity\n   */\n\n\n  fetchEntity(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Fetch the entity and return as model\n   * @param options Options for the request\n   * @returns The model\n   */\n\n\n  fetchModel(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Fetch the entities\n   * @param options Options for the request\n   * @returns The entities\n   */\n\n\n  fetchEntities(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities\n    }) => entities));\n  }\n  /**\n   * Fetch the entities and return as collection\n   * @param options Options for the request\n   * @returns The collection\n   */\n\n\n  fetchCollection(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities,\n      annots\n    }) => entities ? this.asCollection(entities, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Fetch all entities\n   * @param options Options for the request\n   * @returns All entities\n   */\n\n\n  fetchAll(options = {}) {\n    let res = this.clone(); // Clean Paging\n\n    res.query(q => q.clearPaging());\n\n    let fetch = opts => {\n      if (opts) {\n        res.query(q => q.paging(opts));\n      }\n\n      return res.fetch(Object.assign({\n        responseType: 'entities'\n      }, options));\n    };\n\n    return fetch().pipe(expand(({\n      annots: meta\n    }) => meta.skip || meta.skiptoken ? fetch(meta) : EMPTY), concatMap(({\n      entities\n    }) => entities || []), toArray());\n  }\n\n}\n\nclass ODataReferenceResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    segments,\n    query\n  }) {\n    segments.add(PathSegmentNames.reference, $REF);\n    query === null || query === void 0 ? void 0 : query.clear();\n    return new ODataReferenceResource(api, {\n      segments,\n      query\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n  //#region Requests\n\n\n  post(target, options) {\n    return super.post({\n      [ODATA_ID]: target.endpointUrl(false)\n    }, options);\n  }\n\n  put(target, options) {\n    return super.put({\n      [ODATA_ID]: target.endpointUrl(false)\n    }, options);\n  }\n\n  delete(_a = {}) {\n    var {\n      etag,\n      target\n    } = _a,\n        options = __rest(_a, [\"etag\", \"target\"]);\n\n    if (target) {\n      options.params = {\n        [$ID]: target.endpointUrl(false)\n      };\n    }\n\n    return super.delete(Object.assign({\n      etag\n    }, options));\n  } //#endregion\n  //#region Shortcuts for collections\n\n  /**\n   * Add the given target to the collection.\n   * @param target The target resource\n   * @param options Options for the request\n   * @returns Observable of the response\n   */\n\n\n  add(target, options) {\n    return this.post(target, options);\n  }\n  /**\n   * Remove the given target from the collection.\n   * @param target The target resource\n   * @param options Options for the request\n   * @returns Observable of the response\n   */\n\n\n  remove(target, options) {\n    return this.delete(Object.assign({\n      target\n    }, options));\n  } //#region\n  //#region Shortcuts for single\n\n  /**\n   * Set the reference to the given target.\n   * @param target The target resource\n   * @param options Options for the request\n   * @returns Observable of the response\n   */\n\n\n  set(target, options) {\n    return this.put(target, options);\n  }\n  /**\n   * Unset the reference to the given target.\n   * @param options Options for the request.\n   * @returns Observable of the response\n   */\n\n\n  unset(options) {\n    return this.delete(options);\n  }\n\n  fetch(options = {}) {\n    return this.get(options);\n  }\n  /**\n   * Fetch the entity\n   * @param options Options for the request\n   * @returns The entity\n   */\n\n\n  fetchEntity(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Fetch entities\n   * @param options Options for the request\n   * @returns The entities\n   */\n\n\n  fetchEntities(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities\n    }) => entities));\n  }\n\n}\n/**\n * OData Navigation Property Resource\n * https://www.odata.org/getting-started/advanced-tutorial/#containment\n * https://www.odata.org/getting-started/advanced-tutorial/#derived\n */\n\n\nclass ODataNavigationPropertyResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    type,\n    schema,\n    segments,\n    query\n  }) {\n    const segment = segments.add(PathSegmentNames.navigationProperty, path);\n    if (schema !== undefined) segment.type(schema.type());else if (type !== undefined) segment.type(type);\n    query === null || query === void 0 ? void 0 : query.keep(QueryOptionNames.format);\n    return new ODataNavigationPropertyResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  static fromResource(resource, path) {\n    const baseType = resource.type();\n    let baseSchema = resource.schema;\n    let fieldType;\n    let fieldSchema;\n\n    if (baseSchema !== undefined) {\n      const field = baseSchema.findFieldByName(path);\n      fieldType = field === null || field === void 0 ? void 0 : field.type;\n      fieldSchema = fieldType !== undefined ? resource.api.findStructuredTypeForType(fieldType) : undefined;\n      baseSchema = field !== undefined ? baseSchema.findSchemaForField(field) : undefined;\n    }\n\n    const navigation = ODataNavigationPropertyResource.factory(resource.api, {\n      path,\n      type: fieldType,\n      schema: fieldSchema,\n      segments: resource.cloneSegments(),\n      query: resource.cloneQuery()\n    }); // Switch entitySet to binding type if available\n\n    if (baseSchema !== undefined && baseSchema.type() !== baseType) {\n      let entitySet = resource.api.findEntitySetForType(baseSchema.type());\n\n      if (entitySet !== undefined) {\n        navigation.segment(s => s.entitySet().path(entitySet.name));\n      }\n    }\n\n    return navigation;\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  key(value) {\n    const navigation = this.clone();\n    var key = this.resolveKey(value);\n    if (key !== undefined) navigation.segment(s => s.navigationProperty().key(key));\n    return navigation;\n  }\n\n  keys(values) {\n    const navigation = this.clone();\n    const types = this.pathSegments.types({\n      key: true\n    });\n    const keys = values.map((value, index) => ODataResource.resolveKey(value, this.api.findStructuredTypeForType(types[index])));\n    navigation.segment(s => s.keys(keys));\n    return navigation;\n  }\n\n  media() {\n    return ODataMediaResource.factory(this.api, {\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n\n  reference() {\n    return ODataReferenceResource.factory(this.api, {\n      segments: this.cloneSegments()\n    });\n  }\n\n  navigationProperty(path) {\n    return ODataNavigationPropertyResource.fromResource(this, path);\n  }\n\n  property(path) {\n    return ODataPropertyResource.fromResource(this, path);\n  }\n\n  count() {\n    return ODataCountResource.factory(this.api, {\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n\n  cast(type) {\n    const baseSchema = this.schema;\n    const castSchema = this.api.findStructuredTypeForType(type);\n    if (castSchema !== undefined && baseSchema !== undefined && !castSchema.isSubtypeOf(baseSchema)) throw new Error(`Cannot cast to ${type}`);\n    const segments = this.cloneSegments();\n    segments.add(PathSegmentNames.type, type).type(type);\n    return new ODataNavigationPropertyResource(this.api, {\n      segments,\n      schema: castSchema,\n      query: this.cloneQuery()\n    });\n  } //#region Requests\n\n\n  post(attrs, options = {}) {\n    return super.post(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  put(attrs, options = {}) {\n    return super.put(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  patch(attrs, options = {}) {\n    return super.patch(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  delete(options = {}) {\n    return super.delete(Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  get(options = {}) {\n    return super.get(options);\n  } //#endregion\n  //#region Shortcuts\n\n  /**\n   * Create a new entity\n   * @param attrs The entity attributes\n   * @param options Options for the request\n   * @returns The created entity with the annotations\n   */\n\n\n  create(attrs, options) {\n    return this.post(attrs, options);\n  }\n  /**\n   * Update an existing entity\n   * @param attrs The entity attributes\n   * @param options Options for the request\n   * @param etag The etag of the entity\n   * @returns The updated entity with the annotations\n   */\n\n\n  update(attrs, options) {\n    return this.put(attrs, options);\n  }\n  /**\n   * Modify an existing entity\n   * @param attrs The entity attributes\n   * @param options Options for the request\n   * @param etag The etag of the entity\n   * @returns The modified entity with the annotations\n   */\n\n\n  modify(attrs, options) {\n    return this.patch(attrs, options);\n  }\n  /**\n   * Delete an existing entity\n   * @param options Options for the request\n   * @param etag The etag of the entity\n   * @returns An observable of the destroy\n   */\n\n\n  destroy(options) {\n    return this.delete(options);\n  }\n\n  fetch(options = {}) {\n    if (!this.hasEntityKey()) return throwError(() => new Error('fetch: Navigation resource without entity key'));\n    return this.get(options);\n  }\n  /**\n   * Fetch the entity\n   * @param options Options for the request\n   * @returns The entity\n   */\n\n\n  fetchEntity(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Fetch the entity and return as model\n   * @param options Options for the request\n   * @returns The model\n   */\n\n\n  fetchModel(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entity'\n    }, options)).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Fetch entities\n   * @param options Options for the request\n   * @returns The entities\n   */\n\n\n  fetchEntities(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities\n    }) => entities));\n  }\n  /**\n   * Fetch entities and return as collection\n   * @param options Options for the request\n   * @returns The collection\n   */\n\n\n  fetchCollection(options = {}) {\n    return this.fetch(Object.assign({\n      responseType: 'entities'\n    }, options)).pipe(map(({\n      entities,\n      annots\n    }) => entities ? this.asCollection(entities, {\n      annots,\n      reset: true\n    }) : null));\n  }\n  /**\n   * Fetch all entities\n   * @param options Options for the request\n   * @returns All entities\n   */\n\n\n  fetchAll(options = {}) {\n    let res = this.clone(); // Clean Paging\n\n    res.query(q => q.clearPaging());\n\n    let fetch = opts => {\n      if (opts) {\n        res.query(q => q.paging(opts));\n      }\n\n      return res.fetch(Object.assign({\n        responseType: 'entities'\n      }, options));\n    };\n\n    return fetch().pipe(expand(({\n      annots: meta\n    }) => meta.skip || meta.skiptoken ? fetch(meta) : EMPTY), concatMap(({\n      entities\n    }) => entities || []), toArray());\n  }\n\n}\n\nclass ODataEntityResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    schema,\n    segments,\n    query\n  }) {\n    query === null || query === void 0 ? void 0 : query.keep(QueryOptionNames.expand, QueryOptionNames.select, QueryOptionNames.format);\n    return new ODataEntityResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  key(value) {\n    const entity = this.clone();\n    var key = this.resolveKey(value);\n    if (key !== undefined) entity.segment(s => s.entitySet().key(key));\n    return entity;\n  }\n\n  keys(values) {\n    const entity = this.clone();\n    const types = this.pathSegments.types({\n      key: true\n    });\n    const keys = values.map((value, index) => ODataResource.resolveKey(value, this.api.findStructuredTypeForType(types[index])));\n    entity.segment(s => s.keys(keys));\n    return entity;\n  }\n\n  media() {\n    return ODataMediaResource.factory(this.api, {\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n\n  navigationProperty(path) {\n    return ODataNavigationPropertyResource.fromResource(this, path);\n  }\n\n  property(path) {\n    return ODataPropertyResource.fromResource(this, path);\n  }\n\n  action(path) {\n    return ODataActionResource.fromResource(this, path);\n  }\n\n  function(path) {\n    return ODataFunctionResource.fromResource(this, path);\n  }\n\n  cast(type) {\n    const baseSchema = this.schema;\n    const castSchema = this.api.findStructuredTypeForType(type);\n    if (castSchema !== undefined && baseSchema !== undefined && !castSchema.isSubtypeOf(baseSchema)) throw new Error(`cast: Cannot cast to ${type}`);\n    const segments = this.cloneSegments();\n    segments.add(PathSegmentNames.type, type).type(type);\n    return new ODataEntityResource(this.api, {\n      segments,\n      schema: castSchema,\n      query: this.cloneQuery()\n    });\n  } //#region Requests\n\n\n  post(attrs, options = {}) {\n    return super.post(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  put(attrs, options = {}) {\n    return super.put(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  patch(attrs, options = {}) {\n    return super.patch(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  delete(options = {}) {\n    return super.delete(Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  get(options = {}) {\n    return super.get(Object.assign({\n      responseType: 'entity'\n    }, options));\n  } //#endregion\n  //#region Shortcuts\n\n\n  create(attrs, options) {\n    return this.post(attrs, options);\n  }\n\n  update(attrs, options) {\n    return this.put(attrs, options);\n  }\n\n  modify(attrs, options) {\n    return this.patch(attrs, options);\n  }\n\n  destroy(options) {\n    return this.delete(options);\n  }\n\n  fetch(options) {\n    if (!this.hasKey()) return throwError(() => new Error('fetch: Entity resource without key'));\n    return this.get(options);\n  }\n\n  fetchEntity(options) {\n    return this.fetch(options).pipe(map(({\n      entity\n    }) => entity));\n  }\n\n  fetchModel(options) {\n    return this.fetch(options).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n\n}\n\nclass ODataEntitySetResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    schema,\n    query\n  }) {\n    const segments = new ODataPathSegments();\n    const segment = segments.add(PathSegmentNames.entitySet, path);\n    if (schema !== undefined) segment.type(schema.type());\n    return new ODataEntitySetResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  entity(key) {\n    const entity = ODataEntityResource.factory(this.api, {\n      schema: this.schema,\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n\n    if (key !== undefined) {\n      return entity.key(key);\n    }\n\n    return entity;\n  }\n\n  action(path) {\n    return ODataActionResource.fromResource(this, path);\n  }\n\n  function(path) {\n    return ODataFunctionResource.fromResource(this, path);\n  }\n\n  count() {\n    return ODataCountResource.factory(this.api, {\n      segments: this.cloneSegments(),\n      query: this.cloneQuery()\n    });\n  }\n\n  cast(type) {\n    const baseSchema = this.schema;\n    const castSchema = this.api.findStructuredTypeForType(type);\n    if (castSchema !== undefined && baseSchema !== undefined && !castSchema.isSubtypeOf(baseSchema)) throw new Error(`Cannot cast to ${type}`);\n    const segments = this.cloneSegments();\n    segments.add(PathSegmentNames.type, type).type(type);\n    return new ODataEntitySetResource(this.api, {\n      segments,\n      schema: castSchema,\n      query: this.cloneQuery()\n    });\n  } //#region Requests\n\n\n  post(attrs, options = {}) {\n    return super.post(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  get(options = {}) {\n    return super.get(Object.assign({\n      responseType: 'entities'\n    }, options));\n  } //#endregion\n  //#region Shortcuts\n\n\n  create(attrs, options) {\n    return this.post(attrs, options);\n  }\n\n  fetch(options) {\n    return this.get(options);\n  }\n\n  fetchEntities(options) {\n    return this.fetch(options).pipe(map(({\n      entities\n    }) => entities));\n  }\n\n  fetchCollection(options) {\n    return this.fetch(options).pipe(map(({\n      entities,\n      annots\n    }) => entities ? this.asCollection(entities, {\n      annots,\n      reset: true\n    }) : null));\n  }\n\n  fetchAll(options) {\n    let res = this.clone(); // Clean Paging\n\n    res.query(q => q.clearPaging());\n\n    let fetch = opts => {\n      if (opts) {\n        res.query(q => q.paging(opts));\n      }\n\n      return res.fetch(options);\n    };\n\n    return fetch().pipe(expand(({\n      annots: meta\n    }) => meta.skip || meta.skiptoken ? fetch(meta) : EMPTY), concatMap(({\n      entities\n    }) => entities || []), toArray());\n  }\n\n}\n\nclass ODataAnnotations {\n  constructor(helper, annotations = new Map(), context) {\n    this.helper = helper;\n    this.annotations = annotations;\n    this.context = context;\n  }\n\n  attributes(data, metadata) {\n    return this.helper.attributes(data, metadata);\n  }\n\n  get entitySet() {\n    var _a;\n\n    return (_a = this.context) === null || _a === void 0 ? void 0 : _a.entitySet;\n  }\n\n  get type() {\n    var _a;\n\n    return this.helper.type(this.annotations) || ((_a = this.context) === null || _a === void 0 ? void 0 : _a.type);\n  }\n\n}\n\nclass ODataPropertyAnnotations extends ODataAnnotations {\n  clone() {\n    return new ODataPropertyAnnotations(this.helper, new Map(this.annotations), this.context);\n  }\n\n  data(data) {\n    return this.helper.property(data);\n  }\n\n}\n\nclass ODataEntityAnnotations extends ODataAnnotations {\n  clone() {\n    return new ODataEntityAnnotations(this.helper, new Map(this.annotations), this.context);\n  }\n\n  data(data) {\n    return this.helper.entity(data);\n  }\n\n  get id() {\n    return this.helper.id(this.annotations);\n  }\n\n  get etag() {\n    return this.helper.etag(this.annotations);\n  }\n\n  get mediaEtag() {\n    return this.helper.mediaEtag(this.annotations);\n  }\n\n  get metadataEtag() {\n    return this.helper.metadataEtag(this.annotations);\n  }\n\n  get readLink() {\n    return this.helper.readLink(this.annotations);\n  }\n\n  get editLink() {\n    return this.helper.editLink(this.annotations);\n  }\n\n  get mediaReadLink() {\n    return this.helper.mediaReadLink(this.annotations);\n  }\n\n  get mediaEditLink() {\n    return this.helper.mediaEditLink(this.annotations);\n  }\n\n  get mediaContentType() {\n    return this.helper.mediaContentType(this.annotations);\n  }\n\n  get properties() {\n    if (this._properties === undefined) {\n      this._properties = this.helper.properties(this.annotations);\n    }\n\n    return this._properties;\n  }\n\n  property(name) {\n    return this.properties.get(name);\n  }\n\n  get functions() {\n    if (this._functions === undefined) {\n      this._functions = this.helper.functions(this.annotations);\n    }\n\n    return this._functions;\n  }\n\n  function(name) {\n    return this.functions[name];\n  }\n\n}\n\nclass ODataEntitiesAnnotations extends ODataAnnotations {\n  clone() {\n    return new ODataEntitiesAnnotations(this.helper, new Map(this.annotations), this.context);\n  }\n\n  data(data) {\n    return this.helper.entities(data);\n  }\n\n  get readLink() {\n    return this.helper.readLink(this.annotations);\n  }\n\n  get count() {\n    return this.helper.count(this.annotations);\n  }\n\n  get nextLink() {\n    return this.helper.nextLink(this.annotations);\n  }\n\n  get deltaLink() {\n    return this.helper.deltaLink(this.annotations);\n  }\n\n  get top() {\n    let match = (this.nextLink || '').match(/[&?]{1}\\$top=(\\d+)/);\n    return match !== null ? Number(match[1]) : undefined;\n  }\n\n  get skip() {\n    let match = (this.nextLink || '').match(/[&?]{1}\\$skip=(\\d+)/);\n    return match !== null ? Number(match[1]) : undefined;\n  }\n\n  get skiptoken() {\n    let match = (this.nextLink || '').match(/[&?]{1}\\$skiptoken=([\\d\\w\\s']+)/);\n    return match !== null ? match[1] : undefined;\n  }\n\n  get functions() {\n    if (this._functions === undefined) {\n      this._functions = this.helper.functions(this.annotations);\n    }\n\n    return this._functions;\n  }\n\n  function(name) {\n    return this.functions[name];\n  }\n\n}\n\nclass ODataResponseOptions {\n  constructor(config) {\n    this.version = config.version || DEFAULT_VERSION;\n  }\n\n  get helper() {\n    return ODataHelper[this.version];\n  }\n\n  clone() {\n    return new ODataResponseOptions(this);\n  }\n\n  setFeatures(features) {\n    features.split(';').forEach(o => {\n      let [k, v] = o.split('=');\n\n      switch (k.trim()) {\n        case 'odata.metadata':\n          this.metadata = v;\n          break;\n\n        case 'odata.streaming':\n          this.streaming = v == 'true';\n          break;\n\n        case 'IEEE754Compatible':\n          this.ieee754Compatible = v == 'true';\n          break;\n      }\n    });\n  }\n\n  setVersion(version) {\n    const value = version.replace(/\\;/g, '').trim();\n    if ([VERSION_2_0, VERSION_3_0, VERSION_4_0].indexOf(value) !== -1) this.version = value;\n  }\n\n  setLocation(location) {\n    // TODO: resolve location?\n    this.location = location;\n  }\n\n  setCache(cacheControl) {\n    cacheControl.split(',').forEach(directive => {\n      if (directive.startsWith(MAX_AGE)) {\n        let maxAge = Number(directive.split('=')[1]);\n        if (!Number.isNaN(maxAge)) this.maxAge = maxAge;\n      }\n\n      if (['public', 'private', 'no-cache', 'no-store'].indexOf(directive) !== -1) {\n        this.cacheability = directive;\n      }\n    });\n  }\n\n}\n/**\n * OData Response\n */\n\n\nclass ODataResponse extends HttpResponse {\n  constructor(init) {\n    super(init);\n    this.api = init.api;\n    this.resource = init.resource;\n  }\n\n  static fromHttpResponse(req, res) {\n    return new ODataResponse({\n      api: req.api,\n      resource: req.resource,\n      body: res.body,\n      headers: res.headers,\n      status: res.status,\n      statusText: res.statusText,\n      url: res.url || undefined\n    });\n  }\n\n  static fromJSON(req, json) {\n    return new ODataResponse({\n      api: req.api,\n      resource: req.resource,\n      body: json.body,\n      headers: new HttpHeaders(json.headers),\n      status: json.status,\n      statusText: json.statusText,\n      url: json.url || undefined\n    });\n  }\n\n  toJSON() {\n    return {\n      body: this.body,\n      headers: this.headers.keys().map(name => ({\n        [name]: this.headers.getAll(name) || []\n      })).reduce((acc, header) => Object.assign(acc, header), {}),\n      status: this.status,\n      statusText: this.statusText,\n      url: this.url\n    };\n  }\n\n  get options() {\n    if (this._options === undefined) {\n      this._options = new ODataResponseOptions(this.api.options.parserOptions);\n      const contentType = this.headers.get(CONTENT_TYPE);\n\n      if (contentType && contentType.indexOf(APPLICATION_JSON) !== -1) {\n        const features = contentType.split(',').find(p => p.startsWith(APPLICATION_JSON));\n\n        this._options.setFeatures(features);\n      }\n\n      const header = Http.resolveHeaderKey(this.headers, ODATA_VERSION_HEADERS);\n\n      if (header) {\n        const version = (this.headers.get(header) || '').replace(/\\;/g, '');\n\n        this._options.setVersion(version);\n      }\n\n      const location = this.headers.get(LOCATION_HEADER);\n\n      if (location) {\n        this._options.setLocation(location);\n      }\n\n      const cacheControl = this.headers.get(CACHE_CONTROL);\n\n      if (cacheControl) {\n        this._options.setCache(cacheControl);\n      }\n    }\n\n    return this._options;\n  }\n\n  get payload() {\n    if (this._payload === undefined) {\n      this._payload = this.body && this.options.version === '2.0' ? this.body['d'] : this.body;\n    }\n\n    return this._payload;\n  }\n\n  get context() {\n    if (this._context === undefined) {\n      this._context = this.options.helper.context(Types.isPlainObject(this.payload) ? this.payload : {});\n    }\n\n    return this._context;\n  }\n\n  get annotations() {\n    if (this._annotations === undefined) {\n      const options = this.options;\n      this._annotations = options.helper.annotations(this.payload || {});\n      let key = Http.resolveHeaderKey(this.headers, ETAG_HEADERS);\n\n      if (key) {\n        const etag = this.headers.get(key);\n        if (etag) this._annotations.set(options.helper.ODATA_ETAG, etag);\n      }\n\n      key = Http.resolveHeaderKey(this.headers, ODATA_ENTITYID_HEADERS);\n\n      if (key) {\n        const entityId = this.headers.get(key);\n        if (entityId) this._annotations.set(options.helper.ODATA_ID, entityId);\n      }\n    }\n\n    return this._annotations;\n  }\n  /**\n   * Handle the response body as an entity\n   * @returns\n   */\n\n\n  entity() {\n    const options = this.options;\n    const payload = this.payload;\n    const annots = new ODataEntityAnnotations(options.helper, this.annotations, this.context);\n    const data = payload ? annots.data(payload) : null;\n    let entity = data !== null && Types.isPlainObject(data) ? options.helper.attributes(data, this.api.options.stripMetadata) : data;\n    if (entity !== null) entity = this.resource.deserialize(entity, options);\n    return {\n      entity,\n      annots\n    };\n  }\n  /**\n   * Handle the response body as entities\n   * @returns\n   */\n\n\n  entities() {\n    const options = this.options;\n    const payload = this.payload;\n    const annots = new ODataEntitiesAnnotations(options.helper, this.annotations, this.context);\n    let entities = payload ? annots.data(payload) : null;\n    if (entities !== null) entities = this.resource.deserialize(entities, options);\n    return {\n      entities,\n      annots\n    };\n  }\n  /**\n   * Handle the response body as a property\n   * @returns\n   */\n\n\n  property() {\n    const options = this.options;\n    const payload = this.payload;\n    const annots = new ODataPropertyAnnotations(options.helper, this.annotations, this.context);\n    const data = payload ? annots.data(payload) : null;\n    let property = data !== null && Types.isPlainObject(data) ? options.helper.attributes(data, this.api.options.stripMetadata) : data;\n    if (property !== null) property = this.resource.deserialize(property, options);\n    return {\n      property,\n      annots\n    };\n  }\n  /**\n   * Handle the response body as a value\n   * @returns\n   */\n\n\n  value() {\n    const options = this.options;\n    const payload = this.payload;\n    let value = payload !== null && Types.isPlainObject(payload) ? options.helper.attributes(payload, this.api.options.stripMetadata) : payload;\n    if (value !== null) value = this.resource.deserialize(value, options);\n    return value;\n  }\n\n}\n\nclass CsdlFunction {\n  constructor(name, returnType, isBound, entitySetPath, isComposable, parameters) {\n    this.name = name;\n    this.returnType = returnType;\n    this.isBound = isBound;\n    this.entitySetPath = entitySetPath;\n    this.isComposable = isComposable;\n    this.parameters = parameters;\n  }\n\n}\n\nclass CsdlAction {\n  constructor(name, returnType, isBound, entitySetPath, parameters) {\n    this.name = name;\n    this.returnType = returnType;\n    this.isBound = isBound;\n    this.entitySetPath = entitySetPath;\n    this.parameters = parameters;\n  }\n\n}\n\nclass CsdlFunctionImport {\n  constructor(name, functionName, entitySet, IncludeInServiceDocument) {\n    this.name = name;\n    this.functionName = functionName;\n    this.entitySet = entitySet;\n    this.IncludeInServiceDocument = IncludeInServiceDocument;\n  }\n\n}\n\nclass CsdlActionImport {\n  constructor(name, action, entitySet) {\n    this.name = name;\n    this.action = action;\n    this.entitySet = entitySet;\n  }\n\n}\n\nclass CsdlParameter {\n  constructor(name, type, nullable, maxLength, precision, scale, srid) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.maxLength = maxLength;\n    this.precision = precision;\n    this.scale = scale;\n    this.srid = srid;\n  }\n\n}\n\nclass CsdlReturnType {\n  constructor(type, nullable, maxLength, precision, scale, srid) {\n    this.type = type;\n    this.nullable = nullable;\n    this.maxLength = maxLength;\n    this.precision = precision;\n    this.scale = scale;\n    this.srid = srid;\n  }\n\n}\n\nclass CsdlAnnotable {\n  constructor(annotationList) {\n    this.annotationList = annotationList;\n  }\n\n}\n\nclass CsdlAnnotations extends CsdlAnnotable {\n  constructor(target, annotationList, qualifier) {\n    super(annotationList);\n    this.target = target;\n    this.qualifier = qualifier;\n  }\n\n}\n\nclass CsdlAnnotation {\n  constructor(term, qualifier) {\n    this.term = term;\n    this.qualifier = qualifier;\n  }\n\n}\n\nclass CsdlTerm {\n  constructor(name, type, baseTerm, defaultValue, appliesTo, nullable, maxLength, precision, scale, srid) {\n    this.name = name;\n    this.type = type;\n    this.baseTerm = baseTerm;\n    this.defaultValue = defaultValue;\n    this.appliesTo = appliesTo;\n    this.nullable = nullable;\n    this.maxLength = maxLength;\n    this.precision = precision;\n    this.scale = scale;\n    this.srid = srid;\n  }\n\n}\n\nclass CsdlStructuredType {\n  constructor(name, properties, navigationProperties, baseType, openType, abstract) {\n    this.name = name;\n    this.properties = properties;\n    this.navigationProperties = navigationProperties;\n    this.baseType = baseType;\n    this.openType = openType;\n    this.abstract = abstract;\n  }\n\n}\n\nclass CsdlComplexType extends CsdlStructuredType {\n  constructor(name, properties, navigationProperties, baseType, openType, abstract) {\n    super(name, properties, navigationProperties, baseType, openType, abstract);\n  }\n\n}\n\nclass CsdlEntityType extends CsdlStructuredType {\n  constructor(name, key, properties, navigationProperties, baseType, openType, abstract, hasStream) {\n    super(name, properties, navigationProperties, baseType, openType, abstract);\n    this.key = key;\n    this.hasStream = hasStream;\n  }\n\n}\n\nclass CsdlKey {\n  constructor(propertyRefs) {\n    this.propertyRefs = propertyRefs;\n  }\n\n}\n\nclass CsdlPropertyRef {\n  constructor(name, alias) {\n    this.name = name;\n    this.alias = alias;\n  }\n\n}\n\nclass CsdlEnumType {\n  constructor(name, members, underlyingType, isFlags) {\n    this.name = name;\n    this.members = members;\n    this.underlyingType = underlyingType;\n    this.isFlags = isFlags;\n  }\n\n}\n\nclass CsdlEnumMember {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n  }\n\n}\n\nclass CsdlReference extends CsdlAnnotable {\n  constructor(uri, includes, includeAnnotations, annotationList) {\n    super(annotationList);\n    this.uri = uri;\n    this.includes = includes;\n    this.includeAnnotations = includeAnnotations;\n  }\n\n}\n\nclass CsdlInclude {\n  constructor(namespace, alias) {\n    this.namespace = namespace;\n    this.alias = alias;\n  }\n\n}\n\nclass CsdlIncludeAnnotations {\n  constructor(termNamespace, qualifier, targetNamespace) {\n    this.termNamespace = termNamespace;\n    this.qualifier = qualifier;\n    this.targetNamespace = targetNamespace;\n  }\n\n}\n\nclass CsdlStructuralProperty {\n  constructor(name, type, nullable) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n  }\n\n}\n\nclass CsdlProperty extends CsdlStructuralProperty {\n  constructor(name, type, nullable, maxLength, precision, scale, unicode, srid, defaultValue) {\n    super(name, type, nullable);\n    this.maxLength = maxLength;\n    this.precision = precision;\n    this.scale = scale;\n    this.unicode = unicode;\n    this.srid = srid;\n    this.defaultValue = defaultValue;\n  }\n\n}\n\nclass CsdlNavigationProperty extends CsdlStructuralProperty {\n  constructor(name, type, nullable, partner, containsTarget, referentialConstraints, onDelete) {\n    super(name, type, nullable);\n    this.partner = partner;\n    this.containsTarget = containsTarget;\n    this.referentialConstraints = referentialConstraints;\n    this.onDelete = onDelete;\n  }\n\n}\n\nclass CsdlReferentialConstraint {\n  constructor(property, referencedProperty) {\n    this.property = property;\n    this.referencedProperty = referencedProperty;\n  }\n\n}\n\nclass CsdlOnDelete {\n  constructor(action) {\n    this.action = action;\n  }\n\n}\n\nclass CsdlEntityContainer {\n  constructor(name, extend, entitySets, singletons, functionImports, actionImports) {\n    this.name = name;\n    this.extend = extend;\n    this.entitySets = entitySets;\n    this.singletons = singletons;\n    this.functionImports = functionImports;\n    this.actionImports = actionImports;\n  }\n\n}\n\nclass CsdlEntitySet {\n  constructor(name, entityType, navigationPropertyBinding, includeInServiceDocument) {\n    this.name = name;\n    this.entityType = entityType;\n    this.navigationPropertyBinding = navigationPropertyBinding;\n    this.includeInServiceDocument = includeInServiceDocument;\n  }\n\n}\n\nclass CsdlNavigationPropertyBinding {\n  constructor(path, target) {\n    this.path = path;\n    this.target = target;\n  }\n\n}\n\nclass CsdlSchema extends CsdlAnnotable {\n  constructor(namespace, alias, enumTypes, complexTypes, entityTypes, functions, actions, entityContainer, typeDefinitions, terms, annotationsList, annotationList) {\n    super(annotationList);\n    this.namespace = namespace;\n    this.alias = alias;\n    this.enumTypes = enumTypes;\n    this.complexTypes = complexTypes;\n    this.entityTypes = entityTypes;\n    this.functions = functions;\n    this.actions = actions;\n    this.entityContainer = entityContainer;\n    this.typeDefinitions = typeDefinitions;\n    this.terms = terms;\n    this.annotationsList = annotationsList;\n  }\n\n}\n\nclass CsdlSingleton {\n  constructor(name, type, navigationPropertyBindings) {\n    this.name = name;\n    this.type = type;\n    this.navigationPropertyBindings = navigationPropertyBindings;\n  }\n\n}\n\nclass CsdlTypeDefinition extends CsdlAnnotable {\n  constructor(name, underlayingType, maxLength, precision, scale, unicode, srid, annotationList) {\n    super(annotationList);\n    this.name = name;\n    this.underlayingType = underlayingType;\n    this.maxLength = maxLength;\n    this.precision = precision;\n    this.scale = scale;\n    this.unicode = unicode;\n    this.srid = srid;\n  }\n\n}\n\nvar FieldType = /*#__PURE__*/(() => {\n  (function (FieldType) {\n    FieldType[FieldType[\"ATTRIBUTE\"] = 0] = \"ATTRIBUTE\";\n    FieldType[FieldType[\"TAG\"] = 1] = \"TAG\";\n  })(FieldType || (FieldType = {}));\n\n  return FieldType;\n})();\n\nclass Field {\n  constructor(name, fieldType) {\n    this.name = name;\n    this.fieldType = fieldType;\n  }\n\n}\n\nlet ODataMetadata = /*#__PURE__*/(() => {\n  class ODataMetadata {\n    constructor(xml) {\n      try {\n        const parser = new DOMParser();\n        const document = parser.parseFromString(xml, 'text/xml');\n        this.checkVersion(document);\n        this.version = this.getFieldValueByAttribute(new Field(ODataMetadata.ATTRIBUTE_VERSION, FieldType.ATTRIBUTE), document.documentElement.attributes);\n        this.references = this.getObjects(document.documentElement, ODataMetadata.TAG_REFERENCE, [new Field(ODataMetadata.ATTRIBUTE_URI, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_INCLUDE, FieldType.TAG), new Field(ODataMetadata.TAG_INCLUDE_ANNOTATIONS, FieldType.TAG), new Field(ODataMetadata.TAG_ANNOTATION, FieldType.TAG)]);\n        const dataServices = document.documentElement.getElementsByTagName(ODataMetadata.TAG_DATA_SERVICES)[0];\n        this.schemas = this.getObjects(dataServices, ODataMetadata.TAG_SCHEMA, [new Field(ODataMetadata.ATTRIBUTE_NAMESPACE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ALIAS, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_ENUM_TYPE, FieldType.TAG), new Field(ODataMetadata.TAG_COMPLEX_TYPE, FieldType.TAG), new Field(ODataMetadata.TAG_ENTITY_TYPE, FieldType.TAG), new Field(ODataMetadata.TAG_FUNCTION, FieldType.TAG), new Field(ODataMetadata.TAG_ACTION, FieldType.TAG), new Field(ODataMetadata.TAG_ENTITY_CONTAINER, FieldType.TAG), new Field(ODataMetadata.TAG_TYPE_DEFINITION, FieldType.TAG), new Field(ODataMetadata.TAG_TERM, FieldType.TAG), new Field(ODataMetadata.TAG_ANNOTATIONS, FieldType.TAG), new Field(ODataMetadata.TAG_ANNOTATION, FieldType.TAG)]);\n      } catch (error) {\n        throw new Error('Unable to parse metadata, ' + error);\n      }\n    }\n\n    checkVersion(document) {\n      // check version\n      const attributes = document.documentElement.attributes;\n\n      if (!attributes) {\n        throw new Error('OData version is not specified in the metadata');\n      }\n\n      const attr = attributes.getNamedItem('Version');\n\n      if (attr === null) {\n        throw new Error('OData version is not specified in the metadata');\n      }\n\n      const odataVersion = attr === null || attr === void 0 ? void 0 : attr.nodeValue;\n\n      if (odataVersion !== VERSION_4_0) {\n        throw new Error('OData version \"' + odataVersion + '\" is not supported');\n      }\n    }\n\n    getObjects(parentElement, tag, fieldNames) {\n      let objects = [];\n      const children = parentElement.children;\n\n      for (let index = 0; index < children.length; index++) {\n        const element = children.item(index);\n\n        if (!element || element.nodeName !== tag) {\n          continue;\n        }\n\n        const attributes = element.attributes;\n        const fieldValues = this.getFieldValues(fieldNames, attributes, element);\n\n        switch (tag) {\n          case ODataMetadata.TAG_REFERENCE:\n            objects.push(new CsdlReference(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3]));\n            break;\n\n          case ODataMetadata.TAG_INCLUDE:\n            objects.push(new CsdlInclude(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_INCLUDE_ANNOTATIONS:\n            objects.push(new CsdlIncludeAnnotations(fieldValues[0], fieldValues[1], fieldValues[2]));\n            break;\n\n          case ODataMetadata.TAG_TERM:\n            objects.push(new CsdlTerm(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6], fieldValues[7], fieldValues[8], fieldValues[9]));\n            break;\n\n          case ODataMetadata.TAG_ANNOTATIONS:\n            objects.push(new CsdlAnnotations(fieldValues[0], fieldValues[1], fieldValues[2]));\n            break;\n\n          case ODataMetadata.TAG_ANNOTATION:\n            objects.push(new CsdlAnnotation(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_SCHEMA:\n            objects.push(new CsdlSchema(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6], fieldValues[7], fieldValues[8], fieldValues[9], fieldValues[10], fieldValues[11]));\n            break;\n\n          case ODataMetadata.TAG_ENUM_TYPE:\n            objects.push(new CsdlEnumType(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3]));\n            break;\n\n          case ODataMetadata.TAG_COMPLEX_TYPE:\n            objects.push(new CsdlComplexType(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5]));\n            break;\n\n          case ODataMetadata.TAG_ENTITY_TYPE:\n            objects.push(new CsdlEntityType(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6], fieldValues[7]));\n            break;\n\n          case ODataMetadata.TAG_FUNCTION:\n            objects.push(new CsdlFunction(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5]));\n            break;\n\n          case ODataMetadata.TAG_MEMBER:\n            objects.push(new CsdlEnumMember(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_PROPERTY:\n            objects.push(new CsdlProperty(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6], fieldValues[7], fieldValues[8]));\n            break;\n\n          case ODataMetadata.TAG_PROPERTY_REF:\n            objects.push(new CsdlPropertyRef(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_NAVIGATION_PROPERTY:\n            objects.push(new CsdlNavigationProperty(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6]));\n            break;\n\n          case ODataMetadata.TAG_REFERENTIAL_CONSTRAINT:\n            objects.push(new CsdlReferentialConstraint(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_PARAMETER:\n            objects.push(new CsdlParameter(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6]));\n            break;\n\n          case ODataMetadata.TAG_ACTION:\n            objects.push(new CsdlAction(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4]));\n            break;\n\n          case ODataMetadata.TAG_ENTITY_SET:\n            objects.push(new CsdlEntitySet(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3]));\n            break;\n\n          case ODataMetadata.TAG_SINGLETON:\n            objects.push(new CsdlSingleton(fieldValues[0], fieldValues[1], fieldValues[2]));\n            break;\n\n          case ODataMetadata.TAG_FUNCTION_IMPORT:\n            objects.push(new CsdlFunctionImport(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3]));\n            break;\n\n          case ODataMetadata.TAG_ACTION_IMPORT:\n            objects.push(new CsdlActionImport(fieldValues[0], fieldValues[1], fieldValues[2]));\n            break;\n\n          case ODataMetadata.TAG_NAVIGATION_PROPERTY_BINDING:\n            objects.push(new CsdlNavigationPropertyBinding(fieldValues[0], fieldValues[1]));\n            break;\n\n          case ODataMetadata.TAG_TYPE_DEFINITION:\n            objects.push(new CsdlTypeDefinition(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5], fieldValues[6], fieldValues[7]));\n            break;\n\n          default:\n            throw new Error('Unknwon tag:' + tag);\n        }\n      }\n\n      return objects;\n    }\n\n    getObject(parentElement, tag, fieldNames) {\n      var _a;\n\n      let object;\n      const children = parentElement.children;\n      let element;\n\n      for (let index = 0; index < children.length; index++) {\n        if (children && ((_a = children.item(index)) === null || _a === void 0 ? void 0 : _a.nodeName) === tag) {\n          if (element !== undefined && element !== null) {\n            throw new Error('Expected one ' + tag);\n          }\n\n          element = children.item(index);\n        }\n      }\n\n      if (element !== undefined && element !== null) {\n        const attributes = element.attributes;\n        const fieldValues = this.getFieldValues(fieldNames, attributes, element);\n\n        switch (tag) {\n          case ODataMetadata.TAG_KEY:\n            object = new CsdlKey(fieldValues[0]);\n            break;\n\n          case ODataMetadata.TAG_RETURN_TYPE:\n            object = new CsdlReturnType(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5]);\n            break;\n\n          case ODataMetadata.TAG_ENTITY_CONTAINER:\n            object = new CsdlEntityContainer(fieldValues[0], fieldValues[1], fieldValues[2], fieldValues[3], fieldValues[4], fieldValues[5]);\n            break;\n\n          case ODataMetadata.TAG_ON_DELETE:\n            object = new CsdlOnDelete(fieldValues[0]);\n            break;\n\n          default:\n            throw new Error('Unknwon tag:' + tag);\n        }\n      }\n\n      return object;\n    }\n\n    getFieldValues(fields, attributes, element) {\n      const fieldValues = [];\n\n      for (const field of fields) {\n        if (field.fieldType === FieldType.TAG) {\n          fieldValues.push(this.getFieldValueByTag(field, element));\n        } else if (field.fieldType === FieldType.ATTRIBUTE) {\n          fieldValues.push(this.getFieldValueByAttribute(field, attributes));\n        } else {\n          throw new Error('Unknown field type: ' + field.fieldType);\n        }\n      }\n\n      return fieldValues;\n    }\n\n    getFieldValueByAttribute(field, attributes) {\n      switch (field.name) {\n        case ODataMetadata.ATTRIBUTE_VERSION:\n        case ODataMetadata.ATTRIBUTE_URI:\n        case ODataMetadata.ATTRIBUTE_NAMESPACE:\n        case ODataMetadata.ATTRIBUTE_ALIAS:\n        case ODataMetadata.ATTRIBUTE_TERM_NAMESPACE:\n        case ODataMetadata.ATTRIBUTE_TERM:\n        case ODataMetadata.ATTRIBUTE_QUALIFIER:\n        case ODataMetadata.ATTRIBUTE_TARGET_NAMESPACE:\n        case ODataMetadata.ATTRIBUTE_NAME:\n        case ODataMetadata.ATTRIBUTE_TYPE:\n        case ODataMetadata.ATTRIBUTE_SRID:\n        case ODataMetadata.ATTRIBUTE_DEFAULT_VALUE:\n        case ODataMetadata.ATTRIBUTE_PARTNER:\n        case ODataMetadata.ATTRIBUTE_PROPERTY:\n        case ODataMetadata.ATTRIBUTE_REFERENCED_PROPERTY:\n        case ODataMetadata.ATTRIBUTE_BASE_TYPE:\n        case ODataMetadata.ATTRIBUTE_ENTITY_SET_PATH:\n        case ODataMetadata.ATTRIBUTE_ENTITY_TYPE:\n        case ODataMetadata.ATTRIBUTE_PATH:\n        case ODataMetadata.ATTRIBUTE_TARGET:\n        case ODataMetadata.ATTRIBUTE_FUNCTION:\n        case ODataMetadata.ATTRIBUTE_ACTION:\n        case ODataMetadata.ATTRIBUTE_ENTITY_SET:\n        case ODataMetadata.ATTRIBUTE_UNDERLYING_TYPE:\n        case ODataMetadata.ATTRIBUTE_EXTENDS:\n        case ODataMetadata.ATTRIBUTE_BASE_TERM:\n        case ODataMetadata.ATTRIBUTE_APPLIES_TO:\n          return this.getAttributeValue(attributes, field.name);\n\n        case ODataMetadata.ATTRIBUTE_NULLABLE:\n        case ODataMetadata.ATTRIBUTE_UNICODE:\n        case ODataMetadata.ATTRIBUTE_OPEN_TYPE:\n        case ODataMetadata.ATTRIBUTE_HAS_STREAM:\n        case ODataMetadata.ATTRIBUTE_IS_BOUND:\n        case ODataMetadata.ATTRIBUTE_IS_COMPOSABLE:\n        case ODataMetadata.ATTRIBUTE_CONTAINS_TARGET:\n        case ODataMetadata.ATTRIBUTE_INCLUDE_IN_SERVICE_DOCUMENT:\n        case ODataMetadata.ATTRIBUTE_ABSTRACT:\n        case ODataMetadata.ATTRIBUTE_IS_FLAGS:\n          return this.propertyValueToBoolean(this.getAttributeValue(attributes, field.name));\n\n        case ODataMetadata.ATTRIBUTE_VALUE:\n        case ODataMetadata.ATTRIBUTE_MAX_LENGTH:\n        case ODataMetadata.ATTRIBUTE_PRECISION:\n        case ODataMetadata.ATTRIBUTE_SCALE:\n          return this.propertyValueToNumber(this.getAttributeValue(attributes, field.name));\n\n        default:\n          throw new Error('Unknwon attribute:' + field.name);\n      }\n    }\n\n    getFieldValueByTag(field, element) {\n      switch (field.name) {\n        case ODataMetadata.TAG_INCLUDE:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAMESPACE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ALIAS, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_INCLUDE_ANNOTATIONS:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_TERM_NAMESPACE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_QUALIFIER, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TARGET_NAMESPACE, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_TERM:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_BASE_TERM, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_DEFAULT_VALUE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_APPLIES_TO, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_NULLABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_MAX_LENGTH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PRECISION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SCALE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SRID, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ANNOTATIONS:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_TARGET, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_ANNOTATION, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_QUALIFIER, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ANNOTATION:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_TERM, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_QUALIFIER, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ENUM_TYPE:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_MEMBER, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_UNDERLYING_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_IS_FLAGS, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_COMPLEX_TYPE:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_PROPERTY, FieldType.TAG), new Field(ODataMetadata.TAG_NAVIGATION_PROPERTY, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_BASE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_OPEN_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ABSTRACT, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ENTITY_TYPE:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_KEY, FieldType.TAG), new Field(ODataMetadata.TAG_PROPERTY, FieldType.TAG), new Field(ODataMetadata.TAG_NAVIGATION_PROPERTY, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_BASE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_OPEN_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_HAS_STREAM, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ABSTRACT, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_FUNCTION:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_RETURN_TYPE, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_IS_BOUND, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ENTITY_SET_PATH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_IS_COMPOSABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_PARAMETER, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_MEMBER:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_VALUE, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_PROPERTY:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_NULLABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_MAX_LENGTH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PRECISION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SCALE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_UNICODE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SRID, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_DEFAULT_VALUE, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_KEY:\n          return this.getObject(element, field.name, [new Field(ODataMetadata.TAG_PROPERTY_REF, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_PROPERTY_REF:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ALIAS, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_NAVIGATION_PROPERTY:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_NULLABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PARTNER, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_CONTAINS_TARGET, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_REFERENTIAL_CONSTRAINT, FieldType.TAG), new Field(ODataMetadata.TAG_ON_DELETE, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_REFERENTIAL_CONSTRAINT:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_PROPERTY, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_REFERENCED_PROPERTY, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ON_DELETE:\n          return this.getObject(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_ACTION, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_PARAMETER:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_NULLABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_MAX_LENGTH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PRECISION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SCALE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SRID, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_RETURN_TYPE:\n          return this.getObject(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_NULLABLE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_MAX_LENGTH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PRECISION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SCALE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SRID, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ACTION:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_RETURN_TYPE, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_IS_BOUND, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ENTITY_SET_PATH, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_PARAMETER, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_ENTITY_CONTAINER:\n          return this.getObject(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_EXTENDS, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_ENTITY_SET, FieldType.TAG), new Field(ODataMetadata.TAG_SINGLETON, FieldType.TAG), new Field(ODataMetadata.TAG_FUNCTION_IMPORT, FieldType.TAG), new Field(ODataMetadata.TAG_ACTION_IMPORT, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_ENTITY_SET:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ENTITY_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_NAVIGATION_PROPERTY_BINDING, FieldType.TAG), new Field(ODataMetadata.ATTRIBUTE_INCLUDE_IN_SERVICE_DOCUMENT, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_SINGLETON:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_NAVIGATION_PROPERTY_BINDING, FieldType.TAG)]);\n\n        case ODataMetadata.TAG_FUNCTION_IMPORT:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_FUNCTION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ENTITY_SET, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_INCLUDE_IN_SERVICE_DOCUMENT, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_ACTION_IMPORT:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ACTION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_ENTITY_SET, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_NAVIGATION_PROPERTY_BINDING:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_PATH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_TARGET, FieldType.ATTRIBUTE)]);\n\n        case ODataMetadata.TAG_TYPE_DEFINITION:\n          return this.getObjects(element, field.name, [new Field(ODataMetadata.ATTRIBUTE_NAME, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_UNDERLYING_TYPE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_MAX_LENGTH, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_PRECISION, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SCALE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_UNICODE, FieldType.ATTRIBUTE), new Field(ODataMetadata.ATTRIBUTE_SRID, FieldType.ATTRIBUTE), new Field(ODataMetadata.TAG_ANNOTATION, FieldType.TAG)]);\n\n        default:\n          throw new Error('Unknwon tag:' + field.name);\n      }\n    }\n\n    getAttributeValue(attributes, attributeName) {\n      const attribute = attributes.getNamedItem(attributeName);\n      return attribute !== null && attribute.nodeValue ? attribute.nodeValue : undefined;\n    }\n\n    propertyValueToNumber(attributeValue) {\n      return attributeValue !== undefined ? Number(attributeValue) : undefined;\n    }\n\n    propertyValueToBoolean(attributeValue) {\n      return attributeValue !== undefined ? attributeValue === 'true' : false;\n    }\n\n  }\n\n  // TAGS\n  ODataMetadata.TAG_EDMX = 'edmx:Edmx';\n  ODataMetadata.TAG_DATA_SERVICES = 'edmx:DataServices';\n  ODataMetadata.TAG_REFERENCE = 'edmx:Reference';\n  ODataMetadata.TAG_INCLUDE = 'edmx:Include';\n  ODataMetadata.TAG_INCLUDE_ANNOTATIONS = 'edmx:IncludeAnnotations';\n  ODataMetadata.TAG_TERM = 'Term';\n  ODataMetadata.TAG_ANNOTATIONS = 'Annotations';\n  ODataMetadata.TAG_ANNOTATION = 'Annotation';\n  ODataMetadata.TAG_SCHEMA = 'Schema';\n  ODataMetadata.TAG_ENUM_TYPE = 'EnumType';\n  ODataMetadata.TAG_MEMBER = 'Member';\n  ODataMetadata.TAG_COMPLEX_TYPE = 'ComplexType';\n  ODataMetadata.TAG_ENTITY_TYPE = 'EntityType';\n  ODataMetadata.TAG_PROPERTY = 'Property';\n  ODataMetadata.TAG_KEY = 'Key';\n  ODataMetadata.TAG_PROPERTY_REF = 'PropertyRef';\n  ODataMetadata.TAG_NAVIGATION_PROPERTY = 'NavigationProperty';\n  ODataMetadata.TAG_REFERENTIAL_CONSTRAINT = 'ReferentialConstraint';\n  ODataMetadata.TAG_ON_DELETE = 'OnDelete';\n  ODataMetadata.TAG_FUNCTION = 'Function';\n  ODataMetadata.TAG_RETURN_TYPE = 'ReturnType';\n  ODataMetadata.TAG_PARAMETER = 'Parameter';\n  ODataMetadata.TAG_ACTION = 'Action';\n  ODataMetadata.TAG_ENTITY_CONTAINER = 'EntityContainer';\n  ODataMetadata.TAG_ENTITY_SET = 'EntitySet';\n  ODataMetadata.TAG_SINGLETON = 'Singleton';\n  ODataMetadata.TAG_FUNCTION_IMPORT = 'FunctionImport';\n  ODataMetadata.TAG_ACTION_IMPORT = 'ActionImport';\n  ODataMetadata.TAG_NAVIGATION_PROPERTY_BINDING = 'NavigationPropertyBinding';\n  ODataMetadata.TAG_TYPE_DEFINITION = 'TypeDefinition'; // ATTRIBUTES\n\n  ODataMetadata.ATTRIBUTE_VERSION = 'Version';\n  ODataMetadata.ATTRIBUTE_URI = 'Uri';\n  ODataMetadata.ATTRIBUTE_ALIAS = 'Alias';\n  ODataMetadata.ATTRIBUTE_NAMESPACE = 'Namespace';\n  ODataMetadata.ATTRIBUTE_TERM_NAMESPACE = 'TermNamespace';\n  ODataMetadata.ATTRIBUTE_QUALIFIER = 'Qualifier';\n  ODataMetadata.ATTRIBUTE_TARGET_NAMESPACE = 'TargetNamespace';\n  ODataMetadata.ATTRIBUTE_TERM = 'Term';\n  ODataMetadata.ATTRIBUTE_NAME = 'Name';\n  ODataMetadata.ATTRIBUTE_VALUE = 'Value';\n  ODataMetadata.ATTRIBUTE_BASE_TYPE = 'BaseType';\n  ODataMetadata.ATTRIBUTE_OPEN_TYPE = 'OpenType';\n  ODataMetadata.ATTRIBUTE_TYPE = 'Type';\n  ODataMetadata.ATTRIBUTE_NULLABLE = 'Nullable';\n  ODataMetadata.ATTRIBUTE_MAX_LENGTH = 'MaxLength';\n  ODataMetadata.ATTRIBUTE_PRECISION = 'Precision';\n  ODataMetadata.ATTRIBUTE_SCALE = 'Scale';\n  ODataMetadata.ATTRIBUTE_UNICODE = 'Unicode';\n  ODataMetadata.ATTRIBUTE_SRID = 'SRID';\n  ODataMetadata.ATTRIBUTE_DEFAULT_VALUE = 'DefaultValue';\n  ODataMetadata.ATTRIBUTE_PARTNER = 'Partner';\n  ODataMetadata.ATTRIBUTE_PROPERTY = 'Property';\n  ODataMetadata.ATTRIBUTE_REFERENCED_PROPERTY = 'ReferencedProperty';\n  ODataMetadata.ATTRIBUTE_HAS_STREAM = 'HasStream';\n  ODataMetadata.ATTRIBUTE_CONTAINS_TARGET = 'ContainsTarget';\n  ODataMetadata.ATTRIBUTE_IS_BOUND = 'IsBound';\n  ODataMetadata.ATTRIBUTE_ENTITY_SET_PATH = 'EntitySetPath';\n  ODataMetadata.ATTRIBUTE_IS_COMPOSABLE = 'IsComposable';\n  ODataMetadata.ATTRIBUTE_ENTITY_TYPE = 'EntityType';\n  ODataMetadata.ATTRIBUTE_PATH = 'Path';\n  ODataMetadata.ATTRIBUTE_TARGET = 'Target';\n  ODataMetadata.ATTRIBUTE_FUNCTION = 'Function';\n  ODataMetadata.ATTRIBUTE_ACTION = 'Action';\n  ODataMetadata.ATTRIBUTE_ENTITY_SET = 'EntitySet';\n  ODataMetadata.ATTRIBUTE_INCLUDE_IN_SERVICE_DOCUMENT = 'IncludeInServiceDocument';\n  ODataMetadata.ATTRIBUTE_ABSTRACT = 'Abstract';\n  ODataMetadata.ATTRIBUTE_UNDERLYING_TYPE = 'UnderlyingType';\n  ODataMetadata.ATTRIBUTE_IS_FLAGS = 'IsFlags';\n  ODataMetadata.ATTRIBUTE_EXTENDS = 'Extends';\n  ODataMetadata.ATTRIBUTE_BASE_TERM = 'BaseTerm';\n  ODataMetadata.ATTRIBUTE_APPLIES_TO = 'AppliesTo';\n  return ODataMetadata;\n})();\n\nclass ODataMetadataResource extends ODataResource {\n  constructor(api, segments) {\n    super(api, {\n      segments\n    });\n  } //#region Factory\n\n\n  static factory(api) {\n    let segments = new ODataPathSegments();\n    segments.add(PathSegmentNames.metadata, $METADATA);\n    return new ODataMetadataResource(api, segments);\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n  //#region Requests\n\n\n  get(options) {\n    return super.get(Object.assign({\n      responseType: 'text'\n    }, options)).pipe(map(body => new ODataMetadata(body)));\n  } //#endregion\n  //#region Shortcuts\n\n\n  fetch(options) {\n    return this.get(options);\n  }\n\n}\n\nclass ODataSingletonResource extends ODataResource {\n  //#region Factory\n  static factory(api, {\n    path,\n    schema,\n    query\n  }) {\n    const segments = new ODataPathSegments();\n    const segment = segments.add(PathSegmentNames.singleton, path);\n    if (schema !== undefined) segment.type(schema.type());\n    return new ODataSingletonResource(api, {\n      segments,\n      query,\n      schema\n    });\n  }\n\n  clone() {\n    return super.clone();\n  } //#endregion\n\n\n  key(value) {\n    const singleton = this.clone();\n    var key = this.resolveKey(value);\n    if (key !== undefined) singleton.segment(s => s.singleton().key(key));\n    return singleton;\n  }\n\n  keys(values) {\n    const singleton = this.clone();\n    const types = this.pathSegments.types({\n      key: true\n    });\n    const keys = values.map((value, index) => ODataResource.resolveKey(value, this.api.findStructuredTypeForType(types[index])));\n    singleton.segment(s => s.keys(keys));\n    return singleton;\n  }\n\n  navigationProperty(path) {\n    return ODataNavigationPropertyResource.fromResource(this, path);\n  }\n\n  property(path) {\n    return ODataPropertyResource.fromResource(this, path);\n  }\n\n  action(path) {\n    return ODataActionResource.fromResource(this, path);\n  }\n\n  function(path) {\n    return ODataFunctionResource.fromResource(this, path);\n  } //#region Requests\n\n\n  post(attrs, options = {}) {\n    return super.post(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  put(attrs, options = {}) {\n    return super.put(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  patch(attrs, options = {}) {\n    return super.patch(attrs, Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  delete(options = {}) {\n    return super.delete(Object.assign({\n      responseType: 'entity'\n    }, options));\n  }\n\n  get(options = {}) {\n    return super.get(Object.assign({\n      responseType: 'entity'\n    }, options));\n  } //#endregion\n  //#region Shortcuts\n\n  /**\n   * Creates a new entity.\n   * @param attrs The entity attributes to create.\n   * @param options The options for the request.\n   * @returns The created entity with the annotations.\n   */\n\n\n  create(attrs, options) {\n    return this.post(attrs, options);\n  }\n  /**\n   * Updates an existing entity.\n   * @param attrs The entity attributes to update.\n   * @param options The options for the request.\n   * @returns The updated entity with the annotations.\n   */\n\n\n  update(attrs, options) {\n    return this.put(attrs, options);\n  }\n  /**\n   * Modifies an existing entity.\n   * @param attrs The entity attributes to modify.\n   * @param options The options for the request.\n   * @returns The modified entity with the annotations.\n   */\n\n\n  modify(attrs, options) {\n    return this.patch(attrs, options);\n  }\n  /**\n   * Delete an existing entity.\n   * @param options The options for the request.\n   * @returns Observable of the deleted entity.\n   */\n\n\n  destroy(options) {\n    return this.delete(options);\n  }\n  /**\n   * Fetch an existing entity.\n   * @param options The options for the request.\n   * @param etag The etag to use for the request.\n   * @returns Observable of the entity with the annotations.\n   */\n\n\n  fetch(options) {\n    return this.get(options);\n  }\n  /**\n   * Fetch an existing entity.\n   * @param options The options for the request.\n   * @param etag The etag to use for the request.\n   * @returns Observable of the entity.\n   */\n\n\n  fetchEntity(options) {\n    return this.fetch(options).pipe(map(({\n      entity\n    }) => entity));\n  }\n  /**\n   * Fetch an existing entity and return a model.\n   * @param options The options for the request.\n   * @param etag The etag to use for the request.\n   * @returns Observable of the entity.\n   */\n\n\n  fetchModel(options) {\n    return this.fetch(options).pipe(map(({\n      entity,\n      annots\n    }) => entity ? this.asModel(entity, {\n      annots,\n      reset: true\n    }) : null));\n  }\n\n}\n\nclass ODataInStorageCache extends ODataCache {\n  constructor({\n    name,\n    storage = sessionStorage,\n    timeout\n  }) {\n    super({\n      timeout\n    });\n    this.name = name;\n    this.storage = storage;\n    this.restore();\n    window.addEventListener('beforeunload', () => this.store());\n  }\n  /**\n   * Store the cache in the storage\n   */\n\n\n  store() {\n    this.storage.setItem(this.name, JSON.stringify(Array.from(this.entries.entries())));\n  }\n  /**\n   * Restore the cache from the storage\n   */\n\n\n  restore() {\n    this.entries = new Map(JSON.parse(this.storage.getItem(this.name) || '[]'));\n  }\n  /**\n   * Flush the cache and clean the storage\n   */\n\n\n  flush() {\n    super.flush();\n    this.store();\n  }\n  /**\n   * Store the response in the cache\n   * @param req The request with the resource to store the response\n   * @param res The response to store in the cache\n   */\n\n\n  putResponse(req, res) {\n    const scope = this.scope(req);\n    const tags = this.tags(res);\n    this.put(req.cacheKey, res.toJSON(), {\n      timeout: res.options.maxAge,\n      scope,\n      tags\n    });\n  }\n  /**\n   * Restore the response from the cache\n   * @param req The request with the resource to get the response\n   * @returns The response from the cache\n   */\n\n\n  getResponse(req) {\n    const scope = this.scope(req);\n    const data = this.get(req.cacheKey, {\n      scope\n    });\n    return data !== undefined ? ODataResponse.fromJSON(req, data) : undefined;\n  }\n\n}\n\nclass ODataModelEvent {\n  constructor(name, {\n    model,\n    collection,\n    previous,\n    value,\n    field,\n    options\n  } = {}) {\n    this.bubbling = true;\n    this.name = name;\n    this.model = model;\n    this.collection = collection;\n    this.previous = previous;\n    this.value = value;\n    this.options = options;\n    this.chain = [[this.collection || this.model, field || null]];\n  }\n\n  stopPropagation() {\n    this.bubbling = false;\n  }\n\n  push(model, field) {\n    let event = new ODataModelEvent(this.name, {\n      model: this.model,\n      collection: this.collection,\n      previous: this.previous,\n      value: this.value,\n      options: this.options\n    });\n    event.chain = [...this.chain];\n    event.chain.splice(0, 0, [model, field]);\n    return event;\n  }\n\n  visited(model) {\n    return this.chain.some(c => c[0] === model) && this.chain[this.chain.length - 1][0] !== model;\n  }\n\n  get path() {\n    return this.chain.map(([, field], index) => typeof field === 'number' ? `[${field}]` : field instanceof ODataModelField ? index === 0 ? field.name : `.${field.name}` : '').join('');\n  } //Identifies the current model for the event\n\n\n  get currentModel() {\n    const link = this.chain.find(c => ODataModelOptions.isModel(c[0]));\n    return link !== undefined ? link[0] : undefined;\n  } //Identifies the current collection for the event\n\n\n  get currentCollection() {\n    const link = this.chain.find(c => ODataModelOptions.isCollection(c[0]));\n    return link !== undefined ? link[0] : undefined;\n  }\n\n}\n\nconst BUBBLING = ['change', 'reset', 'update', 'destroy', 'add', 'remove'];\nconst INCLUDE_SHALLOW = {\n  include_concurrency: true,\n  include_computed: true,\n  include_key: true\n};\nconst INCLUDE_DEEP = Object.assign({\n  include_navigation: true,\n  include_non_field: true\n}, INCLUDE_SHALLOW);\nvar ODataModelState = /*#__PURE__*/(() => {\n  (function (ODataModelState) {\n    ODataModelState[ODataModelState[\"Added\"] = 0] = \"Added\";\n    ODataModelState[ODataModelState[\"Removed\"] = 1] = \"Removed\";\n    ODataModelState[ODataModelState[\"Changed\"] = 2] = \"Changed\";\n    ODataModelState[ODataModelState[\"Unchanged\"] = 3] = \"Unchanged\";\n  })(ODataModelState || (ODataModelState = {}));\n\n  return ODataModelState;\n})();\n\nfunction Model({\n  cid = CID_FIELD_NAME\n} = {}) {\n  return constructor => {\n    const Klass = constructor;\n    if (!Klass.hasOwnProperty('options')) Klass.options = {\n      fields: {}\n    };\n    Klass.options.cid = cid;\n    return constructor;\n  };\n}\n\nfunction ModelField(_a = {}) {\n  var {\n    name\n  } = _a,\n      options = __rest(_a, [\"name\"]);\n\n  return (target, key) => {\n    const Klass = target.constructor;\n    if (!Klass.hasOwnProperty('options')) Klass.options = {\n      fields: {}\n    };\n    options.field = name || key;\n    Klass.options.fields[key] = options;\n  };\n}\n\nclass ODataModelField {\n  constructor(options, _a) {\n    var {\n      name,\n      field,\n      parser\n    } = _a,\n        opts = __rest(_a, [\"name\", \"field\", \"parser\"]);\n\n    this.options = options;\n    this.name = name;\n    this.field = field;\n    this.parser = parser;\n    this.default = opts.default || parser.default;\n    this.required = Boolean(opts.required || !parser.nullable);\n    this.concurrency = Boolean(opts.concurrency);\n    this.maxLength = opts.maxLength || parser.maxLength;\n    this.minLength = opts.minLength;\n    this.min = opts.min;\n    this.max = opts.max;\n    this.pattern = opts.pattern;\n  }\n\n  get api() {\n    return this.options.api;\n  }\n\n  get type() {\n    return this.parser.type;\n  }\n\n  get navigation() {\n    return Boolean(this.parser.navigation);\n  }\n\n  get collection() {\n    return Boolean(this.parser.collection);\n  }\n\n  annotatedValue(term) {\n    return this.parser.annotatedValue(term);\n  }\n\n  configure({\n    findOptionsForType,\n    concurrency,\n    options\n  }) {\n    this.meta = findOptionsForType(this.parser.type);\n    this.parserOptions = options;\n    if (concurrency) this.concurrency = concurrency;\n    if (this.default !== undefined) this.default = this.deserialize(this.default, options);\n  }\n\n  isKey() {\n    return this.parser.isKey();\n  }\n\n  hasReferentials() {\n    return this.parser.hasReferentials();\n  }\n\n  get referentials() {\n    return this.parser.referentials;\n  }\n\n  isStructuredType() {\n    return this.parser.isStructuredType();\n  }\n\n  structured() {\n    let structuredType = this.api.findStructuredTypeForType(this.parser.type); //Throw error if not found\n\n    if (!structuredType) throw new Error(`Could not find structured type for ${this.parser.type}`);\n    return structuredType;\n  }\n\n  isEnumType() {\n    return this.parser.isEnumType();\n  }\n\n  enum() {\n    let enumType = this.api.findEnumTypeForType(this.parser.type); //Throw error if not found\n\n    if (!enumType) throw new Error(`Could not find enum type for ${this.parser.type}`);\n    return enumType;\n  }\n\n  validate(value, {\n    method,\n    navigation = false\n  } = {}) {\n    var _a;\n    /*\n    if ('isValid' in value && typeof value.isValid === 'function') {\n      return !value.isValid({ method, navigation }) ? value._errors : undefined;\n    } else if ('models' in value && typeof value.models === 'function') {\n      */\n\n\n    if (ODataModelOptions.isModel(value)) {\n      return !value.isValid({\n        method,\n        navigation\n      }) ? value._errors : undefined;\n    } else if (ODataModelOptions.isCollection(value)) {\n      return value.models().some(m => !m.isValid({\n        method,\n        navigation\n      })) ? value.models().map(m => m._errors) : undefined;\n    } else {\n      const computed = this.annotatedValue(COMPUTED);\n      let errors = ((_a = this.parser) === null || _a === void 0 ? void 0 : _a.validate(value, {\n        method,\n        navigation\n      })) || [];\n\n      if (this.required && (value === null || value === undefined && method !== 'modify') && // Is null or undefined without patch?\n      !(computed && method === 'create') // Not (Is Computed field and create) ?\n      ) {\n        errors['push'](`required`);\n      }\n\n      if (this.maxLength !== undefined && typeof value === 'string' && value.length > this.maxLength) {\n        errors['push'](`maxlength`);\n      }\n\n      if (this.minLength !== undefined && typeof value === 'string' && value.length < this.minLength) {\n        errors['push'](`minlength`);\n      }\n\n      if (this.min !== undefined && typeof value === 'number' && value < this.min) {\n        errors['push'](`min`);\n      }\n\n      if (this.max !== undefined && typeof value === 'number' && value > this.max) {\n        errors['push'](`max`);\n      }\n\n      if (this.pattern !== undefined && typeof value === 'string' && !this.pattern.test(value)) {\n        errors['push'](`pattern`);\n      }\n\n      return !Types.isEmpty(errors) ? errors : undefined;\n    }\n  }\n\n  defaults() {\n    return this.isStructuredType() && this.meta !== undefined ? this.meta.defaults() : this.default;\n  }\n\n  deserialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return this.parser.deserialize(value, parserOptions);\n  }\n\n  serialize(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return this.parser.serialize(value, parserOptions);\n  }\n\n  encode(value, options) {\n    const parserOptions = options || this.parserOptions;\n    return this.parser.encode(value, parserOptions);\n  }\n\n  resourceFactory(base) {\n    if (!(base instanceof ODataEntityResource || base instanceof ODataNavigationPropertyResource || base instanceof ODataPropertyResource)) throw new Error(\"Can't build resource for non compatible base type\");\n    return this.navigation ? base.navigationProperty(this.parser.name) : base.property(this.parser.name);\n  }\n\n  annotationsFactory(base) {\n    return this.parser.collection ? new ODataEntitiesAnnotations(base.helper, base.property(this.parser.name)) : new ODataEntityAnnotations(base.helper, base.property(this.parser.name));\n  }\n\n  schemaFactory(base) {\n    return this.api.findStructuredTypeForType(this.parser.type);\n  }\n\n  modelCollectionFactory({\n    parent,\n    value,\n    reset\n  }) {\n    const annots = this.annotationsFactory(parent.annots());\n    const Model = this.api.modelForType(this.parser.type);\n    const Collection = this.api.collectionForType(this.parser.type);\n    if (Model === undefined || Collection === undefined) throw Error(`No model for ${this.name}`);\n    return this.parser.collection ? new Collection(value || [], {\n      annots: annots,\n      parent: [parent, this],\n      reset\n    }) : new Model(value || {}, {\n      annots: annots,\n      parent: [parent, this],\n      reset\n    });\n  }\n\n}\n\nclass ODataModelOptions {\n  constructor({\n    options,\n    schema\n  }) {\n    this.children = [];\n    this.name = schema.name;\n    this.base = schema.base;\n    this.open = schema.open;\n    this.schema = schema;\n    this.cid = (options === null || options === void 0 ? void 0 : options.cid) || CID_FIELD_NAME;\n    this._fields = Object.entries(options.fields).map(([name, options]) => {\n      const {\n        field\n      } = options,\n            opts = __rest(options, [\"field\"]);\n\n      if (field === undefined || name === undefined) throw new Error('Model Properties need name and field');\n      const parser = this.schema.findFieldByName(field);\n      if (parser === undefined) throw new Error(`No parser for ${field} with name = ${name}`);\n      return new ODataModelField(this, Object.assign({\n        name,\n        field,\n        parser\n      }, opts));\n    });\n  }\n\n  get api() {\n    return this.schema.api;\n  }\n\n  type({\n    alias = false\n  } = {}) {\n    return this.schema.type({\n      alias\n    });\n  }\n\n  isTypeOf(type) {\n    return this.schema.isTypeOf(type);\n  }\n\n  isModelFor(entity) {\n    // Resolve By Type\n    let type = this.api.options.helper.type(entity);\n    if (type && this.isTypeOf(type)) return true; // Resolve By fields\n\n    let keys = Object.keys(entity);\n    let names = this.fields({\n      include_navigation: true,\n      include_parents: true\n    }).map(f => f.name);\n    return keys.every(key => names.includes(key));\n  }\n\n  findChildOptions(predicate) {\n    if (predicate(this)) return this;\n    let match;\n\n    for (let ch of this.children) {\n      match = ch.findChildOptions(predicate);\n      if (match !== undefined) break;\n    }\n\n    return match;\n  }\n\n  configure({\n    findOptionsForType,\n    options\n  }) {\n    if (this.base) {\n      const parent = findOptionsForType(this.base);\n      parent.children.push(this);\n      this.parent = parent;\n    }\n\n    this.entitySet = this.api.findEntitySetForEntityType(this.type());\n    let concurrencyFields = [];\n\n    if (this.entitySet !== undefined) {\n      concurrencyFields = this.entitySet.annotatedValue(OPTIMISTIC_CONCURRENCY) || [];\n    }\n\n    this._fields.forEach(field => {\n      let concurrency = concurrencyFields.indexOf(field.field) !== -1;\n      field.configure({\n        findOptionsForType,\n        concurrency,\n        options\n      });\n    });\n  }\n\n  fields({\n    include_navigation = false,\n    include_parents = true\n  } = {}) {\n    return [...(include_parents && this.parent !== undefined ? this.parent.fields({\n      include_navigation,\n      include_parents\n    }) : []), ...this._fields.filter(field => include_navigation || !field.navigation)];\n  }\n\n  field(name) {\n    let field = this.fields({\n      include_parents: true,\n      include_navigation: true\n    }).find(modelField => modelField.name === name || modelField.field === name); //Throw error if not found\n\n    if (field === undefined) throw new Error(`No field with name ${name}`);\n    return field;\n  }\n\n  attach(self, resource) {\n    if (self._resource !== null && resource.type() !== self._resource.type() && !self._resource.isSubtypeOf(resource)) throw new Error(`Can't attach ${resource.type()} to ${self._resource.type()}`);\n    const current = self._resource;\n\n    if (current === null || !current.isEqualTo(resource)) {\n      self._resource = resource;\n      self.events$.emit(new ODataModelEvent('attach', {\n        model: self,\n        previous: current,\n        value: resource\n      }));\n    }\n  } //# region Resource\n\n\n  static chain(child) {\n    const chain = [];\n    let tuple = [child, null];\n\n    while (tuple !== null) {\n      const parent = tuple;\n      if (chain.some(p => p[0] === parent[0])) break;\n      chain.splice(0, 0, parent);\n      tuple = tuple[0]._parent;\n    }\n\n    return chain;\n  }\n\n  static resource(child) {\n    var _a;\n\n    let resource = null;\n    let prevField = null;\n\n    for (let [model, field] of ODataModelOptions.chain(child)) {\n      resource = resource || model._resource;\n      if (resource === null) break;\n\n      if (ODataModelOptions.isModel(model) && (prevField === null || prevField.collection)) {\n        // Resolve key\n        let modelKey = model.key({\n          field_mapping: true\n        });\n        if (modelKey !== undefined) resource = resource instanceof ODataEntitySetResource ? resource.entity(modelKey) : resource.key(modelKey);\n      }\n\n      prevField = field;\n\n      if (field === null) {\n        // Apply the query from model to new resource\n        const query = (_a = model._resource) === null || _a === void 0 ? void 0 : _a.cloneQuery().toQueryArguments();\n        if (query !== undefined) resource.query(q => q.apply(query));\n        continue;\n      }\n\n      resource = field.resourceFactory(resource);\n    }\n\n    if (resource === null) throw new Error(`resource: Can't build resource for ${child}`);\n    return resource;\n  }\n\n  collectionResourceFactory(query) {\n    if (this.entitySet === undefined) return undefined;\n    return ODataEntitySetResource.factory(this.api, {\n      path: this.entitySet.name,\n      schema: this.schema,\n      query\n    });\n  }\n\n  modelResourceFactory(query) {\n    const resource = this.collectionResourceFactory(query);\n    if (resource instanceof ODataEntitySetResource) return resource.entity();\n    return resource;\n  }\n\n  entityResource(self) {\n    let resource = this.modelResourceFactory(self._resource !== null ? self._resource.cloneQuery() : undefined);\n    if (resource === undefined) throw new Error(`entityResource: Can't build resource for ${self}`);\n    const key = self.key({\n      field_mapping: true\n    });\n    if (key !== undefined) return resource.key(key);\n    return resource;\n  } //#endregion\n\n\n  bind(self, {\n    parent,\n    resource,\n    annots\n  } = {}) {\n    // Parent\n    if (parent !== undefined) {\n      self._parent = parent;\n    } // Resource\n\n\n    if (self._parent === null && resource === undefined) resource = this.modelResourceFactory();\n\n    if (resource !== undefined) {\n      this.attach(self, resource);\n    } // Annotations\n\n\n    self._annotations = annots || new ODataEntityAnnotations(ODataHelper[DEFAULT_VERSION]);\n    const fields = this.fields({\n      include_navigation: true,\n      include_parents: true\n    });\n\n    for (let field of fields) {\n      Object.defineProperty(self, field.name, {\n        configurable: true,\n        get: () => this._get(self, field),\n        set: value => this._set(self, field, value)\n      });\n    }\n  }\n\n  query(self, resource, func) {\n    resource.query(func);\n    this.attach(self, resource);\n    return self;\n  }\n\n  resolveKey(value, {\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    const keyTypes = this.schema.keys({\n      include_parents: true\n    });\n    const key = new Map();\n\n    for (let kt of keyTypes) {\n      let v = value;\n      let options = this;\n      let field;\n\n      for (let name of kt.name.split('/')) {\n        if (options === undefined) break;\n        field = options.fields({\n          include_parents: true\n        }).find(field => field.field === name);\n\n        if (field !== undefined) {\n          v = Types.isPlainObject(v) || ODataModelOptions.isModel(v) ? v[field.name] : v;\n          options = field.meta;\n        }\n      }\n\n      if (field === undefined) return undefined;\n      let name = field_mapping ? field.field : field.name;\n      if (kt.alias !== undefined) name = kt.alias;\n      key.set(name, v);\n    }\n\n    if (key.size === 0) return undefined;\n    return resolve ? Objects.resolveKey(key) : Object.fromEntries(key);\n  }\n\n  resolveReferential(value, field, {\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    const referential = new Map();\n\n    for (let ref of field.referentials) {\n      let from = this.fields({\n        include_parents: true\n      }).find(p => p.field === ref.referencedProperty);\n      let to = field.options.fields({\n        include_parents: true\n      }).find(field => field.field === ref.property);\n\n      if (from !== undefined && to !== undefined) {\n        let name = field_mapping ? to.field : to.name;\n        referential.set(name, value && value[from.name]);\n      }\n    }\n\n    if (referential.size === 0) return undefined;\n    if (referential.size === 1 && Array.from(referential.values())[0] === null) return null;\n    return resolve ? Objects.resolveKey(referential, {\n      single: false\n    }) : Object.fromEntries(referential);\n  }\n\n  resolveReferenced(value, field, {\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    const referenced = new Map();\n\n    for (let ref of field.referentials) {\n      let from = this.fields({\n        include_parents: true\n      }).find(field => field.field === ref.property);\n      let to = field.meta.fields({\n        include_parents: true\n      }).find(field => field.field === ref.referencedProperty);\n\n      if (from !== undefined && to !== undefined) {\n        let name = field_mapping ? to.field : to.name;\n        referenced.set(name, value && value[from.name]);\n      }\n    }\n\n    if (referenced.size === 0) return undefined;\n    if (referenced.size === 1 && Array.from(referenced.values())[0] === null) return null;\n    return resolve ? Objects.resolveKey(referenced, {\n      single: false\n    }) : Object.fromEntries(referenced);\n  }\n\n  validate(self, {\n    method,\n    navigation = false\n  } = {}) {\n    const errors = this.fields({\n      include_parents: true,\n      include_navigation: navigation\n    }).reduce((acc, field) => {\n      let value = self[field.name];\n      let errs = field.validate(value, {\n        method\n      });\n      return errs !== undefined ? Object.assign(acc, {\n        [field.name]: errs\n      }) : acc;\n    }, {});\n    return !Types.isEmpty(errors) ? errors : undefined;\n  }\n\n  defaults() {\n    const defs = this.fields().reduce((acc, field) => {\n      let value = field.defaults();\n      return value !== undefined ? Object.assign(acc, {\n        [field.name]: value\n      }) : acc;\n    }, {});\n    return !Types.isEmpty(defs) ? defs : undefined;\n  }\n\n  hasChanged(self, {\n    include_navigation = false\n  } = {}) {\n    return self._changes.size != 0 || [...self._relations.values()].filter(({\n      field\n    }) => !field.navigation || include_navigation).some(({\n      field,\n      state,\n      model\n    }) => (!include_navigation || field.navigation) && (state === ODataModelState.Changed || model != undefined && model.hasChanged({\n      include_navigation\n    })));\n  }\n\n  asEntity(self, func) {\n    // Build new resource\n    const query = self.resource().cloneQuery();\n    let resource = this.modelResourceFactory(query);\n    if (resource === undefined) throw new Error('Model does not have associated Entity endpoint'); // Store parent and resource\n\n    const store = {\n      parent: self._parent,\n      resource: self._resource\n    }; // Replace parent and resource\n\n    self._parent = null;\n    self._resource = resource; // Execute function\n\n    const result = func(self);\n\n    if (result instanceof Observable) {\n      return result.pipe(finalize(() => {\n        // Restore parent and resource\n        self._parent = store.parent;\n        self._resource = store.resource;\n      }));\n    } else {\n      // Restore parent and resource\n      self._parent = store.parent;\n      self._resource = store.resource;\n      return result;\n    }\n  }\n\n  toEntity(self, {\n    client_id = false,\n    include_navigation = false,\n    include_concurrency = false,\n    include_computed = false,\n    include_key = true,\n    include_non_field = false,\n    changes_only = false,\n    field_mapping = false,\n    chain = []\n  } = {}) {\n    let attrs = self.attributes({\n      changes_only,\n      field_mapping,\n      include_concurrency,\n      include_computed,\n      include_non_field\n    });\n    let relations = [...self._relations.entries()].filter( // Chain\n    ([, {\n      model\n    }]) => chain.every(c => c !== model)).filter( // Changes only\n    ([, {\n      model,\n      state\n    }]) => !changes_only || changes_only && (state === ODataModelState.Changed || model != undefined && model.hasChanged({\n      include_navigation\n    }))).filter(([, {\n      field,\n      model\n    }]) => // Navigation\n    include_navigation && field.navigation && model !== null || !field.navigation).map(([k, {\n      model,\n      field,\n      state\n    }]) => {\n      let changesOnly = changes_only && state !== ODataModelState.Changed && !!field.navigation;\n      let includeKey = include_key && !!field.navigation;\n\n      if (ODataModelOptions.isModel(model)) {\n        return [k, model.toEntity({\n          client_id,\n          include_navigation,\n          include_concurrency,\n          include_non_field,\n          field_mapping,\n          changes_only: changesOnly,\n          include_key: includeKey,\n          chain: [self, ...chain]\n        })];\n      } else if (ODataModelOptions.isCollection(model)) {\n        return [k, model.toEntities({\n          client_id,\n          include_navigation,\n          include_concurrency,\n          include_non_field,\n          field_mapping,\n          changes_only: changesOnly,\n          include_key: includeKey,\n          chain: [self, ...chain]\n        })];\n      }\n\n      return [k, model];\n    }).reduce((acc, [k, v]) => {\n      var _a;\n\n      const name = field_mapping ? ((_a = this.fields().find(field => field.name === k)) === null || _a === void 0 ? void 0 : _a.field) || k : k;\n      return Object.assign(acc, {\n        [name]: v\n      });\n    }, {}); // Create entity\n\n    let entity = Object.assign(Object.assign({}, attrs), relations); // Add client_id\n\n    if (client_id) {\n      entity[this.cid] = self[this.cid];\n    } // Add key\n\n\n    if (include_key) {\n      entity = Object.assign(Object.assign({}, entity), this.resolveKey(self, {\n        field_mapping,\n        resolve: false\n      }));\n    } // Add type\n\n\n    if (self._parent !== null && (ODataModelOptions.isModel(self._parent[0]) && self._parent[1].meta !== self._meta || ODataModelOptions.isCollection(self._parent[0]) && self._parent[0]._model.meta !== self._meta)) {\n      entity[this.api.options.helper.ODATA_TYPE] = `#${this.schema.type()}`;\n    }\n\n    return entity;\n  }\n\n  attributes(self, {\n    changes_only = false,\n    include_concurrency = false,\n    include_computed = false,\n    include_non_field = false,\n    field_mapping = false\n  } = {}) {\n    // Attributes by fields (attributes for the model type)\n    const fieldAttrs = this.fields().reduce((acc, f) => {\n      const isChanged = self._changes.has(f.name);\n\n      const name = field_mapping ? f.field : f.name;\n      const computed = f.annotatedValue(COMPUTED);\n      const value = isChanged ? self._changes.get(f.name) : self._attributes.get(f.name);\n\n      if (f.concurrency && include_concurrency) {\n        return Object.assign(acc, {\n          [name]: value\n        });\n      } else if (computed && include_computed) {\n        return Object.assign(acc, {\n          [name]: value\n        });\n      } else if (changes_only && isChanged) {\n        return Object.assign(acc, {\n          [name]: value\n        });\n      } else if (!changes_only && !f.concurrency && !computed) {\n        return Object.assign(acc, {\n          [name]: value\n        });\n      } else {\n        return acc;\n      }\n    }, {});\n    if (!include_non_field) return fieldAttrs;\n    const names = Object.keys(fieldAttrs); // Attributes from object (attributes for object)\n\n    const nonFieldAttrs = Object.entries(self).filter(([k]) => names.indexOf(k) === -1 && !k.startsWith('_') && !k.endsWith('$')).reduce((acc, [k, v]) => Object.assign(acc, {\n      [k]: v\n    }), {});\n    return Object.assign(Object.assign({}, fieldAttrs), nonFieldAttrs);\n  }\n\n  reset(self, {\n    name,\n    silent = false\n  } = {}) {\n    let changes = [];\n\n    if (name !== undefined) {\n      // Reset value\n      const value = self._attributes.get(name);\n\n      const change = self._changes.get(name);\n\n      if (value !== change) changes = [name];\n\n      self._relations.delete(name);\n\n      self._changes.delete(name);\n    } else {\n      // reset all\n      changes = [...self._changes.keys()];\n\n      self._relations.clear();\n\n      self._changes.clear();\n    }\n\n    if (!silent && changes.length > 0) {\n      self.events$.emit(new ODataModelEvent('reset', {\n        model: self,\n        options: {\n          changes\n        }\n      }));\n    }\n  }\n\n  assign(self, entity, {\n    reset = false,\n    reparent = false,\n    silent = false\n  } = {}) {\n    self._reset = reset;\n    self._reparent = reparent;\n    self._silent = silent;\n    const changes = []; // Apply entity\n\n    const model = self;\n    Object.entries(entity).filter(([, value]) => value !== undefined) // Filter undefined\n    .forEach(([key, value]) => {\n      const field = this.fields({\n        include_parents: true,\n        include_navigation: true\n      }).find(field => self._reset && field.field === key || field.name === key);\n\n      if (field !== undefined) {\n        // Delegated to private setter\n        if (this._set(self, field, value)) {\n          changes.push(field.name);\n        }\n      } else {\n        // Basic assignment\n        const current = model[key];\n        model[key] = value;\n        if (current !== value) changes.push(key);\n      }\n    });\n\n    if (!self._silent && changes.length > 0 || self._reset) {\n      self.events$.emit(new ODataModelEvent(self._reset ? 'reset' : 'update', {\n        model: self,\n        options: {\n          changes\n        }\n      }));\n    }\n\n    self._reset = false;\n    self._reparent = false;\n    self._silent = false;\n  }\n\n  static isModel(obj) {\n    return Types.rawType(obj) === 'Model';\n  }\n\n  static isCollection(obj) {\n    return Types.rawType(obj) === 'Collection';\n  }\n\n  updateCollection(self, field, collection, value) {\n    collection._annotations = field.annotationsFactory(self.annots());\n    collection.assign(value, {\n      reset: self._reset,\n      reparent: self._reparent,\n      silent: self._silent\n    });\n    return collection.hasChanged();\n  }\n\n  updateModel(self, field, model, value) {\n    model._annotations = field.annotationsFactory(self.annots());\n    model.assign(value, {\n      reset: self._reset,\n      reparent: self._reparent,\n      silent: self._silent\n    });\n    return model.hasChanged();\n  }\n\n  _get(self, field) {\n    if (field.isStructuredType()) {\n      const relation = self._relations.get(field.name);\n\n      if ((relation === null || relation === void 0 ? void 0 : relation.model) === null || ODataModelOptions.isModel(relation === null || relation === void 0 ? void 0 : relation.model)) {\n        // Check for reference\n        const referenced = this.resolveReferenced(self, field);\n\n        if ((relation === null || relation === void 0 ? void 0 : relation.model) !== null && referenced !== null && referenced !== undefined) {\n          relation.model.assign(referenced, {\n            silent: true\n          });\n        } else if ((relation === null || relation === void 0 ? void 0 : relation.model) !== null && referenced === null) {\n          this._unlink(self, relation); // New value is null\n\n\n          relation.model = null;\n        } else if ((relation === null || relation === void 0 ? void 0 : relation.model) === null && referenced !== null) {\n          // New value is undefined\n          relation.model = undefined;\n        }\n      }\n\n      return relation === null || relation === void 0 ? void 0 : relation.model;\n    } else {\n      return this.attributes(self, {\n        include_concurrency: true,\n        include_computed: true\n      })[field.name];\n    }\n  }\n\n  _setStructured(self, field, value) {\n    var _a;\n\n    let changed = false; // Ensures that the relation exists\n\n    if (!self._relations.has(field.name)) {\n      self._relations.set(field.name, {\n        state: ODataModelState.Unchanged,\n        field: field\n      });\n    }\n\n    const relation = self._relations.get(field.name);\n\n    const current = relation.model;\n\n    if (value === null) {\n      // Unlink old relation\n      this._unlink(self, relation); // New value is null\n\n\n      relation.model = value;\n      changed = current !== value;\n    } else if (ODataModelOptions.isCollection(current)) {\n      // Current is collection\n      let currentCollection = current;\n\n      if (ODataModelOptions.isCollection(value)) {\n        // New value is collection\n        let newCollection = value;\n\n        if (currentCollection.equals(newCollection)) {\n          changed = false;\n        } else {\n          // Unlink old collection\n          this._unlink(self, relation);\n\n          relation.model = newCollection; // Link new collection\n\n          this._link(self, relation);\n\n          changed = true;\n        }\n      } else if (Types.isArray(value)) {\n        // New value is array\n        changed = this.updateCollection(self, field, currentCollection, value);\n      }\n    } else if (ODataModelOptions.isModel(current)) {\n      // Current is model\n      let currentModel = current;\n\n      if (ODataModelOptions.isModel(value)) {\n        // New value is model\n        let newModel = value;\n\n        if (currentModel.equals(newModel)) {\n          changed = false;\n        } else {\n          // Unlink old model\n          this._unlink(self, relation);\n\n          relation.model = newModel; // Link new model\n\n          this._link(self, relation);\n\n          changed = true;\n        }\n      } else if (Types.isPlainObject(value)) {\n        changed = this.updateModel(self, field, currentModel, value);\n      }\n    } else {\n      // Current is null or undefined\n      // create new model/collection for given value\n      relation.model = ODataModelOptions.isCollection(value) || ODataModelOptions.isModel(value) ? value : field.modelCollectionFactory({\n        parent: self,\n        value: value,\n        reset: self._reset\n      }); // Link new model/collection\n\n      this._link(self, relation);\n\n      changed = true;\n    } // Resolve referentials\n\n\n    if (!ODataModelOptions.isCollection(relation.model)) {\n      let ref = (_a = field.meta) === null || _a === void 0 ? void 0 : _a.resolveReferential(relation.model, field);\n\n      if (ref !== null && ref !== undefined) {\n        Object.assign(self, ref);\n      }\n    } // Update state and emit event\n\n\n    relation.state = self._reset || !changed ? ODataModelState.Unchanged : ODataModelState.Changed;\n\n    if (!self._silent && changed) {\n      self.events$.emit(new ODataModelEvent('change', {\n        field: field,\n        model: self,\n        value: relation.model,\n        previous: current\n      }));\n    }\n\n    return changed;\n  }\n\n  _setValue(self, field, value, key) {\n    let changed = false;\n    const attrs = this.attributes(self, {\n      include_concurrency: true,\n      include_computed: true\n    });\n    const name = field.name;\n    const currentValue = attrs[name];\n    changed = !Types.isEqual(currentValue, value);\n\n    if (self._reset) {\n      self._changes.delete(name);\n\n      self._attributes.set(name, value);\n    } else if (Types.isEqual(value, self._attributes.get(name))) {\n      self._changes.delete(name);\n    } else if (changed) {\n      self._changes.set(name, value);\n    }\n\n    if (!self._silent && changed) {\n      self.events$.emit(new ODataModelEvent('change', {\n        field: field,\n        model: self,\n        value,\n        previous: currentValue,\n        options: {\n          key\n        }\n      }));\n    }\n\n    return changed;\n  }\n\n  _set(self, field, value) {\n    return field.isStructuredType() ? this._setStructured(self, field, value) : this._setValue(self, field, value, field.isKey());\n  }\n\n  _unlink(self, relation) {\n    if (relation.subscription !== undefined) {\n      relation.subscription.unsubscribe();\n      relation.subscription = undefined;\n    }\n\n    if (relation.model != null) {\n      relation.model._parent = null;\n    }\n  }\n\n  _link(self, relation) {\n    if (relation.subscription) {\n      throw new Error('Subscription already exists');\n    }\n\n    if (relation.model == null) {\n      throw new Error('Subscription model is null');\n    }\n\n    if (self._reparent) relation.model._parent = [self, relation.field];\n    relation.subscription = relation.model.events$.subscribe(event => {\n      var _a;\n\n      if (BUBBLING.indexOf(event.name) !== -1 && event.bubbling && !event.visited(self)) {\n        if (event.model === relation.model) {\n          if (event.name === 'change' && relation.field.navigation && ((_a = event.options) === null || _a === void 0 ? void 0 : _a.key)) {\n            let ref = relation.model.referential(relation.field);\n\n            if (ref !== null && ref !== undefined) {\n              Object.assign(self, ref);\n            }\n          }\n        }\n\n        self.events$.emit(event.push(self, relation.field));\n      }\n    });\n  }\n\n}\n\nlet ODataCollection = /*#__PURE__*/(() => {\n  class ODataCollection {\n    constructor(entities = [], {\n      parent,\n      resource,\n      annots,\n      model,\n      reset = false\n    } = {}) {\n      this._parent = null;\n      this._resource = null;\n      this._entries = []; //Events\n\n      this.events$ = new EventEmitter();\n      this._sortBy = null;\n      const Klass = this.constructor;\n      if (model === undefined && Klass.model !== null) model = Klass.model;\n      if (model === undefined) throw new Error('Collection: Collection need model');\n      this._model = model; // Parent\n\n      if (parent !== undefined) {\n        this._parent = parent;\n      } // Resource\n\n\n      if (this._parent === null && resource === undefined) resource = this._model.meta.collectionResourceFactory();\n\n      if (resource !== undefined) {\n        this.attach(resource);\n      } // Annotations\n\n\n      this._annotations = annots || new ODataEntitiesAnnotations((resource === null || resource === void 0 ? void 0 : resource.api.options.helper) || ODataHelper[DEFAULT_VERSION]);\n      entities = entities || [];\n      this.assign(entities, {\n        reset\n      });\n    }\n\n    models() {\n      return this._entries.filter(e => e.state !== ODataModelState.Removed).map(e => e.model);\n    }\n\n    get length() {\n      return this.models().length;\n    }\n\n    isParentOf(child) {\n      return child !== this && ODataModelOptions.chain(child).some(p => p[0] === this);\n    }\n\n    resource() {\n      return ODataModelOptions.resource(this);\n    }\n\n    attach(resource) {\n      if (this._resource !== null && this._resource.type() !== resource.type() && !this._resource.isSubtypeOf(resource)) throw new Error(`attach: Can't reattach ${this._resource.type()} to ${resource.type()}`);\n\n      this._entries.forEach(({\n        model\n      }) => {\n        const mr = this._model.meta.modelResourceFactory(resource.cloneQuery());\n\n        model.attach(mr);\n      });\n\n      const current = this._resource;\n\n      if (current === null || !current.isEqualTo(resource)) {\n        this._resource = resource;\n        this.events$.emit(new ODataModelEvent('attach', {\n          collection: this,\n          previous: current,\n          value: resource\n        }));\n      }\n    }\n\n    asEntitySet(func) {\n      // Build new resource\n      const query = this.resource().cloneQuery();\n\n      let resource = this._model.meta.collectionResourceFactory(query);\n\n      if (resource === undefined) throw new Error('asEntitySet: Collection does not have associated EntitySet endpoint'); // Store parent and resource\n\n      const store = {\n        parent: this._parent,\n        resource: this._resource\n      }; // Replace parent and resource\n\n      this._parent = null;\n      this._resource = resource; // Execute\n\n      const result = func(this);\n\n      if (result instanceof Observable) {\n        return result.pipe(finalize(() => {\n          // Restore\n          this._parent = store.parent;\n          this._resource = store.resource;\n        }));\n      } else {\n        // Restore\n        this._parent = store.parent;\n        this._resource = store.resource;\n        return result;\n      }\n    }\n\n    annots() {\n      return this._annotations;\n    }\n\n    modelFactory(data, {\n      reset = false\n    } = {}) {\n      var _a;\n\n      let Model = this._model;\n      const helper = this._annotations.helper;\n      const annots = new ODataEntityAnnotations(helper, helper.annotations(data));\n\n      if ((annots === null || annots === void 0 ? void 0 : annots.type) !== undefined && Model.meta !== null) {\n        let schema = (_a = Model.meta.findChildOptions(o => o.isTypeOf(annots.type))) === null || _a === void 0 ? void 0 : _a.schema;\n        if (schema !== undefined && schema.model !== undefined) // Change to child model\n          Model = schema.model;\n      }\n\n      return new Model(data, {\n        annots,\n        reset,\n        parent: [this, null]\n      });\n    }\n\n    toEntities({\n      client_id = false,\n      include_navigation = false,\n      include_concurrency = false,\n      include_computed = false,\n      include_key = true,\n      include_non_field = false,\n      changes_only = false,\n      field_mapping = false,\n      chain = []\n    } = {}) {\n      return this._entries.filter(({\n        model,\n        state\n      }) => state !== ODataModelState.Removed && chain.every(c => c !== model)).map(({\n        model,\n        state\n      }) => {\n        var changesOnly = changes_only && state !== ODataModelState.Added;\n        return model.toEntity({\n          client_id,\n          include_navigation,\n          include_concurrency,\n          include_computed,\n          include_key,\n          include_non_field,\n          field_mapping,\n          changes_only: changesOnly,\n          chain: [this, ...chain]\n        });\n      });\n    }\n\n    toJSON() {\n      return this.toEntities();\n    }\n\n    hasChanged({\n      include_navigation\n    } = {}) {\n      return this._entries.some(e => e.state !== ODataModelState.Unchanged) || this.models().some(m => m.hasChanged({\n        include_navigation\n      }));\n    }\n\n    clone() {\n      let Ctor = this.constructor;\n      return new Ctor(this.toEntities(INCLUDE_SHALLOW), {\n        resource: this.resource(),\n        annots: this.annots()\n      });\n    }\n\n    fetch(_a = {}) {\n      var {\n        withCount\n      } = _a,\n          options = __rest(_a, [\"withCount\"]);\n\n      const resource = this.resource();\n      const obs$ = resource instanceof ODataEntitySetResource ? resource.fetch(Object.assign({\n        withCount\n      }, options)) : resource.fetch(Object.assign({\n        responseType: 'entities',\n        withCount\n      }, options));\n      this.events$.emit(new ODataModelEvent('request', {\n        collection: this,\n        value: obs$\n      }));\n      return obs$.pipe(map(({\n        entities,\n        annots\n      }) => {\n        this._annotations = annots;\n        this.assign(entities || [], {\n          reset: true\n        });\n        this.events$.emit(new ODataModelEvent('sync', {\n          collection: this\n        }));\n        return this;\n      }));\n    }\n\n    fetchAll(options) {\n      const resource = this.resource();\n      if (resource instanceof ODataPropertyResource) return throwError(() => new Error('fetchAll: Resource is ODataPropertyResource'));\n      const obs$ = resource.fetchAll(options);\n      this.events$.emit(new ODataModelEvent('request', {\n        collection: this,\n        options: {\n          observable: obs$\n        }\n      }));\n      return obs$.pipe(map(entities => {\n        this._annotations = new ODataEntitiesAnnotations(resource === null || resource === void 0 ? void 0 : resource.api.options.helper);\n        this.assign(entities || [], {\n          reset: true\n        });\n        this.events$.emit(new ODataModelEvent('sync', {\n          collection: this,\n          options: {\n            entities\n          }\n        }));\n        return this;\n      }));\n    }\n    /**\n     * Save all models in the collection\n     * @param relModel The model is relationship\n     * @param method The method to use\n     * @param options HttpOptions\n     */\n\n\n    save(_a = {}) {\n      var {\n        relModel = false,\n        method\n      } = _a,\n          options = __rest(_a, [\"relModel\", \"method\"]);\n\n      const resource = this.resource();\n      if (resource instanceof ODataPropertyResource) return throwError(() => new Error('save: Resource is ODataPropertyResource'));\n      let toDestroyEntity = [];\n      let toRemoveReference = [];\n      let toDestroyContained = [];\n      let toCreateEntity = [];\n      let toAddReference = [];\n      let toCreateContained = [];\n      let toUpdateEntity = [];\n      let toUpdateContained = [];\n\n      this._entries.forEach(({\n        model,\n        state\n      }) => {\n        if (state === ODataModelState.Removed) {\n          if (relModel) {\n            toDestroyEntity.push(model);\n          } else if (!model.isNew()) {\n            toRemoveReference.push(model);\n          } else {\n            toDestroyContained.push(model);\n          }\n        } else if (state === ODataModelState.Added) {\n          if (relModel) {\n            toCreateEntity.push(model);\n          } else if (!model.isNew()) {\n            toAddReference.push(model);\n          } else {\n            toCreateContained.push(model);\n          }\n        } else if (model.hasChanged()) {\n          toUpdateEntity.push(model);\n        }\n      });\n\n      if (toDestroyEntity.length > 0 || toRemoveReference.length > 0 || toDestroyContained.length > 0 || toCreateEntity.length > 0 || toAddReference.length > 0 || toCreateContained.length > 0 || toUpdateEntity.length > 0 || toUpdateContained.length > 0) {\n        const obs$ = forkJoin([...toDestroyEntity.map(m => m.asEntity(e => e.destroy(options))), ...toRemoveReference.map(m => this.removeReference(m, options)), ...toDestroyContained.map(m => m.destroy(options)), ...toCreateEntity.map(m => m.asEntity(e => e.save(Object.assign({\n          method: 'create'\n        }, options)))), ...toAddReference.map(m => this.addReference(m, options)), ...toCreateContained.map(m => m.save(Object.assign({\n          method: 'create'\n        }, options))), ...toUpdateEntity.map(m => m.asEntity(e => e.save(Object.assign({\n          method\n        }, options)))), ...toUpdateContained.map(m => m.save(Object.assign({\n          method\n        }, options)))]);\n        this.events$.emit(new ODataModelEvent('request', {\n          collection: this,\n          options: {\n            observable: obs$\n          }\n        }));\n        return obs$.pipe(map(() => {\n          this._entries = this._entries.filter(entry => entry.state !== ODataModelState.Removed).map(entry => Object.assign(Object.assign({}, entry), {\n            state: ODataModelState.Unchanged\n          }));\n          this.events$.emit(new ODataModelEvent('sync', {\n            collection: this\n          }));\n          return this;\n        }));\n      }\n\n      return of(this);\n    }\n\n    addReference(model, options) {\n      const resource = this.resource();\n\n      if (!model.isNew() && resource instanceof ODataNavigationPropertyResource) {\n        return resource.reference().add(model._meta.entityResource(model), options).pipe(map(() => model));\n      }\n\n      return of(model);\n    }\n\n    _addModel(model, {\n      silent = false,\n      reset = false,\n      reparent = false,\n      merge = false,\n      position = -1\n    } = {}) {\n      const key = model.key();\n\n      let entry = this._findEntry({\n        model,\n        key,\n        cid: model[this._model.meta.cid]\n      });\n\n      if (entry !== undefined && entry.state !== ODataModelState.Removed) {\n        if (merge) {\n          entry.model.assign(model.toEntity());\n        }\n\n        return entry.model;\n      }\n\n      if (entry !== undefined && entry.state === ODataModelState.Removed) {\n        const index = this._entries.indexOf(entry);\n\n        this._entries.splice(index, 1);\n      } // Create Entry\n\n\n      entry = {\n        state: reset ? ODataModelState.Unchanged : ODataModelState.Added,\n        model,\n        key: model.key()\n      }; // Set Parent\n\n      if (reparent) model._parent = [this, null]; // Subscribe\n\n      this._link(entry); // Now add\n\n\n      if (position >= 0) this._entries.splice(position, 0, entry);else this._entries.push(entry);\n\n      if (!silent) {\n        model.events$.emit(new ODataModelEvent('add', {\n          model,\n          collection: this\n        }));\n      }\n\n      return entry.model;\n    }\n\n    addModel(model, {\n      silent = false,\n      reset = false,\n      reparent = false,\n      merge = false,\n      position = -1\n    } = {}) {\n      if (position < 0) position = this._bisect(model);\n\n      const added = this._addModel(model, {\n        silent,\n        reset,\n        merge,\n        position,\n        reparent\n      });\n\n      if (!silent && added !== undefined) {\n        this.events$.emit(new ODataModelEvent('update', {\n          collection: this,\n          options: {\n            added: [added],\n            removed: [],\n            merged: []\n          }\n        }));\n      }\n\n      return added;\n    }\n\n    add(model, {\n      silent = false,\n      reparent = false,\n      server = true,\n      merge = false,\n      position = -1\n    } = {}) {\n      if (server) {\n        return this.addReference(model).pipe(map(model => {\n          return this.addModel(model, {\n            silent,\n            position,\n            reparent,\n            merge,\n            reset: true\n          });\n        }));\n      } else {\n        return of(this.addModel(model, {\n          silent,\n          position,\n          merge,\n          reparent\n        }));\n      }\n    }\n\n    removeReference(model, options) {\n      let resource = this.resource();\n\n      if (!model.isNew() && resource instanceof ODataNavigationPropertyResource) {\n        let target = this._model.meta.api.options.deleteRefBy === 'id' ? model._meta.entityResource(model) : undefined;\n\n        if (this._model.meta.api.options.deleteRefBy === 'path') {\n          resource = resource.key(model.key());\n        }\n\n        return resource.reference().remove(target, options).pipe(map(() => model));\n      }\n\n      return of(model);\n    }\n\n    _removeModel(model, {\n      silent = false,\n      reset = false\n    } = {}) {\n      const key = model.key();\n\n      let entry = this._findEntry({\n        model,\n        key,\n        cid: model[this._model.meta.cid]\n      });\n\n      if (entry === undefined || entry.state === ODataModelState.Removed) {\n        return model;\n      } // Emit Event\n\n\n      if (!silent) model.events$.emit(new ODataModelEvent('remove', {\n        model,\n        collection: this\n      })); // Now remove\n\n      const index = this._entries.indexOf(entry);\n\n      this._entries.splice(index, 1);\n\n      if (!(reset || entry.state === ODataModelState.Added)) {\n        // Move to end of array and mark as removed\n        entry.state = ODataModelState.Removed;\n\n        this._entries.push(entry);\n      }\n\n      this._unlink(entry);\n\n      return entry.model;\n    }\n\n    removeModel(model, {\n      silent = false,\n      reset = false\n    } = {}) {\n      const removed = this._removeModel(model, {\n        silent,\n        reset\n      });\n\n      if (!silent && removed !== undefined) {\n        this.events$.emit(new ODataModelEvent('update', {\n          collection: this,\n          options: {\n            added: [],\n            removed: [removed],\n            merged: []\n          }\n        }));\n      }\n\n      return removed;\n    }\n\n    remove(model, {\n      silent = false,\n      server = true\n    } = {}) {\n      if (server) {\n        return this.removeReference(model).pipe(map(model => this.removeModel(model, {\n          silent,\n          reset: true\n        })));\n      } else {\n        return of(this.removeModel(model, {\n          silent\n        }));\n      }\n    }\n\n    create(attrs = {}, {\n      silent = false,\n      server = true\n    } = {}) {\n      const model = this.modelFactory(attrs);\n      return (model.isValid() && server ? model.save() : of(model)).pipe(switchMap(model => this.add(model, {\n        silent,\n        server\n      })), map(() => model));\n    }\n\n    set(path, value) {\n      const Model = this._model;\n      const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n      if (pathArray.length === 0) return undefined;\n\n      if (pathArray.length > 1) {\n        const model = this._entries[Number(pathArray[0])].model;\n\n        return model.set(pathArray.slice(1), value);\n      }\n\n      if (pathArray.length === 1 && ODataModelOptions.isModel(value)) {\n        let toAdd = [];\n        let toChange = [];\n        let toRemove = [];\n        let index = Number(pathArray[0]);\n        const model = this.models()[index];\n\n        const entry = this._findEntry({\n          model\n        });\n\n        if (entry !== undefined) {\n          //TODO: Remove/Add or Merge?\n          // Merge\n          entry.model.assign(value.toEntity(Object.assign({\n            client_id: true\n          }, INCLUDE_DEEP)));\n          if (entry.model.hasChanged()) toChange.push(model);\n        } else {\n          // Add\n          this._addModel(value, {\n            reparent: true\n          });\n\n          toAdd.push(model);\n        }\n\n        this.events$.emit(new ODataModelEvent('update', {\n          collection: this,\n          options: {\n            added: toAdd,\n            removed: toRemove,\n            changed: toChange\n          }\n        }));\n        return value;\n      }\n    }\n\n    get(path) {\n      const Model = this._model;\n      const pathArray = Types.isArray(path) ? path : `${path}`.match(/([^[.\\]])+/g);\n      if (pathArray.length === 0) return undefined;\n      const value = this.models()[Number(pathArray[0])];\n\n      if (pathArray.length > 1 && ODataModelOptions.isModel(value)) {\n        return value.get(pathArray.slice(1));\n      }\n\n      return value;\n    }\n\n    reset({\n      path,\n      silent = false\n    } = {}) {\n      let toAdd = [];\n      let toChange = [];\n      let toRemove = [];\n\n      if (path !== undefined) {\n        // Reset by path\n        const pathArray = Types.isArray(path) ? path : `${path}`.match(/([^[.\\]])+/g);\n        const index = Number(pathArray[0]);\n\n        if (!Number.isNaN(index)) {\n          const model = this.models()[index];\n\n          if (ODataModelOptions.isModel(model)) {\n            const entry = this._findEntry({\n              model\n            });\n\n            if (entry.state === ODataModelState.Changed || entry.state === ODataModelState.Unchanged && entry.model.hasChanged()) {\n              toChange = [entry];\n            }\n\n            path = pathArray.slice(1);\n          }\n        }\n      } else {\n        // Reset all\n        toAdd = this._entries.filter(e => e.state === ODataModelState.Removed);\n        toChange = this._entries.filter(e => e.state === ODataModelState.Changed || e.state === ODataModelState.Unchanged && e.model.hasChanged());\n        toRemove = this._entries.filter(e => e.state === ODataModelState.Added);\n      }\n\n      toRemove.forEach(entry => {\n        this._removeModel(entry.model, {\n          silent\n        });\n      });\n      toAdd.forEach(entry => {\n        this._addModel(entry.model, {\n          silent\n        });\n      });\n      toChange.forEach(entry => {\n        entry.model.reset({\n          path,\n          silent\n        });\n        entry.state = ODataModelState.Unchanged;\n      });\n\n      if (!silent && (toAdd.length > 0 || toRemove.length > 0 || toChange.length > 0)) {\n        this.events$.emit(new ODataModelEvent('reset', {\n          collection: this,\n          options: {\n            added: toAdd.map(e => e.model),\n            removed: toRemove.map(e => e.model),\n            changed: toChange.map(e => e.model)\n          }\n        }));\n      }\n    }\n\n    clear({\n      silent = false\n    } = {}) {\n      let toRemove = this.models();\n      toRemove.forEach(m => {\n        this._removeModel(m, {\n          silent\n        });\n      });\n      this._entries = [];\n\n      if (!silent) {\n        this.events$.emit(new ODataModelEvent('update', {\n          collection: this,\n          options: {\n            removed: toRemove\n          }\n        }));\n      }\n    }\n\n    assign(objects, {\n      reset = false,\n      reparent = false,\n      silent = false\n    } = {}) {\n      const Model = this._model;\n      let toAdd = [];\n      let toChange = [];\n      let toRemove = [];\n      let toSort = [];\n      let modelMap = [];\n      objects.forEach((obj, index) => {\n        const isModel = ODataModelOptions.isModel(obj);\n        const key = Model !== null && Model.meta ? Model.meta.resolveKey(obj) : undefined;\n        const cid = Model.meta.cid in obj ? obj[Model.meta.cid] : undefined; // Try find entry\n\n        const entry = isModel ? this._findEntry({\n          model: obj\n        }) // By Model\n        : this._findEntry({\n          cid,\n          key\n        }); // By Cid or Key\n\n        let model;\n\n        if (entry !== undefined) {\n          // Merge\n          model = entry.model;\n\n          if (model !== obj) {\n            // Get entity from model\n            if (isModel) {\n              const entity = obj.toEntity(Object.assign({\n                client_id: true\n              }, INCLUDE_DEEP));\n              model.assign(entity, {\n                reset,\n                silent\n              });\n            } else {\n              const helper = this._annotations.helper;\n              const annots = new ODataEntityAnnotations(helper, helper.annotations(obj));\n              const entity = annots.attributes(obj, 'full');\n              model._annotations = annots;\n              model.assign(entity, {\n                reset,\n                silent\n              });\n            } // Model Change?\n\n\n            if (model.hasChanged()) toChange.push(model);\n          } // Has Sort or Index Change?\n\n\n          if (toSort.length > 0 || index !== this.models().indexOf(model)) {\n            toSort.push([model, index]);\n          }\n        } else {\n          // Add\n          model = isModel ? obj : this.modelFactory(obj, {\n            reset\n          });\n          toAdd.push([model, index]);\n        }\n\n        modelMap.push(model[Model.meta.cid]);\n      });\n\n      this._entries.filter(e => modelMap.indexOf(e.model[Model.meta.cid]) === -1).forEach(entry => {\n        toRemove.push(entry.model);\n      });\n\n      toRemove.forEach(m => {\n        this._removeModel(m, {\n          silent,\n          reset\n        });\n      });\n      toAdd.forEach(m => {\n        this._addModel(m[0], {\n          silent,\n          reset,\n          reparent,\n          position: m[1]\n        });\n      });\n      toSort.forEach(m => {\n        this._removeModel(m[0], {\n          silent: true,\n          reset\n        });\n\n        this._addModel(m[0], {\n          silent: true,\n          reset,\n          position: m[1],\n          reparent\n        });\n      });\n\n      if (!silent && (toAdd.length > 0 || toRemove.length > 0 || toChange.length > 0 || toSort.length > 0) || reset) {\n        this._sortBy = null;\n        this.events$.emit(new ODataModelEvent(reset ? 'reset' : 'update', {\n          collection: this,\n          options: {\n            added: toAdd,\n            removed: toRemove,\n            changed: toChange,\n            sorted: toSort\n          }\n        }));\n      }\n    }\n\n    query(func) {\n      const resource = this.resource();\n      resource.query(func);\n      this.attach(resource);\n      return this;\n    }\n\n    callFunction(name, params, responseType, _a = {}) {\n      var options = __rest(_a, []);\n\n      const resource = this.resource();\n\n      if (resource instanceof ODataEntitySetResource) {\n        const func = resource.function(name);\n        func.query(q => q.apply(options));\n\n        switch (responseType) {\n          case 'property':\n            return func.callProperty(params, options);\n\n          case 'model':\n            return func.callModel(params, options);\n\n          case 'collection':\n            return func.callCollection(params, options);\n\n          default:\n            return func.call(params, Object.assign({\n              responseType\n            }, options));\n        }\n      }\n\n      return throwError(() => new Error(`callFunction: Can't function without ODataEntitySetResource`));\n    }\n\n    callAction(name, params, responseType, _a = {}) {\n      var options = __rest(_a, []);\n\n      const resource = this.resource();\n\n      if (!(resource instanceof ODataEntitySetResource)) {\n        return throwError(() => new Error(`callAction: Can't action without ODataEntitySetResource`));\n      }\n\n      const action = resource.action(name);\n      action.query(q => q.apply(options));\n\n      switch (responseType) {\n        case 'property':\n          return action.callProperty(params, options);\n\n        case 'model':\n          return action.callModel(params, options);\n\n        case 'collection':\n          return action.callCollection(params, options);\n\n        default:\n          return action.call(params, Object.assign({\n            responseType\n          }, options));\n      }\n    }\n\n    _unlink(entry) {\n      if (entry.subscription) {\n        entry.subscription.unsubscribe();\n        entry.subscription = undefined;\n      }\n    }\n\n    _link(entry) {\n      if (entry.subscription) {\n        throw new Error('Collection: Subscription already exists');\n      }\n\n      entry.subscription = entry.model.events$.subscribe(event => {\n        var _a;\n\n        if (BUBBLING.indexOf(event.name) !== -1 && event.bubbling && !event.visited(this)) {\n          if (event.model === entry.model) {\n            if (event.name === 'destroy') {\n              this.removeModel(entry.model, {\n                reset: true\n              });\n            } else if (event.name === 'change' && ((_a = event.options) === null || _a === void 0 ? void 0 : _a.key)) {\n              entry.key = entry.model.key();\n            }\n          }\n\n          const index = this.models().indexOf(entry.model);\n          this.events$.emit(event.push(this, index));\n        }\n      });\n    }\n\n    _findEntry({\n      model,\n      cid,\n      key\n    } = {}) {\n      return this._entries.find(entry => {\n        const byModel = model !== undefined && entry.model.equals(model);\n        const byCid = cid !== undefined && entry.model[this._model.meta.cid] === cid;\n        const byKey = key !== undefined && entry.key !== undefined && Types.isEqual(entry.key, key);\n        return byModel || byCid || byKey;\n      });\n    } // Collection functions\n\n\n    equals(other) {\n      return this === other;\n    }\n\n    get [Symbol.toStringTag]() {\n      return 'Collection';\n    }\n\n    [Symbol.iterator]() {\n      let pointer = 0;\n      let models = this.models();\n      return {\n        next() {\n          return {\n            done: pointer === models.length,\n            value: models[pointer++]\n          };\n        }\n\n      };\n    }\n\n    filter(predicate, thisArg) {\n      return this.models().filter(predicate);\n    }\n\n    map(callbackfn, thisArg) {\n      return this.models().map(callbackfn, thisArg);\n    }\n\n    find(predicate, thisArg) {\n      return this.models().find(predicate);\n    }\n\n    reduce(callbackfn, initialValue) {\n      return this.models().reduce(callbackfn, initialValue);\n    }\n\n    first() {\n      return this.models()[0];\n    }\n\n    last() {\n      const models = this.models();\n      return models[models.length - 1];\n    }\n\n    next(model) {\n      const index = this.indexOf(model);\n\n      if (index === -1 || index === this.length - 1) {\n        return undefined;\n      }\n\n      return this.get(index + 1);\n    }\n\n    prev(model) {\n      const index = this.indexOf(model);\n\n      if (index <= 0) {\n        return undefined;\n      }\n\n      return this.get(index - 1);\n    }\n\n    every(predicate) {\n      return this.models().every(predicate);\n    }\n\n    some(predicate) {\n      return this.models().some(predicate);\n    }\n\n    contains(model) {\n      return this.some(m => m.equals(model));\n    }\n\n    indexOf(model) {\n      const models = this.models();\n      const m = models.find(m => m.equals(model));\n      return m === undefined ? -1 : models.indexOf(m);\n    } //#region Sort\n\n\n    _bisect(model) {\n      let index = -1;\n\n      if (this._sortBy !== null) {\n        for (index = 0; index < this._entries.length; index++) {\n          if (this._compare(model, this._entries[index], this._sortBy, 0) < 0) {\n            return index;\n          }\n        }\n      }\n\n      return index;\n    }\n\n    _compare(e1, e2, by, index) {\n      let m1 = ODataModelOptions.isModel(e1) ? e1 : e1.model;\n      let m2 = ODataModelOptions.isModel(e2) ? e2 : e2.model;\n      let value1 = m1.get(by[index].field);\n      let value2 = m2.get(by[index].field);\n      let result = 0;\n      if (value1 == null && value2 != null) result = -1;else if (value1 != null && value2 == null) result = 1;else if (value1 == null && value2 == null) result = 0;else if (typeof value1 == 'string' || value1 instanceof String) {\n        if (value1.localeCompare && value1 != value2) {\n          return (by[index].order || 1) * value1.localeCompare(value2);\n        }\n      } else {\n        result = value1 < value2 ? -1 : 1;\n      }\n\n      if (value1 == value2) {\n        return by.length - 1 > index ? this._compare(e1, e2, by, index + 1) : 0;\n      }\n\n      return (by[index].order || 1) * result;\n    }\n\n    isSorted() {\n      return this._sortBy !== null;\n    }\n\n    sort(by, {\n      silent\n    } = {}) {\n      this._sortBy = by;\n      this._entries = this._entries.sort((e1, e2) => this._compare(e1, e2, by, 0));\n\n      if (!silent) {\n        this.events$.emit(new ODataModelEvent('update', {\n          collection: this\n        }));\n      }\n    }\n\n  }\n\n  ODataCollection.model = null; // @dynamic\n\n  return ODataCollection;\n})();\n\nclass ODataModel {\n  constructor(data = {}, {\n    parent,\n    resource,\n    annots,\n    reset = false\n  } = {}) {\n    // Parent\n    this._parent = null;\n    this._attributes = new Map();\n    this._changes = new Map();\n    this._relations = new Map();\n    this._resource = null;\n    this._reset = false;\n    this._reparent = false;\n    this._silent = false; // Events\n\n    this.events$ = new EventEmitter();\n    const Klass = this.constructor;\n    if (Klass.meta === undefined) throw new Error(`ODataModel: Can't create model without metadata`);\n    this._meta = Klass.meta;\n\n    this._meta.bind(this, {\n      parent,\n      resource,\n      annots\n    }); // Client Id\n\n\n    this[this._meta.cid] = data[this._meta.cid] || Strings.uniqueId(`${Klass.meta.schema.name.toLowerCase()}-`);\n    let attrs = this.annots().attributes(data, 'full');\n    let defaults = this.defaults();\n    this.assign(Objects.merge(defaults, attrs), {\n      reset\n    });\n  }\n\n  static buildMeta({\n    options,\n    schema\n  }) {\n    if (options === undefined) {\n      let fields = schema.fields({\n        include_navigation: true,\n        include_parents: true\n      }).reduce((acc, f) => {\n        let name = f.name; // Prevent collision with reserved keywords\n\n        while (RESERVED_FIELD_NAMES.includes(name)) {\n          name = name + '_';\n        }\n\n        return Object.assign(acc, {\n          [name]: {\n            field: f.name,\n            default: f.default,\n            required: !f.nullable\n          }\n        });\n      }, {});\n      options = {\n        fields\n      };\n    }\n\n    this.meta = new ODataModelOptions({\n      options,\n      schema\n    });\n  } //#region Resources\n\n\n  resource() {\n    return ODataModelOptions.resource(this);\n  }\n\n  navigationProperty(name) {\n    const field = this._meta.field(name);\n\n    if (field === undefined || !field.navigation) throw Error(`navigationProperty: Can't find navigation property ${name}`);\n    const resource = this.resource();\n    if (!(resource instanceof ODataEntityResource) || !resource.hasKey()) throw Error(\"navigationProperty: Can't get navigation without ODataEntityResource with key\");\n    return field.resourceFactory(resource);\n  }\n\n  property(name) {\n    const field = this._meta.field(name);\n\n    if (field === undefined || field.navigation) throw Error(`property: Can't find property ${name}`);\n    const resource = this.resource();\n    if (!(resource instanceof ODataEntityResource) || !resource.hasKey()) throw Error(\"property: Can't get property without ODataEntityResource with key\");\n    return field.resourceFactory(resource);\n  }\n\n  attach(resource) {\n    return this._meta.attach(this, resource);\n  } //#endregion\n\n\n  schema() {\n    return this._meta.schema;\n  }\n\n  annots() {\n    return this._annotations;\n  }\n\n  key({\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    return this._meta.resolveKey(this, {\n      field_mapping,\n      resolve\n    });\n  }\n\n  isNew() {\n    return this.key() === undefined;\n  }\n\n  isParentOf(child) {\n    return child !== this && ODataModelOptions.chain(child).some(p => p[0] === this);\n  }\n\n  referential(field, {\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    return this._meta.resolveReferential(this, field, {\n      field_mapping,\n      resolve\n    });\n  }\n\n  referenced(field, {\n    field_mapping = false,\n    resolve = true\n  } = {}) {\n    return this._meta.resolveReferenced(this, field, {\n      field_mapping,\n      resolve\n    });\n  }\n\n  validate({\n    method,\n    navigation = false\n  } = {}) {\n    return this._meta.validate(this, {\n      method,\n      navigation\n    });\n  }\n\n  isValid({\n    method,\n    navigation = false\n  } = {}) {\n    this._errors = this.validate({\n      method,\n      navigation\n    });\n    if (this._errors !== undefined) this.events$.emit(new ODataModelEvent('invalid', {\n      model: this,\n      value: this._errors,\n      options: {\n        method\n      }\n    }));\n    return this._errors === undefined;\n  }\n\n  defaults() {\n    return this._meta.defaults() || {};\n  }\n\n  toEntity({\n    client_id = false,\n    include_navigation = false,\n    include_concurrency = false,\n    include_computed = false,\n    include_key = true,\n    include_non_field = false,\n    changes_only = false,\n    field_mapping = false,\n    chain = []\n  } = {}) {\n    return this._meta.toEntity(this, {\n      client_id,\n      include_navigation,\n      include_concurrency,\n      include_computed,\n      include_key,\n      include_non_field,\n      changes_only,\n      field_mapping,\n      chain\n    });\n  }\n\n  toJSON() {\n    return this.toEntity();\n  }\n\n  attributes({\n    changes_only = false,\n    include_concurrency = false,\n    include_computed = false,\n    include_non_field = false,\n    field_mapping = false\n  } = {}) {\n    return this._meta.attributes(this, {\n      changes_only,\n      include_concurrency,\n      include_computed,\n      include_non_field,\n      field_mapping\n    });\n  }\n\n  set(path, value) {\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    if (pathArray.length === 0) return undefined;\n\n    if (pathArray.length > 1) {\n      const model = this[pathArray[0]];\n      return model.set(pathArray.slice(1), value);\n    }\n\n    if (pathArray.length === 1) {\n      return this[pathArray[0]] = value;\n    }\n  }\n\n  get(path) {\n    const pathArray = Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    if (pathArray.length === 0) return undefined;\n    const value = this[pathArray[0]];\n\n    if (pathArray.length > 1 && (value instanceof ODataModel || value instanceof ODataCollection)) {\n      return value.get(pathArray.slice(1));\n    }\n\n    return value;\n  }\n\n  reset({\n    path,\n    silent = false\n  } = {}) {\n    const pathArray = path === undefined ? [] : Types.isArray(path) ? path : path.match(/([^[.\\]])+/g);\n    const name = pathArray[0];\n    const value = name !== undefined ? this[name] : undefined;\n\n    if (ODataModelOptions.isModel(value) || ODataModelOptions.isCollection(value)) {\n      value.reset({\n        path: pathArray.slice(1),\n        silent\n      });\n    } else {\n      this._meta.reset(this, {\n        name: pathArray[0],\n        silent\n      });\n    }\n  }\n\n  clear({\n    silent = false\n  } = {}) {\n    this._attributes.clear();\n\n    this._changes.clear();\n\n    this._relations.clear();\n\n    if (!silent) {\n      this.events$.emit(new ODataModelEvent('update', {\n        model: this\n      }));\n    }\n  }\n\n  assign(entity, {\n    reset = false,\n    reparent = false,\n    silent = false\n  } = {}) {\n    return this._meta.assign(this, entity, {\n      reset,\n      silent,\n      reparent\n    });\n  }\n\n  clone() {\n    let Ctor = this.constructor;\n    return new Ctor(this.toEntity(INCLUDE_SHALLOW), {\n      resource: this.resource(),\n      annots: this.annots()\n    });\n  }\n\n  _request(obs$) {\n    this.events$.emit(new ODataModelEvent('request', {\n      model: this,\n      options: {\n        observable: obs$\n      }\n    }));\n    return obs$.pipe(map(({\n      entity,\n      annots\n    }) => {\n      this._annotations = annots;\n      this.assign(annots.attributes(entity || {}, 'full'), {\n        reset: true\n      });\n      this.events$.emit(new ODataModelEvent('sync', {\n        model: this,\n        options: {\n          entity,\n          annots\n        }\n      }));\n      return this;\n    }));\n  }\n\n  fetch(_a = {}) {\n    var options = __rest(_a, []);\n\n    let resource = this.resource();\n    if (resource === undefined) return throwError(() => new Error('fetch: Resource is undefined'));\n    let obs$;\n\n    if (resource instanceof ODataEntityResource) {\n      obs$ = resource.fetch(options);\n    } else if (resource instanceof ODataNavigationPropertyResource) {\n      obs$ = resource.fetch(Object.assign({\n        responseType: 'entity'\n      }, options));\n    } else {\n      obs$ = resource.fetch(Object.assign({\n        responseType: 'entity'\n      }, options));\n    }\n\n    return this._request(obs$);\n  }\n\n  save(_a = {}) {\n    var {\n      method,\n      navigation = false,\n      validate = true\n    } = _a,\n        options = __rest(_a, [\"method\", \"navigation\", \"validate\"]);\n\n    let resource = this.resource();\n    if (resource === undefined) return throwError(() => new Error('save: Resource is undefined'));\n    if (!(resource instanceof ODataEntityResource || resource instanceof ODataNavigationPropertyResource)) return throwError(() => new Error('save: Resource type ODataEntityResource/ODataNavigationPropertyResource needed')); // Resolve method and resource key\n\n    if (method === undefined && this.schema().isCompoundKey()) return throwError(() => new Error('save: Composite key require a specific method, use create/update/modify'));\n    method = method || (!resource.hasKey() ? 'create' : 'update');\n    if (resource instanceof ODataEntityResource && (method === 'update' || method === 'modify') && !resource.hasKey()) return throwError(() => new Error('save: Update/Patch require entity key'));\n    if (resource instanceof ODataNavigationPropertyResource || method === 'create') resource.clearKey();\n\n    if (validate && !this.isValid({\n      method,\n      navigation\n    })) {\n      return throwError(() => new Error('save: Validation errors'));\n    }\n\n    const _entity = this.toEntity({\n      changes_only: method === 'modify',\n      field_mapping: true,\n      include_concurrency: true,\n      include_navigation: navigation\n    });\n\n    return this._request((method === 'create' ? resource.create(_entity, options) : method === 'modify' ? resource.modify(_entity, Object.assign({\n      etag: this.annots().etag\n    }, options)) : resource.update(_entity, Object.assign({\n      etag: this.annots().etag\n    }, options))).pipe(map(({\n      entity,\n      annots\n    }) => ({\n      entity: entity || _entity,\n      annots\n    }))));\n  }\n\n  destroy(_a = {}) {\n    var options = __rest(_a, []);\n\n    let resource = this.resource();\n    if (resource === undefined) return throwError(() => new Error('destroy: Resource is undefined'));\n    if (!(resource instanceof ODataEntityResource || resource instanceof ODataNavigationPropertyResource)) return throwError(() => new Error('destroy: Resource type ODataEntityResource/ODataNavigationPropertyResource needed'));\n    if (!resource.hasKey()) return throwError(() => new Error(\"destroy: Can't destroy model without key\"));\n\n    const _entity = this.toEntity({\n      field_mapping: true\n    });\n\n    const obs$ = resource.destroy(Object.assign({\n      etag: this.annots().etag\n    }, options)).pipe(map(({\n      entity,\n      annots\n    }) => ({\n      entity: entity || _entity,\n      annots\n    })));\n    return this._request(obs$).pipe(tap(() => this.events$.emit(new ODataModelEvent('destroy', {\n      model: this\n    }))));\n  }\n  /**\n   * Create an execution context for change the internal query of a resource\n   * @param func Function to execute\n   */\n\n\n  query(func) {\n    return this._meta.query(this, this.resource(), func);\n  }\n  /**\n   * Perform a check on the internal state of the model and return true if the model is changed.\n   * @param include_navigation Check in navigation properties\n   * @returns true if the model has changed, false otherwise\n   */\n\n\n  hasChanged({\n    include_navigation = false\n  } = {}) {\n    return this._meta.hasChanged(this, {\n      include_navigation\n    });\n  }\n  /**\n   * Create an execution context for a given function, where the model is bound to its entity endpoint\n   * @param ctx Context function\n   * @returns The result of the context\n   */\n\n\n  asEntity(ctx) {\n    return this._meta.asEntity(this, ctx);\n  }\n\n  callFunction(name, params, responseType, _a = {}) {\n    var options = __rest(_a, []);\n\n    const resource = this.resource();\n    if (!(resource instanceof ODataEntityResource) || !resource.hasKey()) return throwError(() => new Error(\"callFunction: Can't call function without ODataEntityResource with key\"));\n    const func = resource.function(name).query(q => q.apply(options));\n\n    switch (responseType) {\n      case 'property':\n        return func.callProperty(params, options);\n\n      case 'model':\n        return func.callModel(params, options);\n\n      case 'collection':\n        return func.callCollection(params, options);\n\n      default:\n        return func.call(params, Object.assign({\n          responseType\n        }, options));\n    }\n  }\n\n  callAction(name, params, responseType, _a = {}) {\n    var options = __rest(_a, []);\n\n    const resource = this.resource();\n    if (!(resource instanceof ODataEntityResource) || !resource.hasKey()) return throwError(() => new Error(\"callAction: Can't call action without ODataEntityResource with key\"));\n    const action = resource.action(name).query(q => q.apply(options));\n\n    switch (responseType) {\n      case 'property':\n        return action.callProperty(params, options);\n\n      case 'model':\n        return action.callModel(params, options);\n\n      case 'collection':\n        return action.callCollection(params, options);\n\n      default:\n        return action.call(params, Object.assign({\n          responseType\n        }, options));\n    }\n  } // Cast\n\n\n  cast(type) {\n    const resource = this.resource();\n    if (!(resource instanceof ODataEntityResource)) throw new Error(`cast: Can't cast to derived model without ODataEntityResource`);\n    return resource.cast(type).asModel(this.toEntity(INCLUDE_DEEP), {\n      annots: this.annots()\n    });\n  }\n\n  fetchNavigationProperty(name, responseType, _a = {}) {\n    var options = __rest(_a, []);\n\n    const nav = this.navigationProperty(name);\n    nav.query(q => q.apply(options));\n\n    switch (responseType) {\n      case 'model':\n        return nav.fetchModel(options);\n\n      case 'collection':\n        return nav.fetchCollection(options);\n    }\n  } // Get Value\n\n\n  getValue(name, options) {\n    const field = this._meta.field(name);\n\n    if (field === undefined || field.navigation) throw Error(`getValue: Can't find property ${name}`);\n    let value = this[name];\n\n    if (value === undefined) {\n      const prop = field.resourceFactory(this.resource());\n      return field.collection ? prop.fetchCollection(options).pipe(tap(c => this.assign({\n        [name]: c\n      }, {\n        silent: true\n      }))) : field.isStructuredType() ? prop.fetchModel(options).pipe(tap(c => this.assign({\n        [name]: c\n      }, {\n        silent: true\n      }))) : prop.fetchProperty(options).pipe(tap(c => this.assign({\n        [name]: c\n      }, {\n        silent: true\n      })));\n    }\n\n    return of(value);\n  } // Set Reference\n\n\n  setReference(name, model, options) {\n    const reference = this.navigationProperty(name).reference();\n    const etag = this.annots().etag;\n    let obs$ = NEVER;\n\n    if (model instanceof ODataModel) {\n      obs$ = reference.set(model._meta.entityResource(model), Object.assign({\n        etag\n      }, options));\n    } else if (model instanceof ODataCollection) {\n      obs$ = forkJoin(model.models().map(m => reference.add(m._meta.entityResource(m), options)));\n    } else if (model === null) {\n      obs$ = reference.unset(Object.assign({\n        etag\n      }, options));\n    }\n\n    this.events$.emit(new ODataModelEvent('request', {\n      model: this,\n      options: {\n        observable: obs$\n      }\n    }));\n    return obs$.pipe(map(model => {\n      this.assign({\n        [name]: model\n      });\n      this.events$.emit(new ODataModelEvent('sync', {\n        model: this\n      }));\n      return this;\n    }));\n  }\n\n  getReference(name) {\n    const field = this._meta.field(name);\n\n    if (field === undefined || !field.navigation) throw Error(`getReference: Can't find navigation property ${name}`);\n    let model = this[name];\n    if (model === null) return null;\n\n    if (model === undefined) {\n      const value = field.collection ? [] : this.referenced(field);\n      model = value !== null ? field.modelCollectionFactory({\n        parent: this,\n        value\n      }) : null;\n      this[name] = model;\n    }\n\n    return model;\n  } // Model functions\n\n\n  equals(other) {\n    const thisKey = this.key();\n    const otherKey = other.key();\n    return this === other || typeof this === typeof other && (this[this._meta.cid] === other[this._meta.cid] || thisKey !== undefined && otherKey !== undefined && Types.isEqual(thisKey, otherKey));\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Model';\n  }\n\n  collection() {\n    return this._parent !== null && ODataModelOptions.isCollection(this._parent[0]) ? this._parent[0] : undefined;\n  }\n\n  next() {\n    var _a;\n\n    return (_a = this.collection()) === null || _a === void 0 ? void 0 : _a.next(this);\n  }\n\n  prev() {\n    var _a;\n\n    return (_a = this.collection()) === null || _a === void 0 ? void 0 : _a.prev(this);\n  }\n\n}\n\nconst RESERVED_FIELD_NAMES = Object.getOwnPropertyNames(ODataModel.prototype);\n\nclass ODataApiOptions {\n  constructor(config) {\n    this.etag = {\n      ifMatch: true,\n      ifNoneMatch: false\n    };\n    this.version = config.version || DEFAULT_VERSION;\n    this.stringAsEnum = config.stringAsEnum || false;\n    this.params = config.params || {};\n    this.headers = config.headers || {};\n    this.withCredentials = config.withCredentials;\n    this.stripMetadata = config.stripMetadata || DEFAULT_STRIP_METADATA;\n    this.fetchPolicy = config.fetchPolicy || DEFAULT_FETCH_POLICY;\n    this.bodyQueryOptions = config.bodyQueryOptions || [];\n    this.accept = config.accept;\n    Object.assign(this.etag, config.etag || {});\n    this.prefer = config.prefer;\n    this.deleteRefBy = config.deleteRefBy || 'path';\n    this.nonParenthesisForEmptyParameterFunction = config.nonParenthesisForEmptyParameterFunction || false;\n  }\n\n  get parserOptions() {\n    return Object.assign({\n      version: this.version\n    }, this.accept);\n  }\n\n  get helper() {\n    return ODataHelper[this.version];\n  }\n\n}\n/**\n * Api abstraction for consuming OData services.\n */\n\n\nclass ODataApi {\n  constructor(config) {\n    //# region Find by Type\n    // Memoize\n    this.memo = {\n      forType: {\n        enum: new Map(),\n        structured: new Map(),\n        callable: new Map(),\n        entitySet: new Map(),\n        parser: new Map(),\n        options: new Map()\n      },\n      byName: {\n        enum: new Map(),\n        structured: new Map(),\n        callable: new Map(),\n        entitySet: new Map()\n      }\n    };\n    this.serviceRootUrl = config.serviceRootUrl;\n    if (this.serviceRootUrl.indexOf('?') != -1) throw new Error(\"The 'serviceRootUrl' should not contain query string. Please use 'params' to add extra parameters\");\n    if (!this.serviceRootUrl.endsWith('/')) this.serviceRootUrl += '/';\n    this.metadataUrl = `${this.serviceRootUrl}$metadata`;\n    this.name = config.name;\n    this.version = config.version || DEFAULT_VERSION;\n    this.default = config.default || false;\n    this.creation = config.creation || new Date();\n    this.options = new ODataApiOptions(Object.assign({\n      version: this.version\n    }, config.options || {}));\n    this.cache = config.cache || new ODataInMemoryCache();\n    this.errorHandler = config.errorHandler;\n    this.parsers = config.parsers || EDM_PARSERS;\n    this.schemas = (config.schemas || []).map(schema => new ODataSchema(schema, this));\n  }\n\n  configure(settings = {}) {\n    this.requester = settings.requester;\n    this.schemas.forEach(schema => {\n      schema.configure({\n        parserForType: type => this.parserForType(type),\n        findOptionsForType: type => this.findOptionsForType(type)\n      });\n    });\n  }\n\n  fromJSON(json) {\n    var _a, _b;\n\n    const segments = new ODataPathSegments(json.segments);\n    const query = new ODataQueryOptions(json.options);\n\n    switch ((_a = segments.last()) === null || _a === void 0 ? void 0 : _a.name) {\n      case PathSegmentNames.entitySet:\n        if ((_b = segments.last()) === null || _b === void 0 ? void 0 : _b.hasKey()) {\n          return new ODataEntityResource(this, {\n            segments,\n            query\n          });\n        } else {\n          return new ODataEntitySetResource(this, {\n            segments,\n            query\n          });\n        }\n\n      case PathSegmentNames.navigationProperty:\n        return new ODataNavigationPropertyResource(this, {\n          segments,\n          query\n        });\n\n      case PathSegmentNames.singleton:\n        return new ODataSingletonResource(this, {\n          segments,\n          query\n        });\n\n      case PathSegmentNames.action:\n        return new ODataActionResource(this, {\n          segments,\n          query\n        });\n\n      case PathSegmentNames.function:\n        return new ODataFunctionResource(this, {\n          segments,\n          query\n        });\n    }\n\n    throw new Error('No Resource for json');\n  }\n  /**\n   * Build a metadata resource.\n   * @returns ODataMetadataResource\n   */\n\n\n  metadata() {\n    return ODataMetadataResource.factory(this);\n  }\n  /**\n   * Build a batch resource.\n   * @returns ODataBatchResource\n   */\n\n\n  batch() {\n    return ODataBatchResource.factory(this);\n  }\n  /**\n   * Build a singleton resource.\n   * @param path Name of the singleton\n   * @returns\n   */\n\n\n  singleton(path) {\n    const entitySet = this.findEntitySetByName(path);\n    const schema = entitySet !== undefined ? this.findStructuredTypeForType(entitySet.entityType) : undefined;\n    return ODataSingletonResource.factory(this, {\n      path,\n      schema\n    });\n  }\n  /**\n   * Build an entity set resource.\n   * @param path Name of the entity set\n   * @returns\n   */\n\n\n  entitySet(path) {\n    const entitySet = this.findEntitySetByName(path);\n    const schema = entitySet !== undefined ? this.findStructuredTypeForType(entitySet.entityType) : undefined;\n    return ODataEntitySetResource.factory(this, {\n      path,\n      schema\n    });\n  }\n  /**\n   * Unbound Action\n   * @param  {string} path?\n   * @returns ODataActionResource\n   */\n\n\n  action(path) {\n    const schema = this.findCallableForType(path);\n    return ODataActionResource.factory(this, {\n      path,\n      schema\n    });\n  }\n  /**\n   * Unbound Function\n   * @param  {string} path?\n   * @returns ODataFunctionResource\n   */\n\n\n  function(path) {\n    const schema = this.findCallableForType(path);\n    return ODataFunctionResource.factory(this, {\n      path,\n      schema\n    });\n  }\n\n  request(req) {\n    let res$ = this.requester !== undefined ? this.requester(req) : NEVER;\n    res$ = res$.pipe(map(res => res.type === HttpEventType.Response ? ODataResponse.fromHttpResponse(req, res) : res));\n    if (this.errorHandler !== undefined) res$ = res$.pipe(catchError(this.errorHandler));\n    return req.observe === 'response' ? this.cache.handleRequest(req, res$) : res$;\n  }\n\n  findSchemaForType(type) {\n    const schemas = this.schemas.filter(s => s.isNamespaceOf(type));\n    if (schemas.length === 0) return undefined;\n    if (schemas.length === 1) return schemas[0];\n    return schemas.sort((s1, s2) => s1.namespace.length - s2.namespace.length).pop();\n  }\n\n  findEnumTypeForType(type) {\n    var _a;\n\n    if (!this.memo.forType.enum.has(type)) {\n      this.memo.forType.enum.set(type, (_a = this.findSchemaForType(type)) === null || _a === void 0 ? void 0 : _a.findEnumTypeForType(type));\n    }\n\n    return this.memo.forType.enum.get(type);\n  }\n\n  findStructuredTypeForType(type) {\n    var _a;\n\n    if (!this.memo.forType.structured.has(type)) {\n      this.memo.forType.structured.set(type, (_a = this.findSchemaForType(type)) === null || _a === void 0 ? void 0 : _a.findStructuredTypeForType(type));\n    }\n\n    return this.memo.forType.structured.get(type);\n  }\n\n  findCallableForType(type, bindingType) {\n    var _a;\n\n    const key = bindingType !== undefined ? `${bindingType}/${type}` : type;\n\n    if (!this.memo.forType.callable.has(key)) {\n      this.memo.forType.callable.set(key, (_a = this.findSchemaForType(type)) === null || _a === void 0 ? void 0 : _a.findCallableForType(type, bindingType));\n    }\n\n    return this.memo.forType.callable.get(key);\n  }\n\n  findEntitySetForType(type) {\n    var _a;\n\n    if (!this.memo.forType.entitySet.has(type)) {\n      this.memo.forType.entitySet.set(type, (_a = this.findSchemaForType(type)) === null || _a === void 0 ? void 0 : _a.findEntitySetForType(type));\n    }\n\n    return this.memo.forType.entitySet.get(type);\n  }\n\n  findModelForType(type) {\n    var _a;\n\n    return (_a = this.findStructuredTypeForType(type)) === null || _a === void 0 ? void 0 : _a.model;\n  }\n\n  modelForType(type) {\n    let Model = this.findModelForType(type);\n\n    if (Model === undefined) {\n      // Build Ad-hoc model\n      let schema = this.findStructuredTypeForType(type);\n      if (schema === undefined) throw Error(`No schema for ${type}`);\n      Model = class extends ODataModel {}; // Build Meta\n\n      Model.buildMeta({\n        schema\n      }); // Configure\n\n      Model.meta.configure({\n        findOptionsForType: type => this.findOptionsForType(type),\n        options: this.options.parserOptions\n      }); // Store New Model for next time\n\n      schema.model = Model;\n    }\n\n    return Model;\n  }\n\n  findCollectionForType(type) {\n    var _a;\n\n    return (_a = this.findStructuredTypeForType(type)) === null || _a === void 0 ? void 0 : _a.collection;\n  }\n\n  collectionForType(type) {\n    let Collection = this.findCollectionForType(type);\n\n    if (Collection === undefined) {\n      let schema = this.findStructuredTypeForType(type);\n      if (schema === undefined) throw Error('');\n      Collection = class extends ODataCollection {};\n      Collection.model = this.modelForType(type); // Store New Collection for next time\n\n      schema.collection = Collection;\n    }\n\n    return Collection;\n  }\n\n  findServiceForType(type) {\n    var _a;\n\n    return (_a = this.findEntitySetForType(type)) === null || _a === void 0 ? void 0 : _a.service;\n  }\n\n  findEntitySetForEntityType(entityType) {\n    if (!this.memo.forType.entitySet.has(entityType)) {\n      this.memo.forType.entitySet.set(entityType, this.schemas.reduce((acc, schema) => [...acc, ...schema.entitySets], []).find(e => e.entityType === entityType));\n    }\n\n    return this.memo.forType.entitySet.get(entityType);\n  }\n\n  findServiceForEntityType(entityType) {\n    var _a;\n\n    return (_a = this.findEntitySetForEntityType(entityType)) === null || _a === void 0 ? void 0 : _a.service;\n  }\n\n  findEnumTypeByName(name) {\n    if (!this.memo.byName.enum.has(name)) {\n      this.memo.byName.enum.set(name, this.schemas.reduce((acc, schema) => [...acc, ...schema.enums], []).find(e => e.name === name));\n    }\n\n    return this.memo.byName.enum.get(name);\n  }\n\n  findStructuredTypeByName(name) {\n    if (!this.memo.byName.structured.has(name)) {\n      this.memo.byName.structured.set(name, this.schemas.reduce((acc, schema) => [...acc, ...schema.entities], []).find(e => e.name === name));\n    }\n\n    return this.memo.byName.structured.get(name);\n  }\n\n  findCallableByName(name, bindingType) {\n    const key = bindingType !== undefined ? `${bindingType}/${name}` : name;\n\n    if (!this.memo.byName.callable.has(key)) {\n      this.memo.byName.callable.set(key, this.schemas.reduce((acc, schema) => [...acc, ...schema.callables], []).find(c => {\n        var _a;\n\n        return c.name === name && (bindingType === undefined || ((_a = c.binding()) === null || _a === void 0 ? void 0 : _a.type) === bindingType);\n      }));\n    }\n\n    return this.memo.byName.callable.get(key);\n  }\n\n  findEntitySetByName(name) {\n    if (!this.memo.byName.entitySet.has(name)) {\n      this.memo.byName.entitySet.set(name, this.schemas.reduce((acc, schema) => [...acc, ...schema.entitySets], []).find(e => e.name === name));\n    }\n\n    return this.memo.byName.entitySet.get(name);\n  }\n\n  findModelByName(name) {\n    var _a;\n\n    return (_a = this.findStructuredTypeByName(name)) === null || _a === void 0 ? void 0 : _a.model;\n  }\n\n  findCollectionByName(name) {\n    var _a;\n\n    return (_a = this.findStructuredTypeByName(name)) === null || _a === void 0 ? void 0 : _a.collection;\n  }\n\n  findServiceByName(name) {\n    var _a;\n\n    return (_a = this.findEntitySetByName(name)) === null || _a === void 0 ? void 0 : _a.service;\n  }\n\n  parserForType(type, bindingType) {\n    const key = bindingType !== undefined ? `${bindingType}/${type}` : type;\n\n    if (!this.memo.forType.parser.has(key)) {\n      if (type in this.parsers) {\n        // Edm, Base Parsers\n        this.memo.forType.parser.set(key, this.parsers[type]);\n      } else if (!type.startsWith('Edm.')) {\n        // EnumType, ComplexType and EntityType Parsers\n        let value = this.findCallableForType(type, bindingType) || this.findEnumTypeForType(type) || this.findStructuredTypeForType(type);\n        this.memo.forType.parser.set(key, value === null || value === void 0 ? void 0 : value.parser);\n      } else {\n        // None Parser\n        this.memo.forType.parser.set(key, NONE_PARSER);\n      }\n    }\n\n    return this.memo.forType.parser.get(key);\n  }\n\n  findOptionsForType(type) {\n    var _a; // Strucutred Options\n\n\n    if (!this.memo.forType.options.has(type)) {\n      let st = this.findStructuredTypeForType(type);\n      this.memo.forType.options.set(type, st !== undefined && st.model !== undefined && ((_a = st.model) === null || _a === void 0 ? void 0 : _a.meta) !== null ? st.model.meta : undefined);\n    }\n\n    return this.memo.forType.options.get(type);\n  }\n\n}\n\nclass ODataSettings {\n  constructor(...configs) {\n    this.apis = configs.map(config => new ODataApi(config));\n\n    if (this.apis.length > 1) {\n      if (this.apis.some(c => c.name === undefined)) throw new Error('Multiple APIs: Needs configuration names');\n      if (this.apis.filter(c => c.default).length > 1) throw new Error('Multiple APIs: Needs only one default api');\n    } // If not default setup first config as default api\n\n\n    if (this.apis.every(c => !c.default)) this.apis[0].default = true;\n  }\n\n  configure(settings) {\n    this.apis.forEach(api => api.configure(settings));\n  }\n\n  defaultApi() {\n    return this.apis.find(c => c.default);\n  }\n\n  findApiByName(name) {\n    return this.apis.find(c => c.name === name);\n  }\n\n  apiByName(name) {\n    const api = this.findApiByName(name);\n    if (api === undefined) throw new Error(`No API for name: ${name}`);\n    return api;\n  }\n\n  findApiForTypes(types) {\n    return this.apis.find(c => c.schemas.some(s => types.some(type => s.isNamespaceOf(type))));\n  }\n\n  findApiForType(type) {\n    return this.findApiForTypes([type]);\n  }\n\n  apiForType(type) {\n    const api = this.findApiForType(type);\n    if (api === undefined) throw new Error(`No API for type: ${type}`);\n    return api;\n  } //#region Configs shortcuts\n\n\n  enumTypeForType(type) {\n    let values = this.apis.map(api => api.findEnumTypeForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Enum for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  structuredTypeForType(type) {\n    let values = this.apis.map(api => api.findStructuredTypeForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Structured for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  callableForType(type, bindingType) {\n    let values = this.apis.map(api => api.findCallableForType(type, bindingType)).filter(e => e);\n    if (values.length === 0) throw Error(`No Callable for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  entitySetForType(type) {\n    let values = this.apis.map(api => api.findEntitySetForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No EntitySet for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  parserForType(type) {\n    let values = this.apis.map(api => api.parserForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Parser for type ${type} was found`);\n    if (!type.startsWith('Edm.') && values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  modelForType(type) {\n    let values = this.apis.map(api => api.findModelForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Model for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  collectionForType(type) {\n    let values = this.apis.map(api => api.findCollectionForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Collection for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  serviceForType(type) {\n    let values = this.apis.map(api => api.findServiceForType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Service for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  serviceForEntityType(type) {\n    let values = this.apis.map(api => api.findServiceForEntityType(type)).filter(e => e);\n    if (values.length === 0) throw Error(`No Service for type ${type} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  enumTypeByName(name) {\n    let values = this.apis.map(api => api.findEnumTypeByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No Enum for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  structuredTypeByName(name) {\n    let values = this.apis.map(api => api.findStructuredTypeByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No Structured for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple Structured: More than one value was found');\n    return values[0];\n  }\n\n  callableByName(name, bindingType) {\n    let values = this.apis.map(api => api.findCallableByName(name, bindingType)).filter(e => e);\n    if (values.length === 0) throw Error(`No Callable for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple Callable: More than one value was found');\n    return values[0];\n  }\n\n  entitySetByName(name) {\n    let values = this.apis.map(api => api.findEntitySetByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No EntitySet for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple EntitySet: More than one value was found');\n    return values[0];\n  }\n\n  modelByName(name) {\n    let values = this.apis.map(api => api.findModelByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No Model for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  collectionByName(name) {\n    let values = this.apis.map(api => api.findCollectionByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No Collection for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n  serviceByName(name) {\n    let values = this.apis.map(api => api.findServiceByName(name)).filter(e => e);\n    if (values.length === 0) throw Error(`No Service for name ${name} was found`);\n    if (values.length > 1) throw Error('Multiple APIs: More than one value was found');\n    return values[0];\n  }\n\n}\n\nfunction addBody(options, body) {\n  return {\n    body,\n    etag: options.etag,\n    apiName: options.apiName,\n    fetchPolicy: options.fetchPolicy,\n    headers: options.headers,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials\n  };\n}\n\nlet ODataClient = /*#__PURE__*/(() => {\n  class ODataClient {\n    constructor(http, settings, injector) {\n      this.http = http;\n      this.settings = settings;\n      this.injector = injector;\n      this.settings.configure({\n        requester: req => this.http.request(req.method, `${req.url}`, {\n          body: req.body,\n          headers: req.headers,\n          observe: req.observe,\n          params: req.params,\n          reportProgress: req.reportProgress,\n          responseType: req.responseType,\n          withCredentials: req.withCredentials\n        })\n      });\n    } //#region Resolve Building Blocks\n\n    /**\n     * Resolve the api for the given value.\n     * Where value is: string type or an string name or an instance of resource.\n     * @param value The value to resolve.\n     * @returns The api for the value.\n     */\n\n\n    apiFor(value) {\n      let api = undefined;\n      if (value instanceof ODataResource) api = this.settings.findApiForTypes(value.types());else if (typeof value === 'string') api = this.settings.findApiByName(value) || this.settings.findApiForType(value);\n      return api || this.settings.defaultApi();\n    }\n    /**\n     * Resolve the parser for the given string type.\n     * @param type The string type of the parser.\n     * @returns The parser for the given type.\n     */\n\n\n    parserForType(type) {\n      return this.settings.parserForType(type);\n    }\n    /**\n     * Resolve the enum type for the given string type.\n     * @param type The string type of the enum type.\n     * @returns The enum type for the given type.\n     */\n\n\n    enumTypeForType(type) {\n      return this.settings.enumTypeForType(type);\n    }\n    /**\n     * Resolve the structured type for the given string type.\n     * @param type The string type of the structured type.\n     * @returns The structured type for the given type.\n     */\n\n\n    structuredTypeForType(type) {\n      return this.settings.structuredTypeForType(type);\n    }\n    /**\n     * Resolve the callable for the given string type.\n     * @param type The string type of the callable.\n     * @returns The callable for the given type.\n     */\n\n\n    callableForType(type) {\n      return this.settings.callableForType(type);\n    }\n    /**\n     * Resolve the entity set for the given string type.\n     * @param type The string type of the entity set.\n     * @returns The entity set for the given type.\n     */\n\n\n    entitySetForType(type) {\n      return this.settings.entitySetForType(type);\n    }\n    /**\n     * Resolve the model for the given string type.\n     * @param type The string type of the model.\n     * @returns The model for the given type.\n     */\n\n\n    modelForType(type) {\n      return this.settings.modelForType(type);\n    }\n    /**\n     * Resolve the collection for the given string type.\n     * @param type The string type of the collection.\n     * @returns The collection for the given type.\n     */\n\n\n    collectionForType(type) {\n      return this.settings.collectionForType(type);\n    }\n    /**\n     * Resolve the service for the given string type.\n     * @param type The string type of the service.\n     * @returns The service for the given type.\n     */\n\n\n    serviceForType(type) {\n      return this.injector.get(this.settings.serviceForType(type));\n    }\n    /**\n     * Resolve the service for the given string entity type.\n     * @param type The string entity type binding to the service.\n     * @returns The service for the given entity type.\n     */\n\n\n    serviceForEntityType(type) {\n      return this.injector.get(this.settings.serviceForEntityType(type));\n    }\n\n    enumTypeByName(name) {\n      return this.settings.enumTypeByName(name);\n    }\n\n    structuredTypeByName(name) {\n      return this.settings.structuredTypeByName(name);\n    }\n\n    callableByName(name) {\n      return this.settings.callableByName(name);\n    }\n\n    entitySetByName(name) {\n      return this.settings.entitySetByName(name);\n    }\n\n    modelByName(name) {\n      return this.settings.modelByName(name);\n    }\n\n    collectionByName(name) {\n      return this.settings.collectionByName(name);\n    }\n\n    serviceByName(name) {\n      return this.injector.get(this.settings.serviceByName(name));\n    }\n\n    fromJSON(json, apiNameOrType) {\n      return this.apiFor(apiNameOrType).fromJSON(json);\n    } // Requests\n\n    /**\n     * Build a resource for the metadata.\n     * @param apiName The name of the API.\n     * @returns The metadata resource.\n     */\n\n\n    metadata(apiName) {\n      return this.apiFor(apiName).metadata();\n    }\n    /**\n     * Build a resource for the batch.\n     * @param apiName The name of the API.\n     * @returns The batch resource.\n     */\n\n\n    batch(apiName) {\n      return this.apiFor(apiName).batch();\n    }\n    /**\n     * Build a resource for the singleton.\n     * @param path The full path to the singleton.\n     * @param apiNameOrType The name of the API or the type of the singleton.\n     * @returns The singleton resource.\n     */\n\n\n    singleton(path, apiNameOrType) {\n      return this.apiFor(apiNameOrType).singleton(path);\n    }\n    /**\n     * Build a resource for the entity set.\n     * @param path The full path to the entity set.\n     * @param apiNameOrType The name of the API or the type of the entity set.\n     * @returns The entity set resource.\n     */\n\n\n    entitySet(path, apiNameOrType) {\n      return this.apiFor(apiNameOrType).entitySet(path);\n    }\n    /**\n     * Build a resource for unbound action.\n     * @param path The full path to the action.\n     * @param apiNameOrType The name of the API or the type of the entity.\n     * @returns The unbound action resource.\n     */\n\n\n    action(path, apiNameOrType) {\n      return this.apiFor(apiNameOrType).action(path);\n    }\n    /**\n     * Build a resource for unbound function.\n     * @param path The full path to the function.\n     * @param apiNameOrType The name of the API or the type of the callable.\n     * @returns The unbound function resource.\n     */\n\n\n    function(path, apiNameOrType) {\n      return this.apiFor(apiNameOrType).function(path);\n    }\n\n    request(method, resource, options) {\n      let api = options.apiName ? this.settings.apiByName(options.apiName) : resource.api;\n      if (!api) throw new Error(`The types: '[${resource.types().join(', ')}]' does not belongs to any known configuration`);\n      const request = new ODataRequest({\n        method,\n        api,\n        resource,\n        body: options.body,\n        observe: options.observe === 'events' ? 'events' : 'response',\n        etag: options.etag,\n        headers: options.headers,\n        reportProgress: options.reportProgress,\n        params: options.params,\n        responseType: options.responseType,\n        fetchPolicy: options.fetchPolicy,\n        withCredentials: options.withCredentials\n      });\n      return api.request(request).pipe(map(res => options.observe === undefined || options.observe === 'body' ? res.body : res));\n    }\n\n    delete(resource, options = {}) {\n      return this.request('DELETE', resource, addBody(options, null));\n    }\n\n    get(resource, options = {}) {\n      return this.request('GET', resource, options);\n    }\n\n    head(resource, options = {}) {\n      return this.request('HEAD', resource, options);\n    }\n\n    jsonp(resource, callbackParam) {\n      return this.request('JSONP', resource, {\n        body: null,\n        params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n        observe: 'body',\n        responseType: 'json'\n      });\n    }\n\n    options(resource, options = {}) {\n      return this.request('OPTIONS', resource, options);\n    }\n\n    patch(resource, body, options = {}) {\n      return this.request('PATCH', resource, addBody(options, body));\n    }\n\n    post(resource, body, options = {}) {\n      return this.request('POST', resource, addBody(options, body));\n    }\n\n    put(resource, body, options = {}) {\n      return this.request('PUT', resource, addBody(options, body));\n    }\n\n  }\n\n  ODataClient.fac = function ODataClient_Factory(t) {\n    return new (t || ODataClient)(i0.inject(i1.HttpClient), i0.inject(ODataSettings), i0.inject(i0.Injector));\n  };\n\n  ODataClient.prov = /* @__PURE__ */i0.defineInjectable({\n    token: ODataClient,\n    factory: ODataClient.fac,\n    providedIn: 'root'\n  });\n  return ODataClient;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ODATA_CONFIGURATIONS = new InjectionToken('odata.configuraions');\n\nclass ODataBaseService {\n  constructor(client, name, apiNameOrEntityType) {\n    this.client = client;\n    this.name = name;\n    this.apiNameOrEntityType = apiNameOrEntityType;\n  }\n\n  get api() {\n    return this.client.apiFor(this.apiNameOrEntityType);\n  }\n\n  callFunction(params, resource, responseType, options = {}) {\n    resource.query(q => q.apply(options));\n    return resource.call(params, Object.assign({\n      responseType: responseType\n    }, options));\n  }\n\n  callAction(params, resource, responseType, options = {}) {\n    resource.query(q => q.apply(options));\n    return resource.call(params, Object.assign({\n      responseType: responseType\n    }, options));\n  }\n\n  fetchNavigationProperty(resource, responseType, options = {}) {\n    resource.query(q => q.apply(options));\n    return resource.fetch(Object.assign({\n      responseType: responseType\n    }, options));\n  }\n\n}\n\nclass ODataEntityService extends ODataBaseService {\n  /**\n   * The schema for the structured type.\n   */\n  get structuredTypeSchema() {\n    return this.apiNameOrEntityType !== undefined ? this.api.findStructuredTypeForType(this.apiNameOrEntityType) : undefined;\n  }\n\n}\n\nclass ODataEntitySetService extends ODataEntityService {\n  /**\n   * Get the entity set resource for this service.\n   */\n  entities() {\n    return this.client.entitySet(this.name, this.apiNameOrEntityType);\n  }\n  /**\n   * Get the entity resource for this service.\n   * @param key The entity key.\n   */\n\n\n  entity(key) {\n    return this.entities().entity(key);\n  }\n\n  attach(model) {\n    if (model instanceof ODataModel) {\n      model.attach(this.entities().entity());\n    } else if (model instanceof ODataCollection) {\n      model.attach(this.entities());\n    }\n  }\n  /**\n   * The schema for the entity set.\n   */\n\n\n  get entitySetSchema() {\n    return this.api.findEntitySetByName(this.name);\n  }\n  /**\n   * Get all entities from the entity set.\n   * @param options The options for the request.\n   */\n\n\n  fetchAll(options) {\n    return this.entities().fetchAll(options);\n  }\n  /**\n   * Get entities from the entity set.\n   * @param withCount Get the count of the entities.\n   * @param options The options for the request.\n   */\n\n\n  fetchMany(options) {\n    return this.entities().fetch(options);\n  }\n  /**\n   * Get an entity from the entity set.\n   * @param key The entity key.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  fetchOne(key, options) {\n    return this.entity(key).fetch(options);\n  }\n  /**\n   * Create an entity in the entity set.\n   * @param attrs The attributes for the entity.\n   * @param options The options for the request.\n   */\n\n\n  create(attrs, options) {\n    return this.entities().create(attrs, options);\n  }\n  /**\n   * Update an entity in the entity set.\n   * @param key The entity key.\n   * @param attrs The attributes for the entity.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  update(key, attrs, options) {\n    const res = this.entity(key);\n    if (!res.hasKey()) return throwError(() => new Error('update: Resource without key'));\n    return res.update(attrs, options);\n  }\n  /**\n   * Patch an entity in the entity set.\n   * @param key The entity key.\n   * @param attrs The attributes for the entity.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  modify(key, attrs, options) {\n    const res = this.entity(key);\n    if (!res.hasKey()) return throwError(() => new Error('modify: Resource without key'));\n    return res.modify(attrs, options);\n  }\n  /**\n   * Delete an entity in the entity set.\n   * @param key The entity key.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  destroy(key, options) {\n    const res = this.entity(key);\n    if (!res.hasKey()) return throwError(() => new Error('destroy: Resource without key'));\n    return res.destroy(options);\n  } //#region Shortcuts\n\n  /**\n   * Get or create an entity in the entity set.\n   * @param key The entity key.\n   * @param attrs The attributes for the entity.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  fetchOrCreate(key, attrs, _a = {}) {\n    var {\n      etag\n    } = _a,\n        options = __rest(_a, [\"etag\"]);\n\n    return this.fetchOne(key, Object.assign({\n      etag\n    }, options)).pipe(catchError(error => {\n      if (error.status === 404) return this.create(attrs, options);else return throwError(error);\n    }));\n  }\n  /**\n   * Save an entity in the entity set.\n   * @param attrs The attributes for the entity.\n   * @param method The method to use.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  save(attrs, _a = {}) {\n    var {\n      etag,\n      method\n    } = _a,\n        options = __rest(_a, [\"etag\", \"method\"]);\n\n    let schema = this.structuredTypeSchema;\n    if (method === undefined && schema !== undefined && schema.isCompoundKey()) return throwError(() => new Error('save: Composite key require a specific method, use create/update/patch'));\n    let key = schema && schema.resolveKey(attrs);\n    if (method === undefined) method = key !== undefined ? 'update' : 'create';\n    if ((method === 'update' || method === 'modify') && key === undefined) return throwError(() => new Error(\"save: Can't update/patch entity without key\"));\n    return method === 'create' ? this.create(attrs, options) : method === 'modify' ? this.modify(key, attrs, Object.assign({\n      etag\n    }, options)) : this.update(key, attrs, Object.assign({\n      etag\n    }, options));\n  }\n\n}\n/**\n * OData Singleton Service\n * www.odata.org/getting-started/advanced-tutorial/#singleton\n */\n\n\nclass ODataSingletonService extends ODataEntityService {\n  /**\n   * Get the entity resource for this service.\n   * @param key The entity key.\n   */\n  entity() {\n    return this.client.singleton(this.name, this.apiNameOrEntityType);\n  }\n  /**\n   * Attach an existing model to this service.\n   * @param model The model to attach.\n   */\n\n\n  attach(model) {\n    model.attach(this.entity());\n  }\n  /**\n   * The schema for the singleton.\n   */\n\n\n  get singletonSchema() {\n    return this.api.findEntitySetByName(this.name);\n  }\n  /**\n   * Update the singleton entity\n   * @param attrs The attributes for the entity.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  update(attrs, options) {\n    const res = this.entity();\n    return res.update(attrs, options);\n  }\n  /**\n   * Patch the singleton entity\n   * @param attrs The attributes for the entity.\n   * @param etag The etag for the entity.\n   * @param options The options for the request.\n   */\n\n\n  patch(attrs, options) {\n    const res = this.entity();\n    return res.modify(attrs, options);\n  }\n\n}\n\nlet ODataServiceFactory = /*#__PURE__*/(() => {\n  class ODataServiceFactory {\n    constructor(client) {\n      this.client = client;\n    }\n    /**\n     * Factory method to create an entity set service.\n     * @param entitySetName Name of the entity set.\n     * @param apiNameOrEntityType Name of the API or the type of the entity.\n     */\n\n\n    entitySet(entitySetName, apiNameOrEntityType) {\n      return new class extends ODataEntitySetService {}(this.client, entitySetName, apiNameOrEntityType);\n    }\n    /** Factory method to create a singleton service.\n     * @param singletonName Name of the singleton.\n     * @param apiNameOrEntityType Name of the API or the type of the entity.\n     */\n\n\n    singleton(singletonName, apiNameOrEntityType) {\n      return new class extends ODataSingletonService {}(this.client, singletonName, apiNameOrEntityType);\n    }\n\n  }\n\n  ODataServiceFactory.fac = function ODataServiceFactory_Factory(t) {\n    return new (t || ODataServiceFactory)(i0.inject(ODataClient));\n  };\n\n  ODataServiceFactory.prov = /* @__PURE__ */i0.defineInjectable({\n    token: ODataServiceFactory,\n    factory: ODataServiceFactory.fac\n  });\n  return ODataServiceFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createSettings(configs) {\n  return new ODataSettings(...configs);\n}\n\nlet ODataModule = /*#__PURE__*/(() => {\n  class ODataModule {\n    static forRoot(...configs) {\n      return {\n        ngModule: ODataModule,\n        providers: [{\n          provide: ODATA_CONFIGURATIONS,\n          useValue: configs\n        }, {\n          provide: ODataSettings,\n          useFactory: createSettings,\n          deps: [ODATA_CONFIGURATIONS]\n        }, ODataClient, ODataServiceFactory]\n      };\n    }\n\n  }\n\n  ODataModule.fac = function ODataModule_Factory(t) {\n    return new (t || ODataModule)();\n  };\n\n  ODataModule.mod = /* @__PURE__ */i0.defineNgModule({\n    type: ODataModule\n  });\n  ODataModule.inj = /* @__PURE__ */i0.defineInjector({\n    providers: [ODataClient, ODataServiceFactory],\n    imports: [HttpClientModule]\n  });\n  return ODataModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of angular-odata\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BUBBLING, Dates, Durations, EDM_PARSERS, Enums, Http, INCLUDE_DEEP, INCLUDE_SHALLOW, ITEM_ROOT, Model, ModelField, NONE_PARSER, ODATA_CONFIGURATIONS, OData, ODataActionResource, ODataAnnotations, ODataApi, ODataBaseService, ODataBatchRequest, ODataBatchResource, ODataCache, ODataCallable, ODataCallableParser, ODataClient, ODataCollection, ODataCountResource, ODataEntitiesAnnotations, ODataEntityAnnotations, ODataEntityContainer, ODataEntityResource, ODataEntitySet, ODataEntitySetResource, ODataEntitySetService, ODataEntityTypeKey, ODataEnumType, ODataEnumTypeFieldParser, ODataEnumTypeParser, ODataFunctionResource, ODataInMemoryCache, ODataInStorageCache, ODataMediaResource, ODataMetadata, ODataMetadataResource, ODataModel, ODataModelEvent, ODataModelField, ODataModelOptions, ODataModelState, ODataModule, ODataNavigationPropertyResource, ODataParameterParser, ODataPathSegments, ODataPathSegmentsHandler, ODataPropertyAnnotations, ODataPropertyResource, ODataQueryOptionHandler, ODataQueryOptions, ODataQueryOptionsHandler, ODataReferenceResource, ODataReferential, ODataRequest, ODataResource, ODataResponse, ODataSchema, ODataServiceFactory, ODataSettings, ODataSingletonResource, ODataSingletonService, ODataStructuredType, ODataStructuredTypeFieldParser, ODataStructuredTypeParser, ODataValueResource, Objects, PathSegmentNames, QueryCustomTypes, QueryOptionNames, RESERVED_FIELD_NAMES, SegmentHandler, StandardAggregateMethods, Strings, Types, Urls, alias, binary, buildPathAndQuery, createSettings, duration, isQueryCustomType, normalizeValue, raw }; //# sourceMappingURL=vigouredelaruse-angular-odata.mjs.map","map":null,"metadata":{},"sourceType":"module"}