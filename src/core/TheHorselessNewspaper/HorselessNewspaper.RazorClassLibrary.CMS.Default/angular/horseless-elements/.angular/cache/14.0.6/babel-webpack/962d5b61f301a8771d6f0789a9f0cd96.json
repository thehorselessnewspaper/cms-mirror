{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { HttpHeaders } from '@angular/common/http';\nimport { AutoUnsubscribe } from 'ngx-auto-unsubscribe';\nimport { BehaviorSubject, skip, catchError, map, concatMap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../services/configuration-endpoint.service\";\nimport * as i2 from \"@vigouredelaruse/angular-odata\";\nimport * as i3 from \"@wizardcontrollerprerelease/horseless-contentapi-lib\";\nlet TenantChooserService = class TenantChooserService {\n  constructor(clientConfigSvc, factory, tenantService) {\n    this.factory = factory;\n    this.tenantService = tenantService;\n    console.log(\"TenantChooserService starting\");\n    this.clientConfigService = clientConfigSvc;\n    this.restClientConfiguration$ = this.clientConfigService.clientConfiguration$;\n    this.hostingEntitiesTenantsSubject = new BehaviorSubject(new Array());\n    this.contentEntitiesTenantsSubject = new BehaviorSubject(new Array());\n  }\n\n  pullHostingEntitiesTenantsByOffset(offset, rowCount) {\n    console.log(`pullHostingEntitiesTenantsByOffset starting`); //init service\n\n    let contentTenantsSvc = this.factory.entitySet('Tenant', 'TheHorselessNewspaper.Schemas.HostingModel.HostingEntities.Tenant');\n    console.log(`pullHostingEntitiesTenantsByOffset is getting client configuration`);\n    this.restClientConfiguration$.pipe(skip(1), map(clientConfig => {\n      console.log(`pullHostingEntitiesTenantsByOffset finished getting client configuration: data was ` + clientConfig);\n      let baseUrl = clientConfig.ODataEndpoint + \"/ODataHosting/\";\n      contentTenantsSvc.api.serviceRootUrl = baseUrl;\n      return clientConfig;\n    }), concatMap(clientConfig => {\n      const headers = new HttpHeaders({\n        'Authorization': `Bearer ${clientConfig.AccessToken}`,\n        'Accept': 'odata.metadata=full',\n        '__tenant__': clientConfig.TenantIdentifier\n      });\n      console.log('odata service root url= ' + contentTenantsSvc.api.serviceRootUrl);\n      let tenantEntities = contentTenantsSvc.entities(); // build query\n\n      tenantEntities.query(q => {\n        q.orderBy(h => h.e().ascending(h.s.CreatedAt));\n        q.expand({\n          AccessControlEntries: {// expand: {\n            //   AccessControlEntries: {\n            //     select: [\"AccessControlEntries\"]\n            //   }\n            // }\n          },\n          Owners: {// expand: {\n            //   Owners: {\n            //     select: [\"Owners\"]\n            //   }\n            // }\n          },\n          Accounts: {// expand: {\n            //   OwnedPrincipals: {\n            //     select: [\"OwnedPrincipals\"]\n            //   }\n            // }\n          }\n        });\n        q.skip(offset);\n        q.top(rowCount);\n      });\n      console.log(`pullHostingEntitiesTenantsByOffset fetching`);\n      return tenantEntities.fetch({\n        withCount: true,\n        headers: headers\n      }).pipe(map(entities => {\n        console.log(`pullHostingEntitiesTenantsByOffset is emitting entities`);\n\n        if (entities != null && entities != undefined && entities.entities != null && entities.entities != undefined) {\n          this.hostingEntitiesTenantsSubject.next(entities.entities);\n          this.contentEntitiesTenantsCount = entities.annots.count;\n        } // return entities;\n\n      }), catchError(err => {\n        console.log(`pullHostingEntitiesTenantsByOffset handling error ${err}`);\n        return new Array();\n      }));\n    }), catchError(err => {\n      console.log(`pullHostingEntitiesTenantsByOffset handling error ${err}`);\n      return new Array();\n    })).subscribe(piped => {\n      console.log(`restClientConfiguration$ pipe subscriber executed`);\n    });\n  }\n\n  pullContentEntitiesTenantsByOffset(offset, rowCount) {\n    console.log(`pullContentEntitiesTenantsByOffset starting`); //init service\n\n    let contentTenantsSvc = this.factory.entitySet('Tenant', 'TheHorselessNewspaper.Schemas.ContentModel.ContentEntities.Tenant');\n    let tenantEntities = contentTenantsSvc.entities();\n    this.restClientConfiguration$.pipe(skip(1), map(clientConfig => {\n      console.log(`pullContentEntitiesTenantsByOffset has client config`);\n      let baseUrl = clientConfig.ODataEndpoint + \"/ODataContent/\";\n      contentTenantsSvc.api.serviceRootUrl = baseUrl;\n      console.log('odata service root url= ' + contentTenantsSvc.api.serviceRootUrl);\n      return clientConfig;\n    }), concatMap(clientConfig => {\n      const headers = new HttpHeaders({\n        'Authorization': `Bearer ${clientConfig.AccessToken}`,\n        'Accept': 'odata.metadata=full',\n        '__tenant__': clientConfig.TenantIdentifier\n      }); // build query\n\n      tenantEntities.query(q => {\n        q.orderBy(h => h.e().ascending(h.s.CreatedAt));\n        q.expand({\n          AccessControlEntries: {// expand: {\n            //   AccessControlEntries: {\n            //     select: [\"AccessControlEntries\"]\n            //   }\n            // }\n          },\n          Owners: {// expand: {\n            //   Owners: {\n            //     select: [\"Owners\"]\n            //   }\n            // }\n          },\n          Accounts: {// expand: {\n            //   OwnedPrincipals: {\n            //     select: [\"OwnedPrincipals\"]\n            //   }\n            // }\n          }\n        });\n        q.skip(offset);\n        q.top(rowCount);\n      });\n      console.log(`pullContentEntitiesTenantsByOffset is fetching`);\n      return tenantEntities.fetch({\n        withCount: true,\n        headers: headers\n      }).pipe(map(entities => {\n        console.log(`pullContentEntitiesTenantsByOffset is emitting entities`);\n\n        if (entities != null && entities != undefined && entities.entities != null && entities.entities != undefined) {\n          this.contentEntitiesTenantsSubject.next(entities.entities);\n          this.contentEntitiesTenantsCount = entities.annots.count;\n        }\n      }), catchError(err => {\n        console.log(`pullContentEntitiesTenantsByOffset handling error ${err}`);\n        return new Array();\n      }));\n    })).subscribe(piped => {\n      console.log(`this.restClientConfiguration$.pipe subscriber is emitting entities`);\n    });\n  }\n\n  pullContentEntitiesTenantsCount() {\n    let ret = new Array();\n    console.log(`pullContentEntitiesTenantsCount is getting client configuration`); //init service\n\n    let contentTenantsSvc = this.factory.entitySet('Tenant', 'TheHorselessNewspaper.Schemas.ContentModel.ContentEntities.Tenant');\n    this.restClientConfiguration$.pipe(skip(1), concatMap(clientConfig => {\n      let baseUrl = clientConfig.ODataEndpoint + \"/ODataContent/\";\n      contentTenantsSvc.api.serviceRootUrl = baseUrl;\n      const headers = new HttpHeaders({\n        'Authorization': `Bearer ${clientConfig.AccessToken}`,\n        'Accept': 'odata.metadata=full',\n        '__tenant__': clientConfig.TenantIdentifier\n      });\n      console.log('pullContentEntitiesTenantsCount odata service root url= ' + contentTenantsSvc.api.serviceRootUrl);\n      let tenantEntities = contentTenantsSvc.entities();\n      return tenantEntities.count().fetch({\n        headers: headers\n      }).pipe(map(odataResponse => {\n        console.log(\"pullContentEntitiesTenantsCount has a count\");\n        this.contentEntitiesTenantsCount = odataResponse;\n        return odataResponse;\n      }));\n    })).subscribe(piped => {\n      console.log(`this.restClientConfiguration$.pipe subscriber executing`);\n    });\n  }\n\n  pullHostingEntitiesTenantsCount() {\n    let ret = new Array();\n    console.log(`pullHostingEntitiesTenantsCount is getting client configuration`); //init service\n\n    let contentTenantsSvc = this.factory.entitySet('Tenant', 'TheHorselessNewspaper.Schemas.HostingModel.HostingEntities.Tenant');\n    this.restClientConfiguration$.pipe(skip(1), concatMap(clientConfig => {\n      console.log(`pullHostingEntitiesTenantsCount finished getting client configuration with data ` + clientConfig);\n      let baseUrl = clientConfig.ODataEndpoint + \"/ODataHosting/\";\n      contentTenantsSvc.api.serviceRootUrl = baseUrl;\n      const headers = new HttpHeaders({\n        'Authorization': `Bearer ${clientConfig.AccessToken}`,\n        'Accept': 'odata.metadata=full',\n        '__tenant__': clientConfig.TenantIdentifier\n      });\n      console.log('odata service root url= ' + contentTenantsSvc.api.serviceRootUrl);\n      let tenantEntities = contentTenantsSvc.entities();\n      return tenantEntities.count().fetch({\n        headers: headers\n      }).pipe(map(oDataResponse => {\n        this.hostingEntitiesTenantsCount = oDataResponse;\n      }));\n    })).subscribe(piped => {\n      console.log(`this.restClientConfiguration$.pipe subscriber executing`);\n    });\n  }\n\n  ngOnDestroy() {// We'll throw an error if it doesn't\n  }\n\n};\n\nTenantChooserService.ɵfac = function TenantChooserService_Factory(t) {\n  return new (t || TenantChooserService)(i0.ɵɵinject(i1.ConfigurationEndpointService), i0.ɵɵinject(i2.ODataServiceFactory), i0.ɵɵinject(i3.TenantRESTService));\n};\n\nTenantChooserService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TenantChooserService,\n  factory: TenantChooserService.ɵfac,\n  providedIn: 'any'\n});\nTenantChooserService = __decorate([AutoUnsubscribe()], TenantChooserService);\nexport { TenantChooserService };","map":null,"metadata":{},"sourceType":"module"}