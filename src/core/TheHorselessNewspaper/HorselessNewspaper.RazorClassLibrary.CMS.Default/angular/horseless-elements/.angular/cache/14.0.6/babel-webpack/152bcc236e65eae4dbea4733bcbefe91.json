{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { HttpHeaders } from '@angular/common/http';\nimport { AutoUnsubscribe } from \"ngx-auto-unsubscribe\";\nimport { BehaviorSubject, catchError, EMPTY, map, throwError } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nlet ConfigurationEndpointService = class ConfigurationEndpointService {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.accessToken = '';\n    this.clientConfiguration$ = new BehaviorSubject({});\n    this.probeClientConfiguration();\n  }\n  /**\r\n   * supporting getting claims identity\r\n   * auth token from server by delegating\r\n   * auth to the browser cookies\r\n   */\n\n\n  getAccessToken() {\n    return this.accessToken;\n  }\n  /**\r\n   * calls the horseless site loaded in the browser\r\n   * and sends control channel commands to the\r\n   * RestClientConfiguration endpoint\r\n   * then\r\n   * @returns Observable<SecurityRestClientConfiguration>\r\n   */\n\n\n  probeClientConfiguration() {\n    let url = window.location.href;\n    let headers = new HttpHeaders(); // command channel message to the client configuration endpoint middleware\n\n    headers = headers.set('RestClientConfigurationEndpoint', 'get');\n    console.log(`probeClientConfiguration getting client configuration for ${url}`);\n    this.httpClient.post(url, '', {\n      headers: headers\n    }).pipe(map(clientConfig => {\n      console.log(`probeClientConfiguration handling client configuration result for ${url}`);\n      this.clientConfiguration$.next(clientConfig);\n      this.accessToken = clientConfig.AccessToken;\n    }), catchError(err => {\n      console.log(`probeClientConfiguration handling error ${err}`);\n      return EMPTY;\n    })).subscribe(piped => {\n      console.log(`probeClientConfiguration pipe subscriber got client configuration for ${url}`);\n    });\n  }\n\n  handleError(error) {\n    if (error.status === 0) {\n      // A client-side or network error occurred. Handle it accordingly.\n      console.error('An error occurred:', error.error);\n    } else {\n      // The backend returned an unsuccessful response code.\n      // The response body may contain clues as to what went wrong.\n      console.error(`Backend returned code ${error.status}, body was: `, error.error);\n    } // Return an observable with a user-facing error message.\n\n\n    return throwError(() => new Error('Something bad happened; please try again later.'));\n  }\n\n  ngOnDestroy() {// We'll throw an error if it doesn't\n  }\n\n};\n\nConfigurationEndpointService.ɵfac = function ConfigurationEndpointService_Factory(t) {\n  return new (t || ConfigurationEndpointService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nConfigurationEndpointService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ConfigurationEndpointService,\n  factory: ConfigurationEndpointService.ɵfac,\n  providedIn: 'any'\n});\nConfigurationEndpointService = __decorate([AutoUnsubscribe()], ConfigurationEndpointService);\nexport { ConfigurationEndpointService };","map":null,"metadata":{},"sourceType":"module"}