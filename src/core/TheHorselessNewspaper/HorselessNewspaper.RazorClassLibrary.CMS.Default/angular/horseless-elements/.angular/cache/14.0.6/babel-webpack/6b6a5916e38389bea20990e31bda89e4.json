{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, NgModule } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, Observable, throwError, timer, Subject, tap as tap$1, catchError as catchError$1, forkJoin, TimeoutError, switchMap as switchMap$1, map as map$1 } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, take, switchMap, retryWhen, catchError, retry, concatMap, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\nlet HttpBaseService = /*#__PURE__*/(() => {\n  class HttpBaseService {\n    constructor(http) {\n      this.http = http;\n    }\n\n    get(url, params) {\n      return this.http.get(url, params);\n    }\n\n    post(url, body, params) {\n      return this.http.post(url, body, params);\n    }\n\n  }\n\n  HttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n    return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  HttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HttpBaseService,\n    factory: HttpBaseService.ɵfac\n  });\n  return HttpBaseService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\nlet DataService = /*#__PURE__*/(() => {\n  class DataService {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n    }\n\n    get(url, config, token) {\n      const headers = this.prepareHeaders(token);\n      const params = this.prepareParams(config);\n      return this.httpClient.get(url, {\n        headers,\n        params\n      });\n    }\n\n    post(url, body, config, headersParams) {\n      const headers = headersParams || this.prepareHeaders();\n      const params = this.prepareParams(config);\n      return this.httpClient.post(url, body, {\n        headers,\n        params\n      });\n    }\n\n    prepareHeaders(token) {\n      let headers = new HttpHeaders();\n      headers = headers.set('Accept', 'application/json');\n\n      if (!!token) {\n        headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n      }\n\n      return headers;\n    }\n\n    prepareParams(config) {\n      let params = new HttpParams();\n      const {\n        ngswBypass\n      } = config;\n\n      if (ngswBypass) {\n        params = params.set(NGSW_CUSTOM_PARAM, '');\n      }\n\n      return params;\n    }\n\n  }\n\n  DataService.ɵfac = function DataService_Factory(t) {\n    return new (t || DataService)(i0.ɵɵinject(HttpBaseService));\n  };\n\n  DataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DataService,\n    factory: DataService.ɵfac\n  });\n  return DataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes = /*#__PURE__*/(() => {\n  (function (EventTypes) {\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\n    EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\n    EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\n  })(EventTypes || (EventTypes = {}));\n\n  return EventTypes;\n})();\nvar LogLevel = /*#__PURE__*/(() => {\n  (function (LogLevel) {\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n  })(LogLevel || (LogLevel = {}));\n\n  return LogLevel;\n})();\n\n/**\r\n * Implement this class-interface to create a custom logger service.\r\n */\nlet AbstractLoggerService = /*#__PURE__*/(() => {\n  class AbstractLoggerService {}\n\n  AbstractLoggerService.ɵfac = function AbstractLoggerService_Factory(t) {\n    return new (t || AbstractLoggerService)();\n  };\n\n  AbstractLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbstractLoggerService,\n    factory: AbstractLoggerService.ɵfac\n  });\n  return AbstractLoggerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoggerService = /*#__PURE__*/(() => {\n  class LoggerService {\n    constructor(abstractLoggerService) {\n      this.abstractLoggerService = abstractLoggerService;\n    }\n\n    logError(configuration, message, ...args) {\n      if (this.loggingIsTurnedOff(configuration)) {\n        return;\n      }\n\n      const {\n        configId\n      } = configuration;\n\n      if (!!args && !!args.length) {\n        this.abstractLoggerService.logError(`[ERROR] ${configId} - ${message}`, ...args);\n      } else {\n        this.abstractLoggerService.logError(`[ERROR] ${configId} - ${message}`);\n      }\n    }\n\n    logWarning(configuration, message, ...args) {\n      if (!this.logLevelIsSet(configuration)) {\n        return;\n      }\n\n      if (this.loggingIsTurnedOff(configuration)) {\n        return;\n      }\n\n      if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Warn)) {\n        return;\n      }\n\n      const {\n        configId\n      } = configuration;\n\n      if (!!args && !!args.length) {\n        this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${message}`, ...args);\n      } else {\n        this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${message}`);\n      }\n    }\n\n    logDebug(configuration, message, ...args) {\n      if (!this.logLevelIsSet(configuration)) {\n        return;\n      }\n\n      if (this.loggingIsTurnedOff(configuration)) {\n        return;\n      }\n\n      if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Debug)) {\n        return;\n      }\n\n      const {\n        configId\n      } = configuration;\n\n      if (!!args && !!args.length) {\n        this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${message}`, ...args);\n      } else {\n        this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${message}`);\n      }\n    }\n\n    currentLogLevelIsEqualOrSmallerThan(configuration, logLevelToCompare) {\n      const {\n        logLevel\n      } = configuration || {};\n      return logLevel <= logLevelToCompare;\n    }\n\n    logLevelIsSet(configuration) {\n      const {\n        logLevel\n      } = configuration || {};\n\n      if (logLevel === null) {\n        return false;\n      }\n\n      if (logLevel === undefined) {\n        return false;\n      }\n\n      return true;\n    }\n\n    loggingIsTurnedOff(configuration) {\n      const {\n        logLevel\n      } = configuration || {};\n      return logLevel === LogLevel.None;\n    }\n\n  }\n\n  LoggerService.ɵfac = function LoggerService_Factory(t) {\n    return new (t || LoggerService)(i0.ɵɵinject(AbstractLoggerService));\n  };\n\n  LoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoggerService,\n    factory: LoggerService.ɵfac\n  });\n  return LoggerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nlet AbstractSecurityStorage = /*#__PURE__*/(() => {\n  class AbstractSecurityStorage {}\n\n  AbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n    return new (t || AbstractSecurityStorage)();\n  };\n\n  AbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbstractSecurityStorage,\n    factory: AbstractSecurityStorage.ɵfac\n  });\n  return AbstractSecurityStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BrowserStorageService = /*#__PURE__*/(() => {\n  class BrowserStorageService {\n    constructor(loggerService, abstractSecurityStorage) {\n      this.loggerService = loggerService;\n      this.abstractSecurityStorage = abstractSecurityStorage;\n    }\n\n    read(key, configuration) {\n      const {\n        configId\n      } = configuration;\n\n      if (!this.hasStorage()) {\n        this.loggerService.logDebug(configuration, `Wanted to read '${key}' but Storage was undefined`);\n        return null;\n      }\n\n      const storedConfig = this.abstractSecurityStorage.read(configId);\n\n      if (!storedConfig) {\n        return null;\n      }\n\n      return JSON.parse(storedConfig);\n    }\n\n    write(value, configuration) {\n      const {\n        configId\n      } = configuration;\n\n      if (!this.hasStorage()) {\n        this.loggerService.logDebug(configuration, `Wanted to write '${value}' but Storage was falsy`);\n        return false;\n      }\n\n      value = value || null;\n      this.abstractSecurityStorage.write(configId, JSON.stringify(value));\n      return true;\n    }\n\n    remove(key, configuration) {\n      if (!this.hasStorage()) {\n        this.loggerService.logDebug(configuration, `Wanted to remove '${key}' but Storage was falsy`);\n        return false;\n      } // const storage = this.getStorage(configuration);\n      // if (!storage) {\n      //   this.loggerService.logDebug(configuration, `Wanted to write '${key}' but Storage was falsy`);\n      //   return false;\n      // }\n\n\n      this.abstractSecurityStorage.remove(key);\n      return true;\n    } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n    clear(configuration) {\n      if (!this.hasStorage()) {\n        this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n        return false;\n      } // const storage = this.getStorage(configuration);\n      // if (!storage) {\n      //   this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n      //   return false;\n      // }\n\n\n      this.abstractSecurityStorage.clear();\n      return true;\n    }\n\n    hasStorage() {\n      return typeof Storage !== 'undefined';\n    }\n\n  }\n\n  BrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n    return new (t || BrowserStorageService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AbstractSecurityStorage));\n  };\n\n  BrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BrowserStorageService,\n    factory: BrowserStorageService.ɵfac\n  });\n  return BrowserStorageService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StoragePersistenceService = /*#__PURE__*/(() => {\n  class StoragePersistenceService {\n    constructor(browserStorageService) {\n      this.browserStorageService = browserStorageService;\n    }\n\n    read(key, config) {\n      const storedConfig = this.browserStorageService.read(key, config) || {};\n      return storedConfig[key];\n    }\n\n    write(key, value, config) {\n      const storedConfig = this.browserStorageService.read(key, config) || {};\n      storedConfig[key] = value;\n      return this.browserStorageService.write(storedConfig, config);\n    }\n\n    remove(key, config) {\n      const storedConfig = this.browserStorageService.read(key, config) || {};\n      delete storedConfig[key];\n      this.browserStorageService.write(storedConfig, config);\n    }\n\n    clear(config) {\n      this.browserStorageService.clear(config);\n    }\n\n    resetStorageFlowData(config) {\n      this.remove('session_state', config);\n      this.remove('storageSilentRenewRunning', config);\n      this.remove('codeVerifier', config);\n      this.remove('userData', config);\n      this.remove('storageCustomParamsAuthRequest', config);\n      this.remove('access_token_expires_at', config);\n      this.remove('storageCustomParamsRefresh', config);\n      this.remove('storageCustomParamsEndSession', config);\n      this.remove('reusable_refresh_token', config);\n    }\n\n    resetAuthStateInStorage(config) {\n      this.remove('authzData', config);\n      this.remove('reusable_refresh_token', config);\n      this.remove('authnResult', config);\n    }\n\n    getAccessToken(config) {\n      return this.read('authzData', config);\n    }\n\n    getIdToken(config) {\n      var _a;\n\n      return (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.id_token;\n    }\n\n    getRefreshToken(config) {\n      var _a;\n\n      let refreshToken = (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.refresh_token;\n\n      if (!refreshToken && config.allowUnsafeReuseRefreshToken) {\n        return this.read('reusable_refresh_token', config);\n      }\n\n      return refreshToken;\n    }\n\n    getAuthenticationResult(config) {\n      return this.read('authnResult', config);\n    }\n\n  }\n\n  StoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n    return new (t || StoragePersistenceService)(i0.ɵɵinject(BrowserStorageService));\n  };\n\n  StoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StoragePersistenceService,\n    factory: StoragePersistenceService.ɵfac\n  });\n  return StoragePersistenceService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PublicEventsService = /*#__PURE__*/(() => {\n  class PublicEventsService {\n    constructor() {\n      this.notify = new ReplaySubject(1);\n    }\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\n\n\n    fireEvent(type, value) {\n      this.notify.next({\n        type,\n        value\n      });\n    }\n    /**\r\n     * Wires up the event notification observable.\r\n     */\n\n\n    registerForEvents() {\n      return this.notify.asObservable();\n    }\n\n  }\n\n  PublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n    return new (t || PublicEventsService)();\n  };\n\n  PublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PublicEventsService,\n    factory: PublicEventsService.ɵfac\n  });\n  return PublicEventsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PARTS_OF_TOKEN = 3;\nlet TokenHelperService = /*#__PURE__*/(() => {\n  class TokenHelperService {\n    constructor(loggerService, document) {\n      this.loggerService = loggerService;\n      this.document = document;\n    }\n\n    getTokenExpirationDate(dataIdToken) {\n      if (!dataIdToken.hasOwnProperty('exp')) {\n        return new Date(new Date().toUTCString());\n      }\n\n      const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n      date.setUTCSeconds(dataIdToken.exp);\n      return date;\n    }\n\n    getSigningInputFromToken(token, encoded, configuration) {\n      if (!this.tokenIsValid(token, configuration)) {\n        return '';\n      }\n\n      const header = this.getHeaderFromToken(token, encoded, configuration);\n      const payload = this.getPayloadFromToken(token, encoded, configuration);\n      return [header, payload].join('.');\n    }\n\n    getHeaderFromToken(token, encoded, configuration) {\n      if (!this.tokenIsValid(token, configuration)) {\n        return {};\n      }\n\n      return this.getPartOfToken(token, 0, encoded);\n    }\n\n    getPayloadFromToken(token, encoded, configuration) {\n      if (!this.tokenIsValid(token, configuration)) {\n        return {};\n      }\n\n      return this.getPartOfToken(token, 1, encoded);\n    }\n\n    getSignatureFromToken(token, encoded, configuration) {\n      if (!this.tokenIsValid(token, configuration)) {\n        return {};\n      }\n\n      return this.getPartOfToken(token, 2, encoded);\n    }\n\n    getPartOfToken(token, index, encoded) {\n      const partOfToken = this.extractPartOfToken(token, index);\n\n      if (encoded) {\n        return partOfToken;\n      }\n\n      const result = this.urlBase64Decode(partOfToken);\n      return JSON.parse(result);\n    }\n\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n      switch (output.length % 4) {\n        case 0:\n          break;\n\n        case 2:\n          output += '==';\n          break;\n\n        case 3:\n          output += '=';\n          break;\n\n        default:\n          throw Error('Illegal base64url string!');\n      }\n\n      const decoded = typeof this.document.defaultView !== 'undefined' ? this.document.defaultView.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n      try {\n        // Going backwards: from byte stream, to percent-encoding, to original string.\n        return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n      } catch (err) {\n        return decoded;\n      }\n    }\n\n    tokenIsValid(token, configuration) {\n      if (!token) {\n        this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);\n        return false;\n      }\n\n      if (!token.includes('.')) {\n        this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);\n        return false;\n      }\n\n      const parts = token.split('.');\n\n      if (parts.length !== PARTS_OF_TOKEN) {\n        this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n        return false;\n      }\n\n      return true;\n    }\n\n    extractPartOfToken(token, index) {\n      return token.split('.')[index];\n    }\n\n  }\n\n  TokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n    return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(DOCUMENT));\n  };\n\n  TokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TokenHelperService,\n    factory: TokenHelperService.ɵfac\n  });\n  return TokenHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CryptoService = /*#__PURE__*/(() => {\n  class CryptoService {\n    constructor(doc) {\n      this.doc = doc;\n    }\n\n    getCrypto() {\n      // support for IE,  (window.crypto || window.msCrypto)\n      return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n    }\n\n  }\n\n  CryptoService.ɵfac = function CryptoService_Factory(t) {\n    return new (t || CryptoService)(i0.ɵɵinject(DOCUMENT));\n  };\n\n  CryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CryptoService,\n    factory: CryptoService.ɵfac\n  });\n  return CryptoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet JwtWindowCryptoService = /*#__PURE__*/(() => {\n  class JwtWindowCryptoService {\n    constructor(cryptoService) {\n      this.cryptoService = cryptoService;\n    }\n\n    generateCodeChallenge(codeVerifier) {\n      return this.calcHash(codeVerifier).pipe(map(challengeRaw => this.base64UrlEncode(challengeRaw)));\n    }\n\n    generateAtHash(accessToken, algorithm) {\n      return this.calcHash(accessToken, algorithm).pipe(map(tokenHash => {\n        let substr = tokenHash.substr(0, tokenHash.length / 2);\n        const tokenHashBase64 = btoa(substr);\n        return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n      }));\n    }\n\n    calcHash(valueToHash, algorithm = 'SHA-256') {\n      const msgBuffer = new TextEncoder().encode(valueToHash);\n      return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map(hashBuffer => {\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        return this.toHashString(hashArray);\n      }));\n    }\n\n    toHashString(byteArray) {\n      let result = '';\n\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n\n      return result;\n    }\n\n    base64UrlEncode(str) {\n      const base64 = btoa(str);\n      return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }\n\n  }\n\n  JwtWindowCryptoService.ɵfac = function JwtWindowCryptoService_Factory(t) {\n    return new (t || JwtWindowCryptoService)(i0.ɵɵinject(CryptoService));\n  };\n\n  JwtWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JwtWindowCryptoService,\n    factory: JwtWindowCryptoService.ɵfac\n  });\n  return JwtWindowCryptoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nlet TokenValidationService = /*#__PURE__*/(() => {\n  class TokenValidationService {\n    constructor(tokenHelperService, loggerService, jwtWindowCryptoService, cryptoService, document) {\n      this.tokenHelperService = tokenHelperService;\n      this.loggerService = loggerService;\n      this.jwtWindowCryptoService = jwtWindowCryptoService;\n      this.cryptoService = cryptoService;\n      this.document = document;\n      this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n    } // id_token C7: The current time MUST be before the time represented by the exp Claim\n    // (possibly allowing for some small leeway to account for clock skew).\n\n\n    hasIdTokenExpired(token, configuration, offsetSeconds, disableIdTokenValidation) {\n      const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);\n      return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds, disableIdTokenValidation);\n    } // id_token C7: The current time MUST be before the time represented by the exp Claim\n    // (possibly allowing for some small leeway to account for clock skew).\n\n\n    validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds, disableIdTokenValidation) {\n      if (disableIdTokenValidation) return true;\n      const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n      offsetSeconds = offsetSeconds || 0;\n\n      if (!tokenExpirationDate) {\n        return false;\n      }\n\n      const tokenExpirationValue = tokenExpirationDate.valueOf();\n      const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n      const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n      this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n      return tokenNotExpired;\n    }\n\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {\n      // value is optional, so if it does not exist, then it has not expired\n      if (!accessTokenExpiresAt) {\n        return true;\n      }\n\n      offsetSeconds = offsetSeconds || 0;\n      const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n      const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n      const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n      this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n      return tokenNotExpired;\n    } // iss\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n    // https scheme that contains scheme, host,\n    // and optionally, port number and path components and no query or fragment components.\n    //\n    // sub\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n    //\n    // aud\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n    // audience value.\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n    //\n    // exp\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n    // the date/ time.\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n    //\n    // iat\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n    // 1970- 01 - 01T00: 00: 00Z as measured\n    // in UTC until the date/ time.\n\n\n    validateRequiredIdToken(dataIdToken, configuration) {\n      let validated = true;\n\n      if (!dataIdToken.hasOwnProperty('iss')) {\n        validated = false;\n        this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');\n      }\n\n      if (!dataIdToken.hasOwnProperty('sub')) {\n        validated = false;\n        this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');\n      }\n\n      if (!dataIdToken.hasOwnProperty('aud')) {\n        validated = false;\n        this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');\n      }\n\n      if (!dataIdToken.hasOwnProperty('exp')) {\n        validated = false;\n        this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');\n      }\n\n      if (!dataIdToken.hasOwnProperty('iat')) {\n        validated = false;\n        this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');\n      }\n\n      return validated;\n    } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {\n      if (disableIatOffsetValidation) {\n        return true;\n      }\n\n      if (!dataIdToken.hasOwnProperty('iat')) {\n        return false;\n      }\n\n      const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n      dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n      maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n      const nowInUtc = new Date(new Date().toUTCString());\n      const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n      const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n      this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n      if (diff > 0) {\n        return diff < maxOffsetAllowedInMilliseconds;\n      }\n\n      return -diff < maxOffsetAllowedInMilliseconds;\n    } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n    // The precise method for detecting replay attacks is Client specific.\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n    // The current spec is ambiguous and KeyCloak does send it.\n\n\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {\n      const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n      if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n        this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n        return false;\n      }\n\n      return true;\n    } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n    // MUST exactly match the value of the iss (issuer) Claim.\n\n\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {\n      if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n        this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n        return false;\n      }\n\n      return true;\n    } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n    // by the iss (issuer) Claim as an audience.\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n    // not trusted by the Client.\n\n\n    validateIdTokenAud(dataIdToken, aud, configuration) {\n      if (Array.isArray(dataIdToken.aud)) {\n        const result = dataIdToken.aud.includes(aud);\n\n        if (!result) {\n          this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n          return false;\n        }\n\n        return true;\n      } else if (dataIdToken.aud !== aud) {\n        this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    }\n\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n      if (!dataIdToken) {\n        return false;\n      }\n\n      if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n        return false;\n      }\n\n      return true;\n    } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n    validateIdTokenAzpValid(dataIdToken, clientId) {\n      if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\n        return true;\n      }\n\n      if (dataIdToken.azp === clientId) {\n        return true;\n      }\n\n      return false;\n    }\n\n    validateStateFromHashCallback(state, localState, configuration) {\n      if (state !== localState) {\n        this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n        return false;\n      }\n\n      return true;\n    } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n    validateSignatureIdToken(idToken, jwtkeys, configuration) {\n      if (!jwtkeys || !jwtkeys.keys) {\n        return of(false);\n      }\n\n      const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);\n\n      if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n        this.loggerService.logWarning(configuration, 'id token has no header data');\n        return of(false);\n      }\n\n      const kid = headerData.kid;\n      let alg = headerData.alg;\n      let keys = jwtkeys.keys;\n      let key;\n\n      if (!this.keyAlgorithms.includes(alg)) {\n        this.loggerService.logWarning(configuration, 'alg not supported', alg);\n        return of(false);\n      }\n\n      if (kid) {\n        key = keys.find(k => k['kid'] === kid);\n      } else {\n        let kty = this.alg2kty(alg);\n        let matchingKeys = keys.filter(k => k.kty === kty && k.use === 'sig');\n\n        if (matchingKeys.length > 1) {\n          let error = 'More than one matching key found. Please specify a kid in the id_token header.';\n          this.loggerService.logError(configuration, error);\n          return of(false);\n        } else if (matchingKeys.length === 1) {\n          key = matchingKeys[0];\n        }\n      }\n\n      const algorithm = this.getImportAlg(alg);\n      const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);\n      const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);\n      const agent = this.document.defaultView.navigator.userAgent.toLowerCase();\n\n      if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\n        key.alg = '';\n      }\n\n      const crypto = this.cryptoService.getCrypto();\n      return from(crypto.subtle.importKey('jwk', key, algorithm, false, ['verify'])).pipe(mergeMap(cryptoKey => {\n        const signature = base64url.parse(rawSignature, {\n          loose: true\n        });\n        const algorithm = this.getVerifyAlg(alg);\n        return from(crypto.subtle.verify(algorithm, cryptoKey, signature, new TextEncoder().encode(signingInput)));\n      }), tap(isValid => {\n        if (!isValid) {\n          this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');\n        }\n      }));\n    }\n\n    getImportAlg(alg) {\n      switch (alg.charAt(0)) {\n        case 'R':\n          if (alg.includes('256')) {\n            return {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: 'SHA-256'\n            };\n          } else if (alg.includes('384')) {\n            return {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: 'SHA-384'\n            };\n          } else if (alg.includes('512')) {\n            return {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: 'SHA-512'\n            };\n          } else {\n            return null;\n          }\n\n        case 'E':\n          if (alg.includes('256')) {\n            return {\n              name: 'ECDSA',\n              namedCurve: 'P-256'\n            };\n          } else if (alg.includes('384')) {\n            return {\n              name: 'ECDSA',\n              namedCurve: 'P-384'\n            };\n          } else {\n            return null;\n          }\n\n        default:\n          return null;\n      }\n    }\n\n    getVerifyAlg(alg) {\n      switch (alg.charAt(0)) {\n        case 'R':\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-256'\n          };\n\n        case 'E':\n          if (alg.includes('256')) {\n            return {\n              name: 'ECDSA',\n              hash: 'SHA-256'\n            };\n          } else if (alg.includes('384')) {\n            return {\n              name: 'ECDSA',\n              hash: 'SHA-384'\n            };\n          } else {\n            return null;\n          }\n\n        default:\n          return null;\n      }\n    }\n\n    alg2kty(alg) {\n      switch (alg.charAt(0)) {\n        case 'R':\n          return 'RSA';\n\n        case 'E':\n          return 'EC';\n\n        default:\n          throw new Error('Cannot infer kty from alg: ' + alg);\n      }\n    } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n    ////    if (!header_data.hasOwnProperty('kid')) {\n    ////        // no kid defined in Jose header\n    ////        if (jwtkeys.keys.length != 1) {\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n    ////            return false;\n    ////        }\n    ////    }\n    ////    return true;\n    //// }\n    // Access Token Validation\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n    // is present in the ID Token.\n\n\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {\n      this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n      let sha = 'SHA-256';\n\n      if (idTokenAlg.includes('384')) {\n        sha = 'SHA-384';\n      } else if (idTokenAlg.includes('512')) {\n        sha = 'SHA-512';\n      }\n\n      return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap(hash => {\n        this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);\n\n        if (hash === atHash) {\n          return of(true); // isValid;\n        } else {\n          return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map(newHash => {\n            this.loggerService.logDebug(configuration, '-gen access--' + hash);\n            return newHash === atHash;\n          }));\n        }\n      }));\n    }\n\n    millisToMinutesAndSeconds(millis) {\n      const minutes = Math.floor(millis / 60000);\n      const seconds = (millis % 60000 / 1000).toFixed(0);\n      return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n    }\n\n    calculateNowWithOffset(offsetSeconds) {\n      return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    }\n\n  }\n\n  TokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\n  TokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n    return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JwtWindowCryptoService), i0.ɵɵinject(CryptoService), i0.ɵɵinject(DOCUMENT));\n  };\n\n  TokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TokenValidationService,\n    factory: TokenValidationService.ɵfac\n  });\n  return TokenValidationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\nlet AuthStateService = /*#__PURE__*/(() => {\n  class AuthStateService {\n    constructor(storagePersistenceService, loggerService, publicEventsService, tokenValidationService) {\n      this.storagePersistenceService = storagePersistenceService;\n      this.loggerService = loggerService;\n      this.publicEventsService = publicEventsService;\n      this.tokenValidationService = tokenValidationService;\n      this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n    }\n\n    get authenticated$() {\n      return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n    }\n\n    setAuthenticatedAndFireEvent(allConfigs) {\n      const result = this.composeAuthenticatedResult(allConfigs);\n      this.authenticatedInternal$.next(result);\n    }\n\n    setUnauthenticatedAndFireEvent(currentConfig, allConfigs) {\n      this.storagePersistenceService.resetAuthStateInStorage(currentConfig);\n      const result = this.composeUnAuthenticatedResult(allConfigs);\n      this.authenticatedInternal$.next(result);\n    }\n\n    updateAndPublishAuthState(authenticationResult) {\n      this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n    }\n\n    setAuthorizationData(accessToken, authResult, currentConfig, allConfigs) {\n      this.loggerService.logDebug(currentConfig, `storing the accessToken '${accessToken}'`);\n      this.storagePersistenceService.write('authzData', accessToken, currentConfig);\n      this.persistAccessTokenExpirationTime(authResult, currentConfig);\n      this.setAuthenticatedAndFireEvent(allConfigs);\n    }\n\n    getAccessToken(configuration) {\n      if (!this.isAuthenticated(configuration)) {\n        return null;\n      }\n\n      const token = this.storagePersistenceService.getAccessToken(configuration);\n      return this.decodeURIComponentSafely(token);\n    }\n\n    getIdToken(configuration) {\n      if (!this.isAuthenticated(configuration)) {\n        return null;\n      }\n\n      const token = this.storagePersistenceService.getIdToken(configuration);\n      return this.decodeURIComponentSafely(token);\n    }\n\n    getRefreshToken(configuration) {\n      if (!this.isAuthenticated(configuration)) {\n        return null;\n      }\n\n      const token = this.storagePersistenceService.getRefreshToken(configuration);\n      return this.decodeURIComponentSafely(token);\n    }\n\n    getAuthenticationResult(configuration) {\n      if (!this.isAuthenticated(configuration)) {\n        return null;\n      }\n\n      return this.storagePersistenceService.getAuthenticationResult(configuration);\n    }\n\n    areAuthStorageTokensValid(configuration) {\n      if (!this.isAuthenticated(configuration)) {\n        return false;\n      }\n\n      if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configuration)) {\n        this.loggerService.logDebug(configuration, 'persisted idToken is expired');\n        return false;\n      }\n\n      if (this.hasAccessTokenExpiredIfExpiryExists(configuration)) {\n        this.loggerService.logDebug(configuration, 'persisted accessToken is expired');\n        return false;\n      }\n\n      this.loggerService.logDebug(configuration, 'persisted idToken and accessToken are valid');\n      return true;\n    }\n\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configuration) {\n      const {\n        renewTimeBeforeTokenExpiresInSeconds,\n        enableIdTokenExpiredValidationInRenew,\n        disableIdTokenValidation\n      } = configuration;\n\n      if (!enableIdTokenExpiredValidationInRenew) {\n        return false;\n      }\n\n      const tokenToCheck = this.storagePersistenceService.getIdToken(configuration);\n      const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configuration, renewTimeBeforeTokenExpiresInSeconds, disableIdTokenValidation);\n\n      if (idTokenExpired) {\n        this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n      }\n\n      return idTokenExpired;\n    }\n\n    hasAccessTokenExpiredIfExpiryExists(configuration) {\n      const {\n        renewTimeBeforeTokenExpiresInSeconds\n      } = configuration;\n      const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configuration);\n      const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configuration, renewTimeBeforeTokenExpiresInSeconds);\n      const hasExpired = !accessTokenHasNotExpired;\n\n      if (hasExpired) {\n        this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n      }\n\n      return hasExpired;\n    }\n\n    isAuthenticated(configuration) {\n      const hasAccessToken = !!this.storagePersistenceService.getAccessToken(configuration);\n      const hasIdToken = !!this.storagePersistenceService.getIdToken(configuration);\n      return hasAccessToken && hasIdToken;\n    }\n\n    decodeURIComponentSafely(token) {\n      if (token) {\n        return decodeURIComponent(token);\n      } else {\n        return '';\n      }\n    }\n\n    persistAccessTokenExpirationTime(authResult, configuration) {\n      if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\n        const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n        this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configuration);\n      }\n    }\n\n    composeAuthenticatedResult(allConfigs) {\n      if (allConfigs.length === 1) {\n        const {\n          configId\n        } = allConfigs[0];\n        return {\n          isAuthenticated: true,\n          allConfigsAuthenticated: [{\n            configId,\n            isAuthenticated: true\n          }]\n        };\n      }\n\n      return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n    }\n\n    composeUnAuthenticatedResult(allConfigs) {\n      if (allConfigs.length === 1) {\n        const {\n          configId\n        } = allConfigs[0];\n        return {\n          isAuthenticated: false,\n          allConfigsAuthenticated: [{\n            configId,\n            isAuthenticated: false\n          }]\n        };\n      }\n\n      return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n    }\n\n    checkAllConfigsIfTheyAreAuthenticated(allConfigs) {\n      const allConfigsAuthenticated = allConfigs.map(config => ({\n        configId: config.configId,\n        isAuthenticated: this.isAuthenticated(config)\n      }));\n      const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n      return {\n        allConfigsAuthenticated,\n        isAuthenticated\n      };\n    }\n\n  }\n\n  AuthStateService.ɵfac = function AuthStateService_Factory(t) {\n    return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(TokenValidationService));\n  };\n\n  AuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthStateService,\n    factory: AuthStateService.ɵfac\n  });\n  return AuthStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IFrameService = /*#__PURE__*/(() => {\n  class IFrameService {\n    constructor(doc, loggerService) {\n      this.doc = doc;\n      this.loggerService = loggerService;\n    }\n\n    getExistingIFrame(identifier) {\n      const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n      if (this.isIFrameElement(iFrameOnParent)) {\n        return iFrameOnParent;\n      }\n\n      const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n      if (this.isIFrameElement(iFrameOnSelf)) {\n        return iFrameOnSelf;\n      }\n\n      return null;\n    }\n\n    addIFrameToWindowBody(identifier, config) {\n      const sessionIframe = this.doc.createElement('iframe');\n      sessionIframe.id = identifier;\n      sessionIframe.title = identifier;\n      this.loggerService.logDebug(config, sessionIframe);\n      sessionIframe.style.display = 'none';\n      this.doc.body.appendChild(sessionIframe);\n      return sessionIframe;\n    }\n\n    getIFrameFromParentWindow(identifier) {\n      try {\n        const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\n\n        if (this.isIFrameElement(iFrameElement)) {\n          return iFrameElement;\n        }\n\n        return null;\n      } catch (e) {\n        return null;\n      }\n    }\n\n    getIFrameFromWindow(identifier) {\n      const iFrameElement = this.doc.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    }\n\n    isIFrameElement(element) {\n      return !!element && element instanceof HTMLIFrameElement;\n    }\n\n  }\n\n  IFrameService.ɵfac = function IFrameService_Factory(t) {\n    return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n  };\n\n  IFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IFrameService,\n    factory: IFrameService.ɵfac\n  });\n  return IFrameService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nlet CheckSessionService = /*#__PURE__*/(() => {\n  class CheckSessionService {\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, zone, document) {\n      this.storagePersistenceService = storagePersistenceService;\n      this.loggerService = loggerService;\n      this.iFrameService = iFrameService;\n      this.eventService = eventService;\n      this.zone = zone;\n      this.document = document;\n      this.checkSessionReceived = false;\n      this.lastIFrameRefresh = 0;\n      this.outstandingMessages = 0;\n      this.heartBeatInterval = 3000;\n      this.iframeRefreshInterval = 60000;\n      this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n    }\n\n    get checkSessionChanged$() {\n      return this.checkSessionChangedInternal$.asObservable();\n    }\n\n    isCheckSessionConfigured(configuration) {\n      const {\n        startCheckSession\n      } = configuration;\n      return startCheckSession;\n    }\n\n    start(configuration) {\n      if (!!this.scheduledHeartBeatRunning) {\n        return;\n      }\n\n      const {\n        clientId\n      } = configuration;\n      this.pollServerSession(clientId, configuration);\n    }\n\n    stop() {\n      if (!this.scheduledHeartBeatRunning) {\n        return;\n      }\n\n      this.clearScheduledHeartBeat();\n      this.checkSessionReceived = false;\n    }\n\n    serverStateChanged(configuration) {\n      const {\n        startCheckSession\n      } = configuration;\n      return startCheckSession && this.checkSessionReceived;\n    }\n\n    getExistingIframe() {\n      return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n    }\n\n    init(configuration) {\n      if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n        return of(undefined);\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (!authWellKnownEndPoints) {\n        this.loggerService.logWarning(configuration, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n        return of();\n      }\n\n      const existingIframe = this.getOrCreateIframe(configuration);\n      const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n      if (checkSessionIframe) {\n        existingIframe.contentWindow.location.replace(checkSessionIframe);\n      } else {\n        this.loggerService.logWarning(configuration, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n      }\n\n      return new Observable(observer => {\n        existingIframe.onload = () => {\n          this.lastIFrameRefresh = Date.now();\n          observer.next();\n          observer.complete();\n        };\n      });\n    }\n\n    pollServerSession(clientId, configuration) {\n      this.outstandingMessages = 0;\n\n      const pollServerSessionRecur = () => {\n        this.init(configuration).pipe(take(1)).subscribe(() => {\n          var _a;\n\n          const existingIframe = this.getExistingIframe();\n\n          if (existingIframe && clientId) {\n            this.loggerService.logDebug(configuration, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n            const sessionState = this.storagePersistenceService.read('session_state', configuration);\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n            if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\n              const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\n              this.outstandingMessages++;\n              existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n            } else {\n              this.loggerService.logDebug(configuration, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n              this.checkSessionChangedInternal$.next(true);\n            }\n          } else {\n            this.loggerService.logWarning(configuration, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          } // after sending three messages with no response, fail.\n\n\n          if (this.outstandingMessages > 3) {\n            this.loggerService.logError(configuration, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n          }\n\n          this.zone.runOutsideAngular(() => {\n            this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n          });\n        });\n      };\n\n      pollServerSessionRecur();\n    }\n\n    clearScheduledHeartBeat() {\n      clearTimeout(this.scheduledHeartBeatRunning);\n      this.scheduledHeartBeatRunning = null;\n    }\n\n    messageHandler(configuration, e) {\n      var _a;\n\n      const existingIFrame = this.getExistingIframe();\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n      const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\n      this.outstandingMessages = 0;\n\n      if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n        if (e.data === 'error') {\n          this.loggerService.logWarning(configuration, 'CheckSession - error from check session messageHandler');\n        } else if (e.data === 'changed') {\n          this.loggerService.logDebug(configuration, `CheckSession - ${e} from check session messageHandler`);\n          this.checkSessionReceived = true;\n          this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n          this.checkSessionChangedInternal$.next(true);\n        } else {\n          this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n          this.loggerService.logDebug(configuration, `CheckSession - ${e.data} from check session messageHandler`);\n        }\n      }\n    }\n\n    bindMessageEventToIframe(configId) {\n      const iframeMessageEvent = this.messageHandler.bind(this, configId);\n      this.document.defaultView.addEventListener('message', iframeMessageEvent, false);\n    }\n\n    getOrCreateIframe(configuration) {\n      const existingIframe = this.getExistingIframe();\n\n      if (!existingIframe) {\n        const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configuration);\n        const {\n          configId\n        } = configuration;\n        this.bindMessageEventToIframe(configId);\n        return frame;\n      }\n\n      return existingIframe;\n    }\n\n  }\n\n  CheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n    return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n  };\n\n  CheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CheckSessionService,\n    factory: CheckSessionService.ɵfac\n  });\n  return CheckSessionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CurrentUrlService = /*#__PURE__*/(() => {\n  class CurrentUrlService {\n    constructor(doc) {\n      this.doc = doc;\n    }\n\n    getStateParamFromCurrentUrl() {\n      const currentUrl = this.getCurrentUrl();\n      const parsedUrl = new URL(currentUrl);\n      const urlParams = new URLSearchParams(parsedUrl.search);\n      const stateFromUrl = urlParams.get('state');\n      return stateFromUrl;\n    }\n\n    currentUrlHasStateParam() {\n      return !!this.getStateParamFromCurrentUrl();\n    }\n\n    getCurrentUrl() {\n      return this.doc.defaultView.location.toString();\n    }\n\n  }\n\n  CurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n    return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n  };\n\n  CurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CurrentUrlService,\n    factory: CurrentUrlService.ɵfac\n  });\n  return CurrentUrlService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable no-shadow */\n\n\nvar ValidationResult = /*#__PURE__*/(() => {\n  (function (ValidationResult) {\n    ValidationResult[\"NotSet\"] = \"NotSet\";\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n    ValidationResult[\"Ok\"] = \"Ok\";\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n  })(ValidationResult || (ValidationResult = {}));\n\n  return ValidationResult;\n})();\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nlet RandomService = /*#__PURE__*/(() => {\n  class RandomService {\n    constructor(cryptoService, loggerService) {\n      this.cryptoService = cryptoService;\n      this.loggerService = loggerService;\n    }\n\n    createRandom(requiredLength, configuration) {\n      if (requiredLength <= 0) {\n        return '';\n      }\n\n      if (requiredLength > 0 && requiredLength < 7) {\n        this.loggerService.logWarning(configuration, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n        requiredLength = 10;\n      }\n\n      const length = requiredLength - 6;\n      const arr = new Uint8Array(Math.floor(length / 2));\n      const crypto = this.cryptoService.getCrypto();\n\n      if (crypto) {\n        crypto.getRandomValues(arr);\n      }\n\n      return Array.from(arr, this.toHex).join('') + this.randomString(7);\n    }\n\n    toHex(dec) {\n      return ('0' + dec.toString(16)).substr(-2);\n    }\n\n    randomString(length) {\n      let result = '';\n      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      const values = new Uint32Array(length);\n      const crypto = this.cryptoService.getCrypto();\n\n      if (crypto) {\n        crypto.getRandomValues(values);\n\n        for (let i = 0; i < length; i++) {\n          result += characters[values[i] % characters.length];\n        }\n      }\n\n      return result;\n    }\n\n  }\n\n  RandomService.ɵfac = function RandomService_Factory(t) {\n    return new (t || RandomService)(i0.ɵɵinject(CryptoService), i0.ɵɵinject(LoggerService));\n  };\n\n  RandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RandomService,\n    factory: RandomService.ɵfac\n  });\n  return RandomService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FlowsDataService = /*#__PURE__*/(() => {\n  class FlowsDataService {\n    constructor(storagePersistenceService, randomService, loggerService) {\n      this.storagePersistenceService = storagePersistenceService;\n      this.randomService = randomService;\n      this.loggerService = loggerService;\n    }\n\n    createNonce(configuration) {\n      const nonce = this.randomService.createRandom(40, configuration);\n      this.loggerService.logDebug(configuration, 'Nonce created. nonce:' + nonce);\n      this.setNonce(nonce, configuration);\n      return nonce;\n    }\n\n    setNonce(nonce, configuration) {\n      this.storagePersistenceService.write('authNonce', nonce, configuration);\n    }\n\n    getAuthStateControl(configuration) {\n      return this.storagePersistenceService.read('authStateControl', configuration);\n    }\n\n    setAuthStateControl(authStateControl, configuration) {\n      return this.storagePersistenceService.write('authStateControl', authStateControl, configuration);\n    }\n\n    getExistingOrCreateAuthStateControl(configuration) {\n      let state = this.storagePersistenceService.read('authStateControl', configuration);\n\n      if (!state) {\n        state = this.randomService.createRandom(40, configuration);\n        this.storagePersistenceService.write('authStateControl', state, configuration);\n      }\n\n      return state;\n    }\n\n    setSessionState(sessionState, configuration) {\n      this.storagePersistenceService.write('session_state', sessionState, configuration);\n    }\n\n    resetStorageFlowData(configuration) {\n      this.storagePersistenceService.resetStorageFlowData(configuration);\n    }\n\n    getCodeVerifier(configuration) {\n      return this.storagePersistenceService.read('codeVerifier', configuration);\n    }\n\n    createCodeVerifier(configuration) {\n      const codeVerifier = this.randomService.createRandom(67, configuration);\n      this.storagePersistenceService.write('codeVerifier', codeVerifier, configuration);\n      return codeVerifier;\n    }\n\n    isSilentRenewRunning(configuration) {\n      const {\n        configId,\n        silentRenewTimeoutInSeconds\n      } = configuration;\n      const storageObject = this.getSilentRenewRunningStorageEntry(configuration);\n\n      if (!storageObject) {\n        return false;\n      }\n\n      const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n      const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n      const currentDateUtc = Date.parse(new Date().toISOString());\n      const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n      const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n      if (isProbablyStuck) {\n        this.loggerService.logDebug(configuration, 'silent renew process is probably stuck, state will be reset.', configId);\n        this.resetSilentRenewRunning(configuration);\n        return false;\n      }\n\n      return storageObject.state === 'running';\n    }\n\n    setSilentRenewRunning(configuration) {\n      const storageObject = {\n        state: 'running',\n        dateOfLaunchedProcessUtc: new Date().toISOString()\n      };\n      this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configuration);\n    }\n\n    resetSilentRenewRunning(configuration) {\n      this.storagePersistenceService.write('storageSilentRenewRunning', '', configuration);\n    }\n\n    getSilentRenewRunningStorageEntry(configuration) {\n      const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configuration);\n\n      if (!storageEntry) {\n        return null;\n      }\n\n      return JSON.parse(storageEntry);\n    }\n\n  }\n\n  FlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n    return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(LoggerService));\n  };\n\n  FlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FlowsDataService,\n    factory: FlowsDataService.ɵfac\n  });\n  return FlowsDataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FlowHelper = /*#__PURE__*/(() => {\n  class FlowHelper {\n    isCurrentFlowCodeFlow(configuration) {\n      return this.currentFlowIs('code', configuration);\n    }\n\n    isCurrentFlowAnyImplicitFlow(configuration) {\n      return this.isCurrentFlowImplicitFlowWithAccessToken(configuration) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configuration);\n    }\n\n    isCurrentFlowCodeFlowWithRefreshTokens(configuration) {\n      const {\n        useRefreshToken\n      } = configuration;\n\n      if (this.isCurrentFlowCodeFlow(configuration) && useRefreshToken) {\n        return true;\n      }\n\n      return false;\n    }\n\n    isCurrentFlowImplicitFlowWithAccessToken(configuration) {\n      return this.currentFlowIs('id_token token', configuration);\n    }\n\n    currentFlowIs(flowTypes, configuration) {\n      const {\n        responseType\n      } = configuration;\n\n      if (Array.isArray(flowTypes)) {\n        return flowTypes.some(x => responseType === x);\n      }\n\n      return responseType === flowTypes;\n    }\n\n    isCurrentFlowImplicitFlowWithoutAccessToken(configuration) {\n      return this.currentFlowIs('id_token', configuration);\n    }\n\n  }\n\n  FlowHelper.ɵfac = function FlowHelper_Factory(t) {\n    return new (t || FlowHelper)();\n  };\n\n  FlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FlowHelper,\n    factory: FlowHelper.ɵfac\n  });\n  return FlowHelper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\nconst AUTH0_ENDPOINT = 'auth0.com';\nlet UrlService = /*#__PURE__*/(() => {\n  class UrlService {\n    constructor(loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\n      this.loggerService = loggerService;\n      this.flowsDataService = flowsDataService;\n      this.flowHelper = flowHelper;\n      this.storagePersistenceService = storagePersistenceService;\n      this.jwtWindowCryptoService = jwtWindowCryptoService;\n    }\n\n    getUrlParameter(urlToCheck, name) {\n      if (!urlToCheck) {\n        return '';\n      }\n\n      if (!name) {\n        return '';\n      }\n\n      name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n      const regex = new RegExp('[\\\\?&#]' + name + '=([^&#]*)');\n      const results = regex.exec(urlToCheck);\n      return results === null ? '' : decodeURIComponent(results[1]);\n    }\n\n    isCallbackFromSts(currentUrl) {\n      return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n    }\n\n    getRefreshSessionSilentRenewUrl(config, customParams) {\n      if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n        return this.createUrlCodeFlowWithSilentRenew(config, customParams);\n      }\n\n      return of(this.createUrlImplicitFlowWithSilentRenew(config, customParams) || '');\n    }\n\n    getAuthorizeParUrl(requestUri, configuration) {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (!authWellKnownEndPoints) {\n        this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n        return null;\n      }\n\n      const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n      if (!authorizationEndpoint) {\n        this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n        return null;\n      }\n\n      const {\n        clientId\n      } = configuration;\n\n      if (!clientId) {\n        this.loggerService.logError(configuration, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n        return null;\n      }\n\n      const urlParts = authorizationEndpoint.split('?');\n      const authorizationUrl = urlParts[0];\n      const existingParams = urlParts[1];\n      let params = this.createHttpParams(existingParams);\n      params = params.set('request_uri', requestUri);\n      params = params.append('client_id', clientId);\n      return `${authorizationUrl}?${params}`;\n    }\n\n    getAuthorizeUrl(config, authOptions) {\n      if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n        return this.createUrlCodeFlowAuthorize(config, authOptions);\n      }\n\n      return of(this.createUrlImplicitFlowAuthorize(config, authOptions) || '');\n    }\n\n    createEndSessionUrl(idTokenHint, configuration, customParamsEndSession) {\n      // Auth0 needs a special logout url\n      // See https://auth0.com/docs/api/authentication#logout\n      if (this.isAuth0Endpoint(configuration)) {\n        return this.composeAuth0Endpoint(configuration);\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n      const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\n\n      if (!endSessionEndpoint) {\n        return null;\n      }\n\n      const urlParts = endSessionEndpoint.split('?');\n      const authorizationEndSessionUrl = urlParts[0];\n      const existingParams = urlParts[1];\n      let params = this.createHttpParams(existingParams);\n      params = params.set('id_token_hint', idTokenHint);\n      const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configuration);\n\n      if (postLogoutRedirectUri) {\n        params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n      }\n\n      if (customParamsEndSession) {\n        params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\n      }\n\n      return `${authorizationEndSessionUrl}?${params}`;\n    }\n\n    createRevocationEndpointBodyAccessToken(token, configuration) {\n      const clientId = this.getClientId(configuration);\n\n      if (!clientId) {\n        return null;\n      }\n\n      let params = this.createHttpParams();\n      params = params.set('client_id', clientId);\n      params = params.set('token', token);\n      params = params.set('token_type_hint', 'access_token');\n      return params.toString();\n    }\n\n    createRevocationEndpointBodyRefreshToken(token, configuration) {\n      const clientId = this.getClientId(configuration);\n\n      if (!clientId) {\n        return null;\n      }\n\n      let params = this.createHttpParams();\n      params = params.set('client_id', clientId);\n      params = params.set('token', token);\n      params = params.set('token_type_hint', 'refresh_token');\n      return params.toString();\n    }\n\n    getRevocationEndpointUrl(configuration) {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n      const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\n\n      if (!revocationEndpoint) {\n        return null;\n      }\n\n      const urlParts = revocationEndpoint.split('?');\n      const revocationEndpointUrl = urlParts[0];\n      return revocationEndpointUrl;\n    }\n\n    createBodyForCodeFlowCodeRequest(code, configuration, customTokenParams) {\n      const codeVerifier = this.flowsDataService.getCodeVerifier(configuration);\n\n      if (!codeVerifier) {\n        this.loggerService.logError(configuration, `CodeVerifier is not set `, codeVerifier);\n        return null;\n      }\n\n      const clientId = this.getClientId(configuration);\n\n      if (!clientId) {\n        return null;\n      }\n\n      let params = this.createHttpParams();\n      params = params.set('grant_type', 'authorization_code');\n      params = params.set('client_id', clientId);\n      params = params.set('code_verifier', codeVerifier);\n      params = params.set('code', code);\n\n      if (customTokenParams) {\n        params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\n      }\n\n      const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n      if (this.flowsDataService.isSilentRenewRunning(configuration) && silentRenewUrl) {\n        params = params.set('redirect_uri', silentRenewUrl);\n        return params.toString();\n      }\n\n      const redirectUrl = this.getRedirectUrl(configuration);\n\n      if (!redirectUrl) {\n        return null;\n      }\n\n      params = params.set('redirect_uri', redirectUrl);\n      return params.toString();\n    }\n\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configuration, customParamsRefresh) {\n      const clientId = this.getClientId(configuration);\n\n      if (!clientId) {\n        return null;\n      }\n\n      let params = this.createHttpParams();\n      params = params.set('grant_type', 'refresh_token');\n      params = params.set('client_id', clientId);\n      params = params.set('refresh_token', refreshToken);\n\n      if (customParamsRefresh) {\n        params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\n      }\n\n      return params.toString();\n    }\n\n    createBodyForParCodeFlowRequest(configuration, customParamsRequest) {\n      const redirectUrl = this.getRedirectUrl(configuration);\n\n      if (!redirectUrl) {\n        return of(null);\n      }\n\n      const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n      const nonce = this.flowsDataService.createNonce(configuration);\n      this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n      const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n      return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n        const {\n          clientId,\n          responseType,\n          scope,\n          hdParam,\n          customParamsAuthRequest\n        } = configuration;\n        let params = this.createHttpParams('');\n        params = params.set('client_id', clientId);\n        params = params.append('redirect_uri', redirectUrl);\n        params = params.append('response_type', responseType);\n        params = params.append('scope', scope);\n        params = params.append('nonce', nonce);\n        params = params.append('state', state);\n        params = params.append('code_challenge', codeChallenge);\n        params = params.append('code_challenge_method', 'S256');\n\n        if (hdParam) {\n          params = params.append('hd', hdParam);\n        }\n\n        if (customParamsAuthRequest) {\n          params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\n        }\n\n        if (customParamsRequest) {\n          params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\n        }\n\n        return params.toString();\n      }));\n    }\n\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configuration, prompt, customRequestParams) {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n      const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\n\n      if (!authorizationEndpoint) {\n        this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n        return null;\n      }\n\n      const {\n        clientId,\n        responseType,\n        scope,\n        hdParam,\n        customParamsAuthRequest\n      } = configuration;\n\n      if (!clientId) {\n        this.loggerService.logError(configuration, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n        return null;\n      }\n\n      if (!responseType) {\n        this.loggerService.logError(configuration, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n        return null;\n      }\n\n      if (!scope) {\n        this.loggerService.logError(configuration, `createAuthorizeUrl could not add scope because it was: `, scope);\n        return null;\n      }\n\n      const urlParts = authorizationEndpoint.split('?');\n      const authorizationUrl = urlParts[0];\n      const existingParams = urlParts[1];\n      let params = this.createHttpParams(existingParams);\n      params = params.set('client_id', clientId);\n      params = params.append('redirect_uri', redirectUrl);\n      params = params.append('response_type', responseType);\n      params = params.append('scope', scope);\n      params = params.append('nonce', nonce);\n      params = params.append('state', state);\n\n      if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\n        params = params.append('code_challenge', codeChallenge);\n        params = params.append('code_challenge_method', 'S256');\n      }\n\n      const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\n\n      if (Object.keys(mergedParams).length > 0) {\n        params = this.appendCustomParams(Object.assign({}, mergedParams), params);\n      }\n\n      if (prompt) {\n        params = this.overWriteParam(params, 'prompt', prompt);\n      }\n\n      if (hdParam) {\n        params = params.append('hd', hdParam);\n      }\n\n      return `${authorizationUrl}?${params}`;\n    }\n\n    createUrlImplicitFlowWithSilentRenew(configuration, customParams) {\n      const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n      const nonce = this.flowsDataService.createNonce(configuration);\n      const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n      if (!silentRenewUrl) {\n        return null;\n      }\n\n      this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ', state);\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (authWellKnownEndPoints) {\n        return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configuration, 'none', customParams);\n      }\n\n      this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    createUrlCodeFlowWithSilentRenew(configuration, customParams) {\n      const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n      const nonce = this.flowsDataService.createNonce(configuration);\n      this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n      const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n      return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n        const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n        if (!silentRenewUrl) {\n          return '';\n        }\n\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n        if (authWellKnownEndPoints) {\n          return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configuration, 'none', customParams);\n        }\n\n        this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n        return null;\n      }));\n    }\n\n    createUrlImplicitFlowAuthorize(configuration, authOptions) {\n      const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n      const nonce = this.flowsDataService.createNonce(configuration);\n      this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\n      const redirectUrl = this.getRedirectUrl(configuration, authOptions);\n\n      if (!redirectUrl) {\n        return null;\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (authWellKnownEndPoints) {\n        const {\n          customParams\n        } = authOptions || {};\n        return this.createAuthorizeUrl('', redirectUrl, nonce, state, configuration, null, customParams);\n      }\n\n      this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    createUrlCodeFlowAuthorize(config, authOptions) {\n      const state = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n      const nonce = this.flowsDataService.createNonce(config);\n      this.loggerService.logDebug(config, 'Authorize created. adding myautostate: ' + state);\n      const redirectUrl = this.getRedirectUrl(config, authOptions);\n\n      if (!redirectUrl) {\n        return of(null);\n      } // code_challenge with \"S256\"\n\n\n      const codeVerifier = this.flowsDataService.createCodeVerifier(config);\n      return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n        if (authWellKnownEndPoints) {\n          const {\n            customParams\n          } = authOptions || {};\n          return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, config, null, customParams);\n        }\n\n        this.loggerService.logError(config, 'authWellKnownEndpoints is undefined');\n        return '';\n      }));\n    }\n\n    getRedirectUrl(configuration, authOptions) {\n      let {\n        redirectUrl\n      } = configuration;\n\n      if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.redirectUrl) {\n        // override by redirectUrl from authOptions\n        redirectUrl = authOptions.redirectUrl;\n      }\n\n      if (!redirectUrl) {\n        this.loggerService.logError(configuration, `could not get redirectUrl, was: `, redirectUrl);\n        return null;\n      }\n\n      return redirectUrl;\n    }\n\n    getSilentRenewUrl(configuration) {\n      const {\n        silentRenewUrl\n      } = configuration;\n\n      if (!silentRenewUrl) {\n        this.loggerService.logError(configuration, `could not get silentRenewUrl, was: `, silentRenewUrl);\n        return null;\n      }\n\n      return silentRenewUrl;\n    }\n\n    getPostLogoutRedirectUrl(configuration) {\n      const {\n        postLogoutRedirectUri\n      } = configuration;\n\n      if (!postLogoutRedirectUri) {\n        this.loggerService.logError(configuration, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n        return null;\n      }\n\n      return postLogoutRedirectUri;\n    }\n\n    getClientId(configuration) {\n      const {\n        clientId\n      } = configuration;\n\n      if (!clientId) {\n        this.loggerService.logError(configuration, `could not get clientId, was: `, clientId);\n        return null;\n      }\n\n      return clientId;\n    }\n\n    appendCustomParams(customParams, params) {\n      for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\n        params = params.append(key, value.toString());\n      }\n\n      return params;\n    }\n\n    overWriteParam(params, key, value) {\n      return params.set(key, value);\n    }\n\n    createHttpParams(existingParams) {\n      existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\n      const params = new HttpParams({\n        fromString: existingParams,\n        encoder: new UriEncoder()\n      });\n      return params;\n    }\n\n    isAuth0Endpoint(configuration) {\n      const {\n        authority\n      } = configuration;\n\n      if (!authority) {\n        return false;\n      }\n\n      return authority.endsWith(AUTH0_ENDPOINT);\n    }\n\n    composeAuth0Endpoint(configuration) {\n      // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\n      const {\n        authority,\n        clientId\n      } = configuration;\n      const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configuration);\n      return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\n    }\n\n  }\n\n  UrlService.ɵfac = function UrlService_Factory(t) {\n    return new (t || UrlService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JwtWindowCryptoService));\n  };\n\n  UrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlService,\n    factory: UrlService.ɵfac\n  });\n  return UrlService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CodeFlowCallbackHandlerService = /*#__PURE__*/(() => {\n  class CodeFlowCallbackHandlerService {\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, storagePersistenceService, dataService) {\n      this.urlService = urlService;\n      this.loggerService = loggerService;\n      this.tokenValidationService = tokenValidationService;\n      this.flowsDataService = flowsDataService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.dataService = dataService;\n    } // STEP 1 Code Flow\n\n\n    codeFlowCallback(urlToCheck, config) {\n      const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n      const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n      const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\n\n      if (!state) {\n        this.loggerService.logDebug(config, 'no state in url');\n        return throwError(() => new Error('no state in url'));\n      }\n\n      if (!code) {\n        this.loggerService.logDebug(config, 'no code in url');\n        return throwError(() => new Error('no code in url'));\n      }\n\n      this.loggerService.logDebug(config, 'running validation for callback', urlToCheck);\n      const initialCallbackContext = {\n        code,\n        refreshToken: null,\n        state,\n        sessionState,\n        authResult: null,\n        isRenewProcess: false,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: null\n      };\n      return of(initialCallbackContext);\n    } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n    codeFlowCodeRequest(callbackContext, config) {\n      const authStateControl = this.flowsDataService.getAuthStateControl(config);\n      const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, config);\n\n      if (!isStateCorrect) {\n        return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\n      }\n\n      const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n      const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n      if (!tokenEndpoint) {\n        return throwError(() => new Error('Token Endpoint not defined'));\n      }\n\n      let headers = new HttpHeaders();\n      headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n      const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, config, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\n      return this.dataService.post(tokenEndpoint, bodyForCodeFlow, config, headers).pipe(switchMap(response => {\n        let authResult = Object.assign(Object.assign({}, response), {\n          state: callbackContext.state,\n          session_state: callbackContext.sessionState\n        });\n        callbackContext.authResult = authResult;\n        return of(callbackContext);\n      }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n        const {\n          authority\n        } = config;\n        const errorMessage = `OidcService code request ${authority}`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }\n\n    handleRefreshRetry(errors, config) {\n      return errors.pipe(mergeMap(error => {\n        // retry token refresh if there is no internet connection\n        if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n          const {\n            authority,\n            refreshTokenRetryInSeconds\n          } = config;\n          const errorMessage = `OidcService code request ${authority} - no internet connection`;\n          this.loggerService.logWarning(config, errorMessage, error);\n          return timer(refreshTokenRetryInSeconds * 1000);\n        }\n\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  CodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n    return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n  };\n\n  CodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CodeFlowCallbackHandlerService,\n    factory: CodeFlowCallbackHandlerService.ɵfac\n  });\n  return CodeFlowCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\nlet UserService = /*#__PURE__*/(() => {\n  class UserService {\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper) {\n      this.oidcDataService = oidcDataService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.eventService = eventService;\n      this.loggerService = loggerService;\n      this.tokenHelperService = tokenHelperService;\n      this.flowHelper = flowHelper;\n      this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n    }\n\n    get userData$() {\n      return this.userDataInternal$.asObservable();\n    }\n\n    getAndPersistUserDataInStore(currentConfiguration, allConfigs, isRenewProcess = false, idToken, decodedIdToken) {\n      idToken = idToken || this.storagePersistenceService.getIdToken(currentConfiguration);\n      decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, currentConfiguration);\n      const existingUserDataFromStorage = this.getUserDataFromStore(currentConfiguration);\n      const haveUserData = !!existingUserDataFromStorage;\n      const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(currentConfiguration);\n      const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(currentConfiguration);\n      const accessToken = this.storagePersistenceService.getAccessToken(currentConfiguration);\n\n      if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n        this.loggerService.logDebug(currentConfiguration, `authCallback idToken flow with accessToken ${accessToken}`);\n        this.setUserDataToStore(decodedIdToken, currentConfiguration, allConfigs);\n        return of(decodedIdToken);\n      }\n\n      const {\n        renewUserInfoAfterTokenRenew\n      } = currentConfiguration;\n\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n        return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, currentConfiguration, allConfigs).pipe(switchMap(userData => {\n          this.loggerService.logDebug(currentConfiguration, 'Received user data: ', userData);\n\n          if (!!userData) {\n            this.loggerService.logDebug(currentConfiguration, 'accessToken: ', accessToken);\n            return of(userData);\n          } else {\n            return throwError(() => new Error('Received no user data, request failed'));\n          }\n        }));\n      }\n\n      return of(existingUserDataFromStorage);\n    }\n\n    getUserDataFromStore(currentConfiguration) {\n      return this.storagePersistenceService.read('userData', currentConfiguration) || null;\n    }\n\n    publishUserDataIfExists(currentConfiguration, allConfigs) {\n      const userData = this.getUserDataFromStore(currentConfiguration);\n\n      if (userData) {\n        this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n      }\n    }\n\n    setUserDataToStore(userData, currentConfiguration, allConfigs) {\n      this.storagePersistenceService.write('userData', userData, currentConfiguration);\n      this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n    }\n\n    resetUserDataInStore(currentConfiguration, allConfigs) {\n      this.storagePersistenceService.remove('userData', currentConfiguration);\n      this.fireUserDataEvent(currentConfiguration, allConfigs, null);\n    }\n\n    getUserDataOidcFlowAndSave(idTokenSub, currentConfiguration, allConfigs) {\n      return this.getIdentityUserData(currentConfiguration).pipe(map(data => {\n        if (this.validateUserDataSubIdToken(currentConfiguration, idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\n          this.setUserDataToStore(data, currentConfiguration, allConfigs);\n          return data;\n        } else {\n          // something went wrong, user data sub does not match that from id_token\n          this.loggerService.logWarning(currentConfiguration, `User data sub does not match sub in id_token, resetting`);\n          this.resetUserDataInStore(currentConfiguration, allConfigs);\n          return null;\n        }\n      }));\n    }\n\n    getIdentityUserData(currentConfiguration) {\n      const token = this.storagePersistenceService.getAccessToken(currentConfiguration);\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n\n      if (!authWellKnownEndPoints) {\n        this.loggerService.logWarning(currentConfiguration, 'init check session: authWellKnownEndpoints is undefined');\n        return throwError(() => new Error('authWellKnownEndpoints is undefined'));\n      }\n\n      const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\n\n      if (!userInfoEndpoint) {\n        this.loggerService.logError(currentConfiguration, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n        return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\n      }\n\n      return this.oidcDataService.get(userInfoEndpoint, currentConfiguration, token).pipe(retry(2));\n    }\n\n    validateUserDataSubIdToken(currentConfiguration, idTokenSub, userDataSub) {\n      if (!idTokenSub) {\n        return false;\n      }\n\n      if (!userDataSub) {\n        return false;\n      }\n\n      if (idTokenSub !== userDataSub) {\n        this.loggerService.logDebug(currentConfiguration, 'validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n        return false;\n      }\n\n      return true;\n    }\n\n    fireUserDataEvent(currentConfiguration, allConfigs, passedUserData) {\n      const userData = this.composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData);\n      this.userDataInternal$.next(userData);\n      const {\n        configId\n      } = currentConfiguration;\n      this.eventService.fireEvent(EventTypes.UserDataChanged, {\n        configId,\n        userData: passedUserData\n      });\n    }\n\n    composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData) {\n      const hasManyConfigs = allConfigs.length > 1;\n\n      if (!hasManyConfigs) {\n        const {\n          configId\n        } = currentConfiguration;\n        return this.composeSingleUserDataResult(configId, passedUserData);\n      }\n\n      const allUserData = allConfigs.map(config => {\n        const {\n          configId\n        } = currentConfiguration;\n\n        if (this.currentConfigIsToUpdate(configId, config)) {\n          return {\n            configId: config.configId,\n            userData: passedUserData\n          };\n        }\n\n        const alreadySavedUserData = this.storagePersistenceService.read('userData', config) || null;\n        return {\n          configId: config.configId,\n          userData: alreadySavedUserData\n        };\n      });\n      return {\n        userData: null,\n        allUserData\n      };\n    }\n\n    composeSingleUserDataResult(configId, userData) {\n      return {\n        userData,\n        allUserData: [{\n          configId,\n          userData\n        }]\n      };\n    }\n\n    currentConfigIsToUpdate(configId, config) {\n      return config.configId === configId;\n    }\n\n  }\n\n  UserService.ɵfac = function UserService_Factory(t) {\n    return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper));\n  };\n\n  UserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserService,\n    factory: UserService.ɵfac\n  });\n  return UserService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ResetAuthDataService = /*#__PURE__*/(() => {\n  class ResetAuthDataService {\n    constructor(authStateService, flowsDataService, userService) {\n      this.authStateService = authStateService;\n      this.flowsDataService = flowsDataService;\n      this.userService = userService;\n    }\n\n    resetAuthorizationData(currentConfiguration, allConfigs) {\n      this.userService.resetUserDataInStore(currentConfiguration, allConfigs);\n      this.flowsDataService.resetStorageFlowData(currentConfiguration);\n      this.authStateService.setUnauthenticatedAndFireEvent(currentConfiguration, allConfigs);\n    }\n\n  }\n\n  ResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n    return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService));\n  };\n\n  ResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResetAuthDataService,\n    factory: ResetAuthDataService.ɵfac\n  });\n  return ResetAuthDataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ImplicitFlowCallbackHandlerService = /*#__PURE__*/(() => {\n  class ImplicitFlowCallbackHandlerService {\n    constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\n      this.resetAuthDataService = resetAuthDataService;\n      this.loggerService = loggerService;\n      this.flowsDataService = flowsDataService;\n      this.doc = doc;\n    } // STEP 1 Code Flow\n    // STEP 1 Implicit Flow\n\n\n    implicitFlowCallback(config, allConfigs, hash) {\n      const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(config);\n      this.loggerService.logDebug(config, 'BEGIN callback, no auth data');\n\n      if (!isRenewProcessData) {\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      }\n\n      hash = hash || this.doc.location.hash.substr(1);\n      const authResult = hash.split('&').reduce((resultData, item) => {\n        const parts = item.split('=');\n        resultData[parts.shift()] = parts.join('=');\n        return resultData;\n      }, {});\n      const callbackContext = {\n        code: null,\n        refreshToken: null,\n        state: null,\n        sessionState: null,\n        authResult,\n        isRenewProcess: isRenewProcessData,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: null\n      };\n      return of(callbackContext);\n    }\n\n  }\n\n  ImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n    return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n  };\n\n  ImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ImplicitFlowCallbackHandlerService,\n    factory: ImplicitFlowCallbackHandlerService.ɵfac\n  });\n  return ImplicitFlowCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SigninKeyDataService = /*#__PURE__*/(() => {\n  class SigninKeyDataService {\n    constructor(storagePersistenceService, loggerService, dataService) {\n      this.storagePersistenceService = storagePersistenceService;\n      this.loggerService = loggerService;\n      this.dataService = dataService;\n    }\n\n    getSigningKeys(currentConfiguration) {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n      const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\n\n      if (!jwksUri) {\n        const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n        this.loggerService.logWarning(currentConfiguration, error);\n        return throwError(() => new Error(error));\n      }\n\n      this.loggerService.logDebug(currentConfiguration, 'Getting signinkeys from ', jwksUri);\n      return this.dataService.get(jwksUri, currentConfiguration).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, currentConfiguration)));\n    }\n\n    handleErrorGetSigningKeys(errorResponse, currentConfiguration) {\n      let errMsg = '';\n\n      if (errorResponse instanceof HttpResponse) {\n        const body = errorResponse.body || {};\n        const err = JSON.stringify(body);\n        const {\n          status,\n          statusText\n        } = errorResponse;\n        errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n      } else {\n        const {\n          message\n        } = errorResponse;\n        errMsg = !!message ? message : `${errorResponse}`;\n      }\n\n      this.loggerService.logError(currentConfiguration, errMsg);\n      return throwError(() => new Error(errMsg));\n    }\n\n  }\n\n  SigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n    return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n  };\n\n  SigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SigninKeyDataService,\n    factory: SigninKeyDataService.ɵfac\n  });\n  return SigninKeyDataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst JWT_KEYS = 'jwtKeys';\nlet HistoryJwtKeysCallbackHandlerService = /*#__PURE__*/(() => {\n  class HistoryJwtKeysCallbackHandlerService {\n    constructor(loggerService, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService, document) {\n      this.loggerService = loggerService;\n      this.authStateService = authStateService;\n      this.flowsDataService = flowsDataService;\n      this.signInKeyDataService = signInKeyDataService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.resetAuthDataService = resetAuthDataService;\n      this.document = document;\n    } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n    callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs) {\n      this.storagePersistenceService.write('authnResult', callbackContext.authResult, config);\n\n      if (config.allowUnsafeReuseRefreshToken && callbackContext.authResult.refresh_token) {\n        this.storagePersistenceService.write('reusable_refresh_token', callbackContext.authResult.refresh_token, config);\n      }\n\n      if (this.historyCleanUpTurnedOn(config) && !callbackContext.isRenewProcess) {\n        this.resetBrowserHistory();\n      } else {\n        this.loggerService.logDebug(config, 'history clean up inactive');\n      }\n\n      if (callbackContext.authResult.error) {\n        const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n        this.loggerService.logDebug(config, errorMessage);\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        this.flowsDataService.setNonce('', config);\n        this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.loggerService.logDebug(config, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n      return this.signInKeyDataService.getSigningKeys(config).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, config)), catchError(err => {\n        // fallback: try to load jwtKeys from storage\n        const storedJwtKeys = this.readSigningKeys(config);\n\n        if (!!storedJwtKeys) {\n          this.loggerService.logWarning(config, `Failed to retrieve signing keys, fallback to stored keys`);\n          return of(storedJwtKeys);\n        }\n\n        return throwError(() => new Error(err));\n      }), switchMap(jwtKeys => {\n        if (jwtKeys) {\n          callbackContext.jwtKeys = jwtKeys;\n          return of(callbackContext);\n        }\n\n        const errorMessage = `Failed to retrieve signing key`;\n        this.loggerService.logWarning(config, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }), catchError(err => {\n        const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n        this.loggerService.logWarning(config, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }\n\n    handleResultErrorFromCallback(result, isRenewProcess) {\n      let validationResult = ValidationResult.SecureTokenServerError;\n\n      if (result.error === 'login_required') {\n        validationResult = ValidationResult.LoginRequired;\n      }\n\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult,\n        isRenewProcess\n      });\n    }\n\n    historyCleanUpTurnedOn(config) {\n      const {\n        historyCleanupOff\n      } = config;\n      return !historyCleanupOff;\n    }\n\n    resetBrowserHistory() {\n      this.document.defaultView.history.replaceState({}, this.document.defaultView.title, this.document.defaultView.location.origin + this.document.defaultView.location.pathname);\n    }\n\n    storeSigningKeys(jwtKeys, config) {\n      this.storagePersistenceService.write(JWT_KEYS, jwtKeys, config);\n    }\n\n    readSigningKeys(config) {\n      return this.storagePersistenceService.read(JWT_KEYS, config);\n    }\n\n  }\n\n  HistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n    return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n  };\n\n  HistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HistoryJwtKeysCallbackHandlerService,\n    factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n  });\n  return HistoryJwtKeysCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet UserCallbackHandlerService = /*#__PURE__*/(() => {\n  class UserCallbackHandlerService {\n    constructor(loggerService, authStateService, flowsDataService, userService, resetAuthDataService) {\n      this.loggerService = loggerService;\n      this.authStateService = authStateService;\n      this.flowsDataService = flowsDataService;\n      this.userService = userService;\n      this.resetAuthDataService = resetAuthDataService;\n    } // STEP 5 userData\n\n\n    callbackUser(callbackContext, configuration, allConfigs) {\n      const {\n        isRenewProcess,\n        validationResult,\n        authResult,\n        refreshToken\n      } = callbackContext;\n      const {\n        autoUserInfo,\n        renewUserInfoAfterTokenRenew\n      } = configuration;\n\n      if (!autoUserInfo) {\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n          // userData is set to the id_token decoded, auto get user data set to false\n          if (validationResult.decodedIdToken) {\n            this.userService.setUserDataToStore(validationResult.decodedIdToken, configuration, allConfigs);\n          }\n        }\n\n        if (!isRenewProcess && !refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configuration);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      }\n\n      return this.userService.getAndPersistUserDataInStore(configuration, allConfigs, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n        if (!!userData) {\n          if (!refreshToken) {\n            this.flowsDataService.setSessionState(authResult.session_state, configuration);\n          }\n\n          this.publishAuthState(validationResult, isRenewProcess);\n          return of(callbackContext);\n        } else {\n          this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n          this.publishUnauthenticatedState(validationResult, isRenewProcess);\n          const errorMessage = `Called for userData but they were ${userData}`;\n          this.loggerService.logWarning(configuration, errorMessage);\n          return throwError(() => new Error(errorMessage));\n        }\n      }), catchError(err => {\n        const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n        this.loggerService.logWarning(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }\n\n    publishAuthState(stateValidationResult, isRenewProcess) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: true,\n        validationResult: stateValidationResult.state,\n        isRenewProcess\n      });\n    }\n\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: stateValidationResult.state,\n        isRenewProcess\n      });\n    }\n\n  }\n\n  UserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n    return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n  };\n\n  UserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserCallbackHandlerService,\n    factory: UserCallbackHandlerService.ɵfac\n  });\n  return UserCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\n    at_hash: ''\n  }, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nlet EqualityService = /*#__PURE__*/(() => {\n  class EqualityService {\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n      if (this.isNullOrUndefined(value1)) {\n        return false;\n      }\n\n      if (this.isNullOrUndefined(value2)) {\n        return false;\n      }\n\n      if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n        return false;\n      }\n\n      if (this.bothValuesAreStrings(value1, value2)) {\n        return value1 === value2;\n      }\n\n      return this.arraysHaveEqualContent(value1, value2);\n    }\n\n    areEqual(value1, value2) {\n      if (!value1 || !value2) {\n        return false;\n      }\n\n      if (this.bothValuesAreArrays(value1, value2)) {\n        return this.arraysStrictEqual(value1, value2);\n      }\n\n      if (this.bothValuesAreStrings(value1, value2)) {\n        return value1 === value2;\n      }\n\n      if (this.bothValuesAreObjects(value1, value2)) {\n        return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n      }\n\n      if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n        if (Array.isArray(value1) && this.valueIsString(value2)) {\n          return value1[0] === value2;\n        }\n\n        if (Array.isArray(value2) && this.valueIsString(value1)) {\n          return value2[0] === value1;\n        }\n      }\n\n      return value1 === value2;\n    }\n\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\n      return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n    }\n\n    bothValuesAreObjects(value1, value2) {\n      return this.valueIsObject(value1) && this.valueIsObject(value2);\n    }\n\n    bothValuesAreStrings(value1, value2) {\n      return this.valueIsString(value1) && this.valueIsString(value2);\n    }\n\n    bothValuesAreArrays(value1, value2) {\n      return Array.isArray(value1) && Array.isArray(value2);\n    }\n\n    valueIsString(value) {\n      return typeof value === 'string' || value instanceof String;\n    }\n\n    valueIsObject(value) {\n      return typeof value === 'object';\n    }\n\n    arraysStrictEqual(arr1, arr2) {\n      if (arr1.length !== arr2.length) {\n        return false;\n      }\n\n      for (let i = arr1.length; i--;) {\n        if (arr1[i] !== arr2[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    arraysHaveEqualContent(arr1, arr2) {\n      if (arr1.length !== arr2.length) {\n        return false;\n      }\n\n      return arr1.some(v => arr2.includes(v));\n    }\n\n    isNullOrUndefined(val) {\n      return val === null || val === undefined;\n    }\n\n  }\n\n  EqualityService.ɵfac = function EqualityService_Factory(t) {\n    return new (t || EqualityService)();\n  };\n\n  EqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: EqualityService,\n    factory: EqualityService.ɵfac\n  });\n  return EqualityService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StateValidationService = /*#__PURE__*/(() => {\n  class StateValidationService {\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, equalityService, flowHelper) {\n      this.storagePersistenceService = storagePersistenceService;\n      this.tokenValidationService = tokenValidationService;\n      this.tokenHelperService = tokenHelperService;\n      this.loggerService = loggerService;\n      this.equalityService = equalityService;\n      this.flowHelper = flowHelper;\n    }\n\n    getValidatedStateResult(callbackContext, configuration) {\n      if (!callbackContext || callbackContext.authResult.error) {\n        return of(new StateValidationResult('', '', false, {}));\n      }\n\n      return this.validateState(callbackContext, configuration);\n    }\n\n    validateState(callbackContext, configuration) {\n      const toReturn = new StateValidationResult();\n      const authStateControl = this.storagePersistenceService.read('authStateControl', configuration);\n\n      if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configuration)) {\n        this.loggerService.logWarning(configuration, 'authCallback incorrect state');\n        toReturn.state = ValidationResult.StatesDoNotMatch;\n        this.handleUnsuccessfulValidation(configuration);\n        return of(toReturn);\n      }\n\n      const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configuration);\n      const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configuration);\n\n      if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n        toReturn.accessToken = callbackContext.authResult.access_token;\n      }\n\n      if (callbackContext.authResult.id_token) {\n        const {\n          clientId,\n          issValidationOff,\n          maxIdTokenIatOffsetAllowedInSeconds,\n          disableIatOffsetValidation,\n          ignoreNonceAfterRefresh,\n          disableIdTokenValidation\n        } = configuration;\n        toReturn.idToken = callbackContext.authResult.id_token;\n        toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configuration);\n        return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configuration).pipe(mergeMap(isSignatureIdTokenValid => {\n          if (!isSignatureIdTokenValid) {\n            this.loggerService.logDebug(configuration, 'authCallback Signature validation failed id_token');\n            toReturn.state = ValidationResult.SignatureFailed;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          const authNonce = this.storagePersistenceService.read('authNonce', configuration);\n\n          if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\n            toReturn.state = ValidationResult.IncorrectNonce;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configuration)) {\n            this.loggerService.logDebug(configuration, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n            toReturn.state = ValidationResult.RequiredPropertyMissing;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n            toReturn.state = ValidationResult.MaxOffsetExpired;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n          if (authWellKnownEndPoints) {\n            if (issValidationOff) {\n              this.loggerService.logDebug(configuration, 'iss validation is turned off, this is not recommended!');\n            } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configuration)) {\n              this.loggerService.logWarning(configuration, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n              toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n              this.handleUnsuccessfulValidation(configuration);\n              return of(toReturn);\n            }\n          } else {\n            this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n            toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect aud');\n            toReturn.state = ValidationResult.IncorrectAud;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n            this.loggerService.logWarning(configuration, 'authCallback missing azp');\n            toReturn.state = ValidationResult.IncorrectAzp;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect azp');\n            toReturn.state = ValidationResult.IncorrectAzp;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback pre, post id_token claims do not match in refresh');\n            toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configuration, maxIdTokenIatOffsetAllowedInSeconds, disableIdTokenValidation)) {\n            this.loggerService.logWarning(configuration, 'authCallback id token expired');\n            toReturn.state = ValidationResult.TokenExpired;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n\n          return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n        }));\n      } else {\n        this.loggerService.logDebug(configuration, 'No id_token found, skipping id_token validation');\n      }\n\n      return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n    }\n\n    validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext) {\n      // flow id_token\n      if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n        toReturn.authResponseIsValid = true;\n        toReturn.state = ValidationResult.Ok;\n        this.handleSuccessfulValidation(configuration);\n        this.handleUnsuccessfulValidation(configuration);\n        return of(toReturn);\n      } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n      if (callbackContext.authResult.id_token) {\n        const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configuration);\n\n        if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n          this.loggerService.logDebug(configuration, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n        } else {\n          return this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\n          configuration).pipe(map(valid => {\n            if (!valid || !toReturn.accessToken) {\n              this.loggerService.logWarning(configuration, 'authCallback incorrect at_hash');\n              toReturn.state = ValidationResult.IncorrectAtHash;\n              this.handleUnsuccessfulValidation(configuration);\n              return toReturn;\n            } else {\n              toReturn.authResponseIsValid = true;\n              toReturn.state = ValidationResult.Ok;\n              this.handleSuccessfulValidation(configuration);\n              return toReturn;\n            }\n          }));\n        }\n      }\n\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configuration);\n      return of(toReturn);\n    }\n\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configuration) {\n      const {\n        useRefreshToken,\n        disableRefreshIdTokenAuthTimeValidation\n      } = configuration;\n\n      if (!useRefreshToken) {\n        return true;\n      }\n\n      if (!callbackContext.existingIdToken) {\n        return true;\n      }\n\n      const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configuration); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n      // except that it might not contain an id_token.\n      // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n      // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n      if (decodedIdToken.iss !== newIdToken.iss) {\n        this.loggerService.logDebug(configuration, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n        return false;\n      } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n      //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n      // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n      if (decodedIdToken.azp !== newIdToken.azp) {\n        this.loggerService.logDebug(configuration, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n        return false;\n      } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n      if (decodedIdToken.sub !== newIdToken.sub) {\n        this.loggerService.logDebug(configuration, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n        return false;\n      } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n      if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\n        this.loggerService.logDebug(configuration, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\n        return false;\n      }\n\n      if (disableRefreshIdTokenAuthTimeValidation) {\n        return true;\n      } // its iat Claim MUST represent the time that the new ID Token is issued,\n      // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n      // - not the time that the new ID token is issued,\n\n\n      if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n        this.loggerService.logDebug(configuration, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n        return false;\n      }\n\n      return true;\n    }\n\n    handleSuccessfulValidation(configuration) {\n      const {\n        autoCleanStateAfterAuthentication\n      } = configuration;\n      this.storagePersistenceService.write('authNonce', null, configuration);\n\n      if (autoCleanStateAfterAuthentication) {\n        this.storagePersistenceService.write('authStateControl', '', configuration);\n      }\n\n      this.loggerService.logDebug(configuration, 'authCallback token(s) validated, continue');\n    }\n\n    handleUnsuccessfulValidation(configuration) {\n      const {\n        autoCleanStateAfterAuthentication\n      } = configuration;\n      this.storagePersistenceService.write('authNonce', null, configuration);\n\n      if (autoCleanStateAfterAuthentication) {\n        this.storagePersistenceService.write('authStateControl', '', configuration);\n      }\n\n      this.loggerService.logDebug(configuration, 'authCallback token(s) invalid');\n    }\n\n  }\n\n  StateValidationService.ɵfac = function StateValidationService_Factory(t) {\n    return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n  };\n\n  StateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateValidationService,\n    factory: StateValidationService.ɵfac\n  });\n  return StateValidationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StateValidationCallbackHandlerService = /*#__PURE__*/(() => {\n  class StateValidationCallbackHandlerService {\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\n      this.loggerService = loggerService;\n      this.stateValidationService = stateValidationService;\n      this.authStateService = authStateService;\n      this.resetAuthDataService = resetAuthDataService;\n      this.doc = doc;\n    } // STEP 4 All flows\n\n\n    callbackStateValidation(callbackContext, configuration, allConfigs) {\n      return this.stateValidationService.getValidatedStateResult(callbackContext, configuration).pipe(map(validationResult => {\n        callbackContext.validationResult = validationResult;\n\n        if (validationResult.authResponseIsValid) {\n          this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configuration, allConfigs);\n          return callbackContext;\n        } else {\n          const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\n          this.loggerService.logWarning(configuration, errorMessage);\n          this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n          this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n          throw new Error(errorMessage);\n        }\n      }));\n    }\n\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: stateValidationResult.state,\n        isRenewProcess\n      });\n    }\n\n  }\n\n  StateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n    return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n  };\n\n  StateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateValidationCallbackHandlerService,\n    factory: StateValidationCallbackHandlerService.ɵfac\n  });\n  return StateValidationCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RefreshSessionCallbackHandlerService = /*#__PURE__*/(() => {\n  class RefreshSessionCallbackHandlerService {\n    constructor(loggerService, authStateService, flowsDataService) {\n      this.loggerService = loggerService;\n      this.authStateService = authStateService;\n      this.flowsDataService = flowsDataService;\n    } // STEP 1 Refresh session\n\n\n    refreshSessionWithRefreshTokens(config) {\n      const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n      this.loggerService.logDebug(config, 'RefreshSession created. Adding myautostate: ' + stateData);\n      const refreshToken = this.authStateService.getRefreshToken(config);\n      const idToken = this.authStateService.getIdToken(config);\n\n      if (refreshToken) {\n        const callbackContext = {\n          code: null,\n          refreshToken,\n          state: stateData,\n          sessionState: null,\n          authResult: null,\n          isRenewProcess: true,\n          jwtKeys: null,\n          validationResult: null,\n          existingIdToken: idToken\n        };\n        this.loggerService.logDebug(config, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n        this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, config);\n        return of(callbackContext);\n      } else {\n        const errorMessage = 'no refresh token found, please login';\n        this.loggerService.logError(config, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n    }\n\n  }\n\n  RefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n    return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n  };\n\n  RefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshSessionCallbackHandlerService,\n    factory: RefreshSessionCallbackHandlerService.ɵfac\n  });\n  return RefreshSessionCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RefreshTokenCallbackHandlerService = /*#__PURE__*/(() => {\n  class RefreshTokenCallbackHandlerService {\n    constructor(urlService, loggerService, dataService, storagePersistenceService) {\n      this.urlService = urlService;\n      this.loggerService = loggerService;\n      this.dataService = dataService;\n      this.storagePersistenceService = storagePersistenceService;\n    } // STEP 2 Refresh Token\n\n\n    refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {\n      let headers = new HttpHeaders();\n      headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n      const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n      const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n      if (!tokenEndpoint) {\n        return throwError(() => new Error('Token Endpoint not defined'));\n      }\n\n      const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);\n      return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap(response => {\n        this.loggerService.logDebug(config, 'token refresh response: ', response); // TODO FGO LOOK AT THIS\n\n        let authResult = new Object();\n        authResult = response;\n        authResult.state = callbackContext.state;\n        callbackContext.authResult = authResult;\n        return of(callbackContext);\n      }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n        const {\n          authority\n        } = config;\n        const errorMessage = `OidcService code request ${authority}`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }\n\n    handleRefreshRetry(errors, config) {\n      return errors.pipe(mergeMap(error => {\n        // retry token refresh if there is no internet connection\n        if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n          const {\n            authority,\n            refreshTokenRetryInSeconds\n          } = config;\n          const errorMessage = `OidcService code request ${authority} - no internet connection`;\n          this.loggerService.logWarning(config, errorMessage, error);\n          return timer(refreshTokenRetryInSeconds * 1000);\n        }\n\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  RefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n    return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n  };\n\n  RefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshTokenCallbackHandlerService,\n    factory: RefreshTokenCallbackHandlerService.ɵfac\n  });\n  return RefreshTokenCallbackHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FlowsService = /*#__PURE__*/(() => {\n  class FlowsService {\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n      this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n      this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n      this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n      this.userHandlerService = userHandlerService;\n      this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n      this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n      this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n    }\n\n    processCodeFlowCallback(urlToCheck, config, allConfigs) {\n      return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, config).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, config)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n    }\n\n    processSilentRenewCodeFlowCallback(firstContext, config, allConfigs) {\n      return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, config).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n    }\n\n    processImplicitFlowCallback(config, allConfigs, hash) {\n      return this.implicitFlowCallbackHandlerService.implicitFlowCallback(config, allConfigs, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n    }\n\n    processRefreshToken(config, allConfigs, customParamsRefresh) {\n      return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(config).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, config, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n    }\n\n  }\n\n  FlowsService.ɵfac = function FlowsService_Factory(t) {\n    return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n  };\n\n  FlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FlowsService,\n    factory: FlowsService.ɵfac\n  });\n  return FlowsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IntervalService = /*#__PURE__*/(() => {\n  class IntervalService {\n    constructor(zone) {\n      this.zone = zone;\n      this.runTokenValidationRunning = null;\n    }\n\n    isTokenValidationRunning() {\n      return !!this.runTokenValidationRunning;\n    }\n\n    stopPeriodicTokenCheck() {\n      if (this.runTokenValidationRunning) {\n        this.runTokenValidationRunning.unsubscribe();\n        this.runTokenValidationRunning = null;\n      }\n    }\n\n    startPeriodicTokenCheck(repeatAfterSeconds) {\n      const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n      return new Observable(subscriber => {\n        let intervalId;\n        this.zone.runOutsideAngular(() => {\n          intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n        });\n        return () => {\n          clearInterval(intervalId);\n        };\n      });\n    }\n\n  }\n\n  IntervalService.ɵfac = function IntervalService_Factory(t) {\n    return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  IntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IntervalService,\n    factory: IntervalService.ɵfac,\n    providedIn: 'root'\n  });\n  return IntervalService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ImplicitFlowCallbackService = /*#__PURE__*/(() => {\n  class ImplicitFlowCallbackService {\n    constructor(flowsService, router, flowsDataService, intervalService) {\n      this.flowsService = flowsService;\n      this.router = router;\n      this.flowsDataService = flowsDataService;\n      this.intervalService = intervalService;\n    }\n\n    authenticatedImplicitFlowCallback(config, allConfigs, hash) {\n      const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n      const {\n        triggerAuthorizationResultEvent,\n        postLoginRoute,\n        unauthorizedRoute\n      } = config;\n      return this.flowsService.processImplicitFlowCallback(config, allConfigs, hash).pipe(tap(callbackContext => {\n        if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n          this.router.navigateByUrl(postLoginRoute);\n        }\n      }), catchError(error => {\n        this.flowsDataService.resetSilentRenewRunning(config);\n        this.intervalService.stopPeriodicTokenCheck();\n\n        if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n          this.router.navigateByUrl(unauthorizedRoute);\n        }\n\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  ImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n    return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n  };\n\n  ImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ImplicitFlowCallbackService,\n    factory: ImplicitFlowCallbackService.ɵfac,\n    providedIn: 'root'\n  });\n  return ImplicitFlowCallbackService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\nlet SilentRenewService = /*#__PURE__*/(() => {\n  class SilentRenewService {\n    constructor(iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n      this.iFrameService = iFrameService;\n      this.flowsService = flowsService;\n      this.resetAuthDataService = resetAuthDataService;\n      this.flowsDataService = flowsDataService;\n      this.authStateService = authStateService;\n      this.loggerService = loggerService;\n      this.flowHelper = flowHelper;\n      this.implicitFlowCallbackService = implicitFlowCallbackService;\n      this.intervalService = intervalService;\n      this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n    }\n\n    get refreshSessionWithIFrameCompleted$() {\n      return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n    }\n\n    getOrCreateIframe(config) {\n      const existingIframe = this.getExistingIframe();\n\n      if (!existingIframe) {\n        return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, config);\n      }\n\n      return existingIframe;\n    }\n\n    isSilentRenewConfigured(configuration) {\n      const {\n        useRefreshToken,\n        silentRenew\n      } = configuration;\n      return !useRefreshToken && silentRenew;\n    }\n\n    codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs) {\n      const params = new HttpParams({\n        fromString: urlParts[1]\n      });\n      const error = params.get('error');\n\n      if (error) {\n        this.authStateService.updateAndPublishAuthState({\n          isAuthenticated: false,\n          validationResult: ValidationResult.LoginRequired,\n          isRenewProcess: true\n        });\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        this.flowsDataService.setNonce('', config);\n        this.intervalService.stopPeriodicTokenCheck();\n        return throwError(() => new Error(error));\n      }\n\n      const code = params.get('code');\n      const state = params.get('state');\n      const sessionState = params.get('session_state');\n      const callbackContext = {\n        code,\n        refreshToken: null,\n        state,\n        sessionState,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: null\n      };\n      return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, config, allConfigs).pipe(catchError(() => {\n        this.intervalService.stopPeriodicTokenCheck();\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        return throwError(() => new Error(error));\n      }));\n    }\n\n    silentRenewEventHandler(e, config, allConfigs) {\n      this.loggerService.logDebug(config, 'silentRenewEventHandler');\n\n      if (!e.detail) {\n        return;\n      }\n\n      let callback$ = of(null);\n      const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(config);\n\n      if (isCodeFlow) {\n        const urlParts = e.detail.toString().split('?');\n        callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs);\n      } else {\n        callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, e.detail);\n      }\n\n      callback$.subscribe({\n        next: callbackContext => {\n          this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n          this.flowsDataService.resetSilentRenewRunning(config);\n        },\n        error: err => {\n          this.loggerService.logError(config, 'Error: ' + err);\n          this.refreshSessionWithIFrameCompletedInternal$.next(null);\n          this.flowsDataService.resetSilentRenewRunning(config);\n        }\n      });\n    }\n\n    getExistingIframe() {\n      return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n    }\n\n  }\n\n  SilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n    return new (t || SilentRenewService)(i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n  };\n\n  SilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SilentRenewService,\n    factory: SilentRenewService.ɵfac\n  });\n  return SilentRenewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CodeFlowCallbackService = /*#__PURE__*/(() => {\n  class CodeFlowCallbackService {\n    constructor(flowsService, flowsDataService, intervalService, router) {\n      this.flowsService = flowsService;\n      this.flowsDataService = flowsDataService;\n      this.intervalService = intervalService;\n      this.router = router;\n    }\n\n    authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {\n      const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n      const {\n        triggerAuthorizationResultEvent,\n        postLoginRoute,\n        unauthorizedRoute\n      } = config;\n      return this.flowsService.processCodeFlowCallback(urlToCheck, config, allConfigs).pipe(tap(callbackContext => {\n        if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n          this.router.navigateByUrl(postLoginRoute);\n        }\n      }), catchError(error => {\n        this.flowsDataService.resetSilentRenewRunning(config);\n        this.intervalService.stopPeriodicTokenCheck();\n\n        if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n          this.router.navigateByUrl(unauthorizedRoute);\n        }\n\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  CodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n    return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(i2.Router));\n  };\n\n  CodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CodeFlowCallbackService,\n    factory: CodeFlowCallbackService.ɵfac,\n    providedIn: 'root'\n  });\n  return CodeFlowCallbackService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CallbackService = /*#__PURE__*/(() => {\n  class CallbackService {\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n      this.urlService = urlService;\n      this.flowHelper = flowHelper;\n      this.implicitFlowCallbackService = implicitFlowCallbackService;\n      this.codeFlowCallbackService = codeFlowCallbackService;\n      this.stsCallbackInternal$ = new Subject();\n    }\n\n    get stsCallback$() {\n      return this.stsCallbackInternal$.asObservable();\n    }\n\n    isCallback(currentUrl) {\n      return this.urlService.isCallbackFromSts(currentUrl);\n    }\n\n    handleCallbackAndFireEvents(currentCallbackUrl, config, allConfigs) {\n      let callback$;\n\n      if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n        callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, config, allConfigs);\n      } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(config)) {\n        if (currentCallbackUrl === null || currentCallbackUrl === void 0 ? void 0 : currentCallbackUrl.includes('#')) {\n          let hash = currentCallbackUrl.substring(currentCallbackUrl.indexOf('#') + 1);\n          callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, hash);\n        } else {\n          callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs);\n        }\n      }\n\n      return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n    }\n\n  }\n\n  CallbackService.ɵfac = function CallbackService_Factory(t) {\n    return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n  };\n\n  CallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CallbackService,\n    factory: CallbackService.ɵfac,\n    providedIn: 'root'\n  });\n  return CallbackService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\nlet AuthWellKnownDataService = /*#__PURE__*/(() => {\n  class AuthWellKnownDataService {\n    constructor(http, loggerService) {\n      this.http = http;\n      this.loggerService = loggerService;\n    }\n\n    getWellKnownEndPointsForConfig(config) {\n      const {\n        authWellknownEndpointUrl\n      } = config;\n\n      if (!authWellknownEndpointUrl) {\n        const errorMessage = 'no authWellknownEndpoint given!';\n        this.loggerService.logError(config, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      return this.getWellKnownDocument(authWellknownEndpointUrl, config).pipe(map(wellKnownEndpoints => ({\n        issuer: wellKnownEndpoints.issuer,\n        jwksUri: wellKnownEndpoints.jwks_uri,\n        authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n        tokenEndpoint: wellKnownEndpoints.token_endpoint,\n        userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n        endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n        checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n        revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n        introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n        parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n      })));\n    }\n\n    getWellKnownDocument(wellKnownEndpoint, config) {\n      let url = wellKnownEndpoint;\n\n      if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n        url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n      }\n\n      return this.http.get(url, config).pipe(retry(2));\n    }\n\n  }\n\n  AuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n    return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService), i0.ɵɵinject(LoggerService));\n  };\n\n  AuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthWellKnownDataService,\n    factory: AuthWellKnownDataService.ɵfac\n  });\n  return AuthWellKnownDataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthWellKnownService = /*#__PURE__*/(() => {\n  class AuthWellKnownService {\n    constructor(dataService, publicEventsService, storagePersistenceService) {\n      this.dataService = dataService;\n      this.publicEventsService = publicEventsService;\n      this.storagePersistenceService = storagePersistenceService;\n    }\n\n    storeWellKnownEndpoints(config, mappedWellKnownEndpoints) {\n      this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, config);\n    }\n\n    queryAndStoreAuthWellKnownEndPoints(config) {\n      const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n      if (!!alreadySavedWellKnownEndpoints) {\n        return of(alreadySavedWellKnownEndpoints);\n      }\n\n      return this.dataService.getWellKnownEndPointsForConfig(config).pipe(tap$1(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(config, mappedWellKnownEndpoints)), catchError$1(error => {\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  AuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n    return new (t || AuthWellKnownService)(i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService));\n  };\n\n  AuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthWellKnownService,\n    factory: AuthWellKnownService.ɵfac\n  });\n  return AuthWellKnownService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RefreshSessionIframeService = /*#__PURE__*/(() => {\n  class RefreshSessionIframeService {\n    constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\n      this.doc = doc;\n      this.loggerService = loggerService;\n      this.urlService = urlService;\n      this.silentRenewService = silentRenewService;\n      this.renderer = rendererFactory.createRenderer(null, null);\n    }\n\n    refreshSessionWithIframe(config, allConfigs, customParams) {\n      this.loggerService.logDebug(config, 'BEGIN refresh session Authorize Iframe renew');\n      return this.urlService.getRefreshSessionSilentRenewUrl(config, customParams).pipe(switchMap(url => {\n        return this.sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs);\n      }));\n    }\n\n    sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs) {\n      const sessionIframe = this.silentRenewService.getOrCreateIframe(config);\n      this.initSilentRenewRequest(config, allConfigs);\n      this.loggerService.logDebug(config, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n      return new Observable(observer => {\n        const onLoadHandler = () => {\n          sessionIframe.removeEventListener('load', onLoadHandler);\n          this.loggerService.logDebug(config, 'removed event listener from IFrame');\n          observer.next(true);\n          observer.complete();\n        };\n\n        sessionIframe.addEventListener('load', onLoadHandler);\n        sessionIframe.contentWindow.location.replace(url);\n      });\n    }\n\n    initSilentRenewRequest(config, allConfigs) {\n      const instanceId = Math.random();\n      const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n        if (e.detail !== instanceId) {\n          initDestroyHandler();\n          renewDestroyHandler();\n        }\n      });\n      const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, config, allConfigs));\n      this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n        detail: instanceId\n      }));\n    }\n\n  }\n\n  RefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n    return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n  };\n\n  RefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshSessionIframeService,\n    factory: RefreshSessionIframeService.ɵfac,\n    providedIn: 'root'\n  });\n  return RefreshSessionIframeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RefreshSessionRefreshTokenService = /*#__PURE__*/(() => {\n  class RefreshSessionRefreshTokenService {\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n      this.loggerService = loggerService;\n      this.resetAuthDataService = resetAuthDataService;\n      this.flowsService = flowsService;\n      this.intervalService = intervalService;\n    }\n\n    refreshSessionWithRefreshTokens(config, allConfigs, customParamsRefresh) {\n      this.loggerService.logDebug(config, 'BEGIN refresh session Authorize');\n      return this.flowsService.processRefreshToken(config, allConfigs, customParamsRefresh).pipe(catchError(error => {\n        this.intervalService.stopPeriodicTokenCheck();\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        return throwError(() => new Error(error));\n      }));\n    }\n\n  }\n\n  RefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n    return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n  };\n\n  RefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshSessionRefreshTokenService,\n    factory: RefreshSessionRefreshTokenService.ɵfac,\n    providedIn: 'root'\n  });\n  return RefreshSessionRefreshTokenService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\nlet RefreshSessionService = /*#__PURE__*/(() => {\n  class RefreshSessionService {\n    constructor(flowHelper, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n      this.flowHelper = flowHelper;\n      this.flowsDataService = flowsDataService;\n      this.loggerService = loggerService;\n      this.silentRenewService = silentRenewService;\n      this.authStateService = authStateService;\n      this.authWellKnownService = authWellKnownService;\n      this.refreshSessionIframeService = refreshSessionIframeService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n      this.userService = userService;\n    }\n\n    userForceRefreshSession(config, allConfigs, extraCustomParams) {\n      this.persistCustomParams(extraCustomParams, config);\n      return this.forceRefreshSession(config, allConfigs, extraCustomParams);\n    }\n\n    forceRefreshSession(config, allConfigs, extraCustomParams) {\n      const {\n        customParamsRefreshTokenRequest,\n        configId\n      } = config;\n      const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n        return this.startRefreshSession(config, allConfigs, mergedParams).pipe(map(() => {\n          const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n          if (isAuthenticated) {\n            return {\n              idToken: this.authStateService.getIdToken(config),\n              accessToken: this.authStateService.getAccessToken(config),\n              userData: this.userService.getUserDataFromStore(config),\n              isAuthenticated,\n              configId\n            };\n          }\n\n          return null;\n        }));\n      }\n\n      const {\n        silentRenewTimeoutInSeconds\n      } = config;\n      const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n      return forkJoin([this.startRefreshSession(config, allConfigs, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n        var _a, _b;\n\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n        if (isAuthenticated) {\n          return {\n            idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\n            accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\n            userData: this.userService.getUserDataFromStore(config),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    persistCustomParams(extraCustomParams, config) {\n      const {\n        useRefreshToken\n      } = config;\n\n      if (extraCustomParams) {\n        if (useRefreshToken) {\n          this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, config);\n        } else {\n          this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, config);\n        }\n      }\n    }\n\n    startRefreshSession(config, allConfigs, extraCustomParams) {\n      const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n      this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n      const shouldBeExecuted = !isSilentRenewRunning;\n\n      if (!shouldBeExecuted) {\n        return of(null);\n      }\n\n      return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config).pipe(switchMap(() => {\n        this.flowsDataService.setSilentRenewRunning(config);\n\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n          // Refresh Session using Refresh tokens\n          return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, extraCustomParams);\n        }\n\n        return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, extraCustomParams);\n      }));\n    }\n\n    timeoutRetryStrategy(errorAttempts, config) {\n      return errorAttempts.pipe(mergeMap((error, index) => {\n        const scalingDuration = 1000;\n        const currentAttempt = index + 1;\n\n        if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n          return throwError(() => new Error(error));\n        }\n\n        this.loggerService.logDebug(config, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n        this.flowsDataService.resetSilentRenewRunning(config);\n        return timer(currentAttempt * scalingDuration);\n      }));\n    }\n\n  }\n\n  RefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n    return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n  };\n\n  RefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshSessionService,\n    factory: RefreshSessionService.ɵfac,\n    providedIn: 'root'\n  });\n  return RefreshSessionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  disableRefreshIdTokenAuthTimeValidation: false,\n  enableIdTokenExpiredValidationInRenew: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  if (!passedConfig) {\n    return null;\n  }\n\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const someAreNull = allIdentifiers.some(x => x === null);\n\n  if (someAreNull) {\n    return {\n      result: false,\n      messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\n      level: 'error'\n    };\n  }\n\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectUrl is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\nlet ConfigValidationService = /*#__PURE__*/(() => {\n  class ConfigValidationService {\n    constructor(loggerService) {\n      this.loggerService = loggerService;\n    }\n\n    validateConfigs(passedConfigs) {\n      return this.validateConfigsInternal(passedConfigs !== null && passedConfigs !== void 0 ? passedConfigs : [], allMultipleConfigRules);\n    }\n\n    validateConfig(passedConfig) {\n      return this.validateConfigInternal(passedConfig, allRules);\n    }\n\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\n      const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n      let overallErrorCount = 0;\n      passedConfigs.forEach(passedConfig => {\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n        overallErrorCount += errorCount;\n      });\n      return overallErrorCount === 0;\n    }\n\n    validateConfigInternal(passedConfig, allRulesToUse) {\n      const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n      return errorCount === 0;\n    }\n\n    processValidationResultsAndGetErrorCount(allValidationResults, config) {\n      const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n      const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n      const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n      allErrorMessages.forEach(message => this.loggerService.logError(config, message));\n      allWarnings.forEach(message => this.loggerService.logWarning(config, message));\n      return allErrorMessages.length;\n    }\n\n    getAllMessagesOfType(type, results) {\n      const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n      return allMessages.reduce((acc, val) => acc.concat(val), []);\n    }\n\n  }\n\n  ConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n    return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n  };\n\n  ConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigValidationService,\n    factory: ConfigValidationService.ɵfac\n  });\n  return ConfigValidationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PlatformProvider = /*#__PURE__*/(() => {\n  class PlatformProvider {\n    constructor(platformId) {\n      this.platformId = platformId;\n    }\n\n    isBrowser() {\n      return isPlatformBrowser(this.platformId);\n    }\n\n  }\n\n  PlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n    return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  PlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PlatformProvider,\n    factory: PlatformProvider.ɵfac\n  });\n  return PlatformProvider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      return this.passedConfigs.map(x => of(x));\n    }\n\n    const singleStaticConfig$ = of(this.passedConfigs);\n    return [singleStaticConfig$];\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\n  }\n\n}\n\nlet ConfigurationService = /*#__PURE__*/(() => {\n  class ConfigurationService {\n    constructor(loggerService, publicEventsService, storagePersistenceService, configValidationService, platformProvider, authWellKnownService, loader) {\n      this.loggerService = loggerService;\n      this.publicEventsService = publicEventsService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.configValidationService = configValidationService;\n      this.platformProvider = platformProvider;\n      this.authWellKnownService = authWellKnownService;\n      this.loader = loader;\n      this.configsInternal = {};\n    }\n\n    hasManyConfigs() {\n      return Object.keys(this.configsInternal).length > 1;\n    }\n\n    getAllConfigurations() {\n      return Object.values(this.configsInternal);\n    }\n\n    getOpenIDConfiguration(configId) {\n      if (this.configsAlreadySaved()) {\n        return of(this.getConfig(configId));\n      }\n\n      return this.getOpenIDConfigurations(configId).pipe(map(result => result.currentConfig));\n    }\n\n    getOpenIDConfigurations(configId) {\n      return this.loadConfigs().pipe(concatMap(allConfigs => this.prepareAndSaveConfigs(allConfigs)), map(allPreparedConfigs => ({\n        allConfigs: allPreparedConfigs,\n        currentConfig: this.getConfig(configId)\n      })));\n    }\n\n    hasAtLeastOneConfig() {\n      return Object.keys(this.configsInternal).length > 0;\n    }\n\n    saveConfig(readyConfig) {\n      const {\n        configId\n      } = readyConfig;\n      this.configsInternal[configId] = readyConfig;\n    }\n\n    loadConfigs() {\n      return forkJoin(this.loader.loadConfigs());\n    }\n\n    configsAlreadySaved() {\n      return this.hasAtLeastOneConfig();\n    }\n\n    getConfig(configId) {\n      if (!!configId) {\n        return this.configsInternal[configId] || null;\n      }\n\n      const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n      return value || null;\n    }\n\n    prepareAndSaveConfigs(passedConfigs) {\n      if (!this.configValidationService.validateConfigs(passedConfigs)) {\n        return of(null);\n      }\n\n      this.createUniqueIds(passedConfigs);\n      const allHandleConfigs$ = passedConfigs.map(x => this.handleConfig(x));\n      return forkJoin(allHandleConfigs$);\n    }\n\n    createUniqueIds(passedConfigs) {\n      passedConfigs.forEach((config, index) => {\n        if (!config.configId) {\n          config.configId = `${index}-${config.clientId}`;\n        }\n      });\n    }\n\n    handleConfig(passedConfig) {\n      if (!this.configValidationService.validateConfig(passedConfig)) {\n        this.loggerService.logError(passedConfig, 'Validation of config rejected with errors. Config is NOT set.');\n        return of(null);\n      }\n\n      if (!passedConfig.authWellknownEndpointUrl) {\n        passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n      }\n\n      const usedConfig = this.prepareConfig(passedConfig);\n      this.saveConfig(usedConfig);\n      const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig);\n\n      if (!!alreadyExistingAuthWellKnownEndpoints) {\n        usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        return of(usedConfig);\n      }\n\n      const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\n\n      if (!!passedAuthWellKnownEndpoints) {\n        this.authWellKnownService.storeWellKnownEndpoints(usedConfig, passedAuthWellKnownEndpoints);\n        usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n      }\n\n      return of(usedConfig);\n    }\n\n    prepareConfig(configuration) {\n      const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\n      this.setSpecialCases(openIdConfigurationInternal);\n      return openIdConfigurationInternal;\n    }\n\n    setSpecialCases(currentConfig) {\n      if (!this.platformProvider.isBrowser()) {\n        currentConfig.startCheckSession = false;\n        currentConfig.silentRenew = false;\n        currentConfig.useRefreshToken = false;\n        currentConfig.usePushedAuthorisationRequests = false;\n      }\n    }\n\n    hasBrowserStorage() {\n      return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n    }\n\n  }\n\n  ConfigurationService.ɵfac = function ConfigurationService_Factory(t) {\n    return new (t || ConfigurationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StsConfigLoader));\n  };\n\n  ConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigurationService,\n    factory: ConfigurationService.ɵfac\n  });\n  return ConfigurationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PeriodicallyTokenCheckService = /*#__PURE__*/(() => {\n  class PeriodicallyTokenCheckService {\n    constructor(resetAuthDataService, flowHelper, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService, configurationService) {\n      this.resetAuthDataService = resetAuthDataService;\n      this.flowHelper = flowHelper;\n      this.flowsDataService = flowsDataService;\n      this.loggerService = loggerService;\n      this.userService = userService;\n      this.authStateService = authStateService;\n      this.refreshSessionIframeService = refreshSessionIframeService;\n      this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n      this.intervalService = intervalService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.publicEventsService = publicEventsService;\n      this.configurationService = configurationService;\n    }\n\n    startTokenValidationPeriodically(allConfigs, currentConfig) {\n      const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled(allConfigs);\n\n      if (configsWithSilentRenewEnabled.length <= 0) {\n        return;\n      }\n\n      if (this.intervalService.isTokenValidationRunning()) {\n        return;\n      }\n\n      const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n      const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n        const objectWithConfigIdsAndRefreshEvent = {};\n        configsWithSilentRenewEnabled.forEach(config => {\n          objectWithConfigIdsAndRefreshEvent[config.configId] = this.getRefreshEvent(config, allConfigs);\n        });\n        return forkJoin(objectWithConfigIdsAndRefreshEvent);\n      }));\n      this.intervalService.runTokenValidationRunning = periodicallyCheck$.pipe(catchError(error => throwError(() => new Error(error)))).subscribe({\n        next: objectWithConfigIds => {\n          for (const [configId, _] of Object.entries(objectWithConfigIds)) {\n            this.configurationService.getOpenIDConfiguration(configId).subscribe(config => {\n              this.loggerService.logDebug(config, 'silent renew, periodic check finished!');\n\n              if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n                this.flowsDataService.resetSilentRenewRunning(config);\n              }\n            });\n          }\n        },\n        error: error => {\n          this.loggerService.logError(currentConfig, 'silent renew failed!', error);\n        }\n      });\n    }\n\n    getRefreshEvent(config, allConfigs) {\n      const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(config);\n\n      if (!shouldStartRefreshEvent) {\n        return of(null);\n      }\n\n      const refreshEvent$ = this.createRefreshEventForConfig(config, allConfigs);\n      this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n      const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n        this.loggerService.logError(config, 'silent renew failed!', error);\n        this.flowsDataService.resetSilentRenewRunning(config);\n        return throwError(() => new Error(error));\n      }));\n      return refreshEventWithErrorHandler$;\n    }\n\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n      const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n      return result.tokenRefreshInSeconds;\n    }\n\n    getConfigsWithSilentRenewEnabled(allConfigs) {\n      return allConfigs.filter(x => x.silentRenew);\n    }\n\n    createRefreshEventForConfig(configuration, allConfigs) {\n      this.loggerService.logDebug(configuration, 'starting silent renew...');\n      return this.configurationService.getOpenIDConfiguration(configuration.configId).pipe(switchMap(config => {\n        if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\n          this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n          return of(null);\n        }\n\n        this.flowsDataService.setSilentRenewRunning(config);\n\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n          // Retrieve Dynamically Set Custom Params for refresh body\n          const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', config) || {};\n          const {\n            customParamsRefreshTokenRequest\n          } = config;\n          const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh); // Refresh Session using Refresh tokens\n\n          return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, mergedParams);\n        } // Retrieve Dynamically Set Custom Params\n\n\n        const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', config);\n        return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, customParams);\n      }));\n    }\n\n    shouldStartPeriodicallyCheckForConfig(config) {\n      const idToken = this.authStateService.getIdToken(config);\n      const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n      const userDataFromStore = this.userService.getUserDataFromStore(config);\n      this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n      const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\n\n      if (!shouldBeExecuted) {\n        return false;\n      }\n\n      const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(config);\n      const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(config);\n\n      if (!idTokenStillValid && !accessTokenHasExpired) {\n        return false;\n      }\n\n      return true;\n    }\n\n  }\n\n  PeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n    return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationService));\n  };\n\n  PeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PeriodicallyTokenCheckService,\n    factory: PeriodicallyTokenCheckService.ɵfac,\n    providedIn: 'root'\n  });\n  return PeriodicallyTokenCheckService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PopUpService = /*#__PURE__*/(() => {\n  class PopUpService {\n    constructor(document) {\n      this.document = document;\n      this.STORAGE_IDENTIFIER = 'popupauth';\n      this.resultInternal$ = new Subject();\n    }\n\n    get result$() {\n      return this.resultInternal$.asObservable();\n    }\n\n    get windowInternal() {\n      return this.document.defaultView;\n    }\n\n    isCurrentlyInPopup() {\n      if (this.canAccessSessionStorage()) {\n        const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\n        return !!this.windowInternal.opener && this.windowInternal.opener !== this.windowInternal && !!popup;\n      }\n\n      return false;\n    }\n\n    openPopUp(url, popupOptions) {\n      const optionsToPass = this.getOptions(popupOptions);\n      this.popUp = this.windowInternal.open(url, '_blank', optionsToPass);\n      this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\n\n      const listener = event => {\n        if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\n          return;\n        }\n\n        this.resultInternal$.next({\n          userClosed: false,\n          receivedUrl: event.data\n        });\n        this.cleanUp(listener);\n      };\n\n      this.windowInternal.addEventListener('message', listener, false);\n      this.handle = this.windowInternal.setInterval(() => {\n        if (this.popUp.closed) {\n          this.resultInternal$.next({\n            userClosed: true\n          });\n          this.cleanUp(listener);\n        }\n      }, 200);\n    }\n\n    sendMessageToMainWindow(url) {\n      if (this.windowInternal.opener) {\n        const href = this.windowInternal.location.href;\n        this.sendMessage(url, href);\n      }\n    }\n\n    cleanUp(listener) {\n      var _a;\n\n      this.windowInternal.removeEventListener('message', listener, false);\n      this.windowInternal.clearInterval(this.handle);\n\n      if (this.popUp) {\n        (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\n        this.popUp.close();\n        this.popUp = null;\n      }\n    }\n\n    sendMessage(url, href) {\n      this.windowInternal.opener.postMessage(url, href);\n    }\n\n    getOptions(popupOptions) {\n      const popupDefaultOptions = {\n        width: 500,\n        height: 500,\n        left: 50,\n        top: 50\n      };\n      const options = Object.assign(Object.assign({}, popupDefaultOptions), popupOptions || {});\n      const left = this.windowInternal.screenLeft + (this.windowInternal.outerWidth - options.width) / 2;\n      const top = this.windowInternal.screenTop + (this.windowInternal.outerHeight - options.height) / 2;\n      options.left = left;\n      options.top = top;\n      return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n    }\n\n    canAccessSessionStorage() {\n      return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n    }\n\n  }\n\n  PopUpService.ɵfac = function PopUpService_Factory(t) {\n    return new (t || PopUpService)(i0.ɵɵinject(DOCUMENT));\n  };\n\n  PopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PopUpService,\n    factory: PopUpService.ɵfac,\n    providedIn: 'root'\n  });\n  return PopUpService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst STORAGE_KEY = 'redirect';\nlet AutoLoginService = /*#__PURE__*/(() => {\n  class AutoLoginService {\n    constructor(storageService, router) {\n      this.storageService = storageService;\n      this.router = router;\n    }\n\n    checkSavedRedirectRouteAndNavigate(config) {\n      const savedRouteForRedirect = this.getStoredRedirectRoute(config);\n\n      if (savedRouteForRedirect) {\n        this.deleteStoredRedirectRoute(config);\n        this.router.navigateByUrl(savedRouteForRedirect);\n      }\n    }\n    /**\r\n     * Saves the redirect URL to storage.\r\n     *\r\n     * @param url The redirect URL to save.\r\n     */\n\n\n    saveRedirectRoute(config, url) {\n      this.storageService.write(STORAGE_KEY, url, config);\n    }\n    /**\r\n     * Gets the stored redirect URL from storage.\r\n     */\n\n\n    getStoredRedirectRoute(config) {\n      return this.storageService.read(STORAGE_KEY, config);\n    }\n    /**\r\n     * Removes the redirect URL from storage.\r\n     */\n\n\n    deleteStoredRedirectRoute(config) {\n      this.storageService.remove(STORAGE_KEY, config);\n    }\n\n  }\n\n  AutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n    return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n  };\n\n  AutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AutoLoginService,\n    factory: AutoLoginService.ɵfac\n  });\n  return AutoLoginService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CheckAuthService = /*#__PURE__*/(() => {\n  class CheckAuthService {\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\n      this.checkSessionService = checkSessionService;\n      this.currentUrlService = currentUrlService;\n      this.silentRenewService = silentRenewService;\n      this.userService = userService;\n      this.loggerService = loggerService;\n      this.authStateService = authStateService;\n      this.callbackService = callbackService;\n      this.refreshSessionService = refreshSessionService;\n      this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n      this.popupService = popupService;\n      this.autoLoginService = autoLoginService;\n      this.storagePersistenceService = storagePersistenceService;\n    }\n\n    checkAuth(configuration, allConfigs, url) {\n      if (this.currentUrlService.currentUrlHasStateParam()) {\n        const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n        const config = this.getConfigurationWithUrlState([configuration], stateParamFromUrl);\n\n        if (!config) {\n          return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n        }\n\n        return this.checkAuthWithConfig(config, allConfigs, url);\n      }\n\n      return this.checkAuthWithConfig(configuration, allConfigs, url);\n    }\n\n    checkAuthMultiple(allConfigs, url) {\n      if (this.currentUrlService.currentUrlHasStateParam()) {\n        const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n        const config = this.getConfigurationWithUrlState(allConfigs, stateParamFromUrl);\n\n        if (!config) {\n          return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n        }\n\n        return this.composeMultipleLoginResults(allConfigs, config, url);\n      }\n\n      const configs = allConfigs !== null && allConfigs !== void 0 ? allConfigs : [];\n      const allChecks$ = configs.map(x => this.checkAuthWithConfig(x, configs, url));\n      return forkJoin(allChecks$);\n    }\n\n    checkAuthIncludingServer(configuration, allConfigs) {\n      return this.checkAuthWithConfig(configuration, allConfigs).pipe(switchMap(loginResponse => {\n        const {\n          isAuthenticated\n        } = loginResponse;\n\n        if (isAuthenticated) {\n          return of(loginResponse);\n        }\n\n        return this.refreshSessionService.forceRefreshSession(configuration, allConfigs).pipe(tap(loginResponseAfterRefreshSession => {\n          if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\n            this.startCheckSessionAndValidation(configuration, allConfigs);\n          }\n        }));\n      }));\n    }\n\n    checkAuthWithConfig(config, allConfigs, url) {\n      if (!config) {\n        const errorMessage = 'Please provide at least one configuration before setting up the module';\n        this.loggerService.logError(config, errorMessage);\n        return of({\n          isAuthenticated: false,\n          errorMessage,\n          userData: null,\n          idToken: null,\n          accessToken: null,\n          configId: null\n        });\n      }\n\n      const currentUrl = url || this.currentUrlService.getCurrentUrl();\n      const {\n        configId,\n        authority\n      } = config;\n      this.loggerService.logDebug(config, `Working with config '${configId}' using ${authority}`);\n\n      if (this.popupService.isCurrentlyInPopup()) {\n        this.popupService.sendMessageToMainWindow(currentUrl);\n        return of(null);\n      }\n\n      const isCallback = this.callbackService.isCallback(currentUrl);\n      this.loggerService.logDebug(config, 'currentUrl to check auth with: ', currentUrl);\n      const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, config, allConfigs) : of(null);\n      return callback$.pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n        if (isAuthenticated) {\n          this.startCheckSessionAndValidation(config, allConfigs);\n\n          if (!isCallback) {\n            this.authStateService.setAuthenticatedAndFireEvent(allConfigs);\n            this.userService.publishUserDataIfExists(config, allConfigs);\n          }\n        }\n\n        this.loggerService.logDebug(config, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n        return {\n          isAuthenticated,\n          userData: this.userService.getUserDataFromStore(config),\n          accessToken: this.authStateService.getAccessToken(config),\n          idToken: this.authStateService.getIdToken(config),\n          configId\n        };\n      }), tap(({\n        isAuthenticated\n      }) => {\n        if (isAuthenticated) {\n          this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n        }\n      }), catchError(({\n        message\n      }) => {\n        this.loggerService.logError(config, message);\n        return of({\n          isAuthenticated: false,\n          errorMessage: message,\n          userData: null,\n          idToken: null,\n          accessToken: null,\n          configId\n        });\n      }));\n    }\n\n    startCheckSessionAndValidation(config, allConfigs) {\n      if (this.checkSessionService.isCheckSessionConfigured(config)) {\n        this.checkSessionService.start(config);\n      }\n\n      this.periodicallyTokenCheckService.startTokenValidationPeriodically(allConfigs, config);\n\n      if (this.silentRenewService.isSilentRenewConfigured(config)) {\n        this.silentRenewService.getOrCreateIframe(config);\n      }\n    }\n\n    getConfigurationWithUrlState(configurations, stateFromUrl) {\n      for (const config of configurations) {\n        const storedState = this.storagePersistenceService.read('authStateControl', config);\n\n        if (storedState === stateFromUrl) {\n          return config;\n        }\n      }\n\n      return null;\n    }\n\n    composeMultipleLoginResults(configurations, activeConfig, url) {\n      const allOtherConfigs = configurations.filter(x => x.configId !== activeConfig.configId);\n      const currentConfigResult = this.checkAuthWithConfig(activeConfig, configurations, url);\n      const allOtherConfigResults = allOtherConfigs.map(config => {\n        const {\n          redirectUrl\n        } = config;\n        return this.checkAuthWithConfig(config, configurations, redirectUrl);\n      });\n      return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n    }\n\n  }\n\n  CheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n    return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService));\n  };\n\n  CheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CheckAuthService,\n    factory: CheckAuthService.ɵfac\n  });\n  return CheckAuthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ClosestMatchingRouteService = /*#__PURE__*/(() => {\n  class ClosestMatchingRouteService {\n    getConfigIdForClosestMatchingRoute(route, configurations) {\n      for (const config of configurations) {\n        const {\n          secureRoutes\n        } = config;\n\n        for (const configuredRoute of secureRoutes) {\n          if (route.startsWith(configuredRoute)) {\n            return {\n              matchingRoute: configuredRoute,\n              matchingConfig: config\n            };\n          }\n        }\n      }\n\n      return {\n        matchingRoute: null,\n        matchingConfig: null\n      };\n    }\n\n  }\n\n  ClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n    return new (t || ClosestMatchingRouteService)();\n  };\n\n  ClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClosestMatchingRouteService,\n    factory: ClosestMatchingRouteService.ɵfac\n  });\n  return ClosestMatchingRouteService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ConsoleLoggerService = /*#__PURE__*/(() => {\n  class ConsoleLoggerService {\n    logError(message, ...args) {\n      console.error(message, ...args);\n    }\n\n    logWarning(message, ...args) {\n      console.warn(message, ...args);\n    }\n\n    logDebug(message, ...args) {\n      console.log(message, ...args);\n    }\n\n  }\n\n  ConsoleLoggerService.ɵfac = function ConsoleLoggerService_Factory(t) {\n    return new (t || ConsoleLoggerService)();\n  };\n\n  ConsoleLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConsoleLoggerService,\n    factory: ConsoleLoggerService.ɵfac\n  });\n  return ConsoleLoggerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ResponseTypeValidationService = /*#__PURE__*/(() => {\n  class ResponseTypeValidationService {\n    constructor(loggerService, flowHelper) {\n      this.loggerService = loggerService;\n      this.flowHelper = flowHelper;\n    }\n\n    hasConfigValidResponseType(configuration) {\n      if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configuration)) {\n        return true;\n      }\n\n      if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\n        return true;\n      }\n\n      this.loggerService.logWarning(configuration, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n      return false;\n    }\n\n  }\n\n  ResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n    return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n  };\n\n  ResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResponseTypeValidationService,\n    factory: ResponseTypeValidationService.ɵfac\n  });\n  return ResponseTypeValidationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RedirectService = /*#__PURE__*/(() => {\n  class RedirectService {\n    constructor(doc) {\n      this.doc = doc;\n    }\n\n    redirectTo(url) {\n      this.doc.location.href = url;\n    }\n\n  }\n\n  RedirectService.ɵfac = function RedirectService_Factory(t) {\n    return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n  };\n\n  RedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RedirectService,\n    factory: RedirectService.ɵfac,\n    providedIn: 'root'\n  });\n  return RedirectService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ParService = /*#__PURE__*/(() => {\n  class ParService {\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\n      this.loggerService = loggerService;\n      this.urlService = urlService;\n      this.dataService = dataService;\n      this.storagePersistenceService = storagePersistenceService;\n    }\n\n    postParRequest(configuration, customParams) {\n      let headers = new HttpHeaders();\n      headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n      const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (!authWellKnownEndpoints) {\n        return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\n      }\n\n      const parEndpoint = authWellKnownEndpoints.parEndpoint;\n\n      if (!parEndpoint) {\n        return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\n      }\n\n      return this.urlService.createBodyForParCodeFlowRequest(configuration, customParams).pipe(switchMap(data => {\n        return this.dataService.post(parEndpoint, data, configuration, headers).pipe(retry(2), map(response => {\n          this.loggerService.logDebug(configuration, 'par response: ', response);\n          return {\n            expiresIn: response.expires_in,\n            requestUri: response.request_uri\n          };\n        }), catchError(error => {\n          const errorMessage = `There was an error on ParService postParRequest`;\n          this.loggerService.logError(configuration, errorMessage, error);\n          return throwError(() => new Error(errorMessage));\n        }));\n      }));\n    }\n\n  }\n\n  ParService.ɵfac = function ParService_Factory(t) {\n    return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n  };\n\n  ParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ParService,\n    factory: ParService.ɵfac\n  });\n  return ParService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ParLoginService = /*#__PURE__*/(() => {\n  class ParLoginService {\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, popupService, checkAuthService, parService) {\n      this.loggerService = loggerService;\n      this.responseTypeValidationService = responseTypeValidationService;\n      this.urlService = urlService;\n      this.redirectService = redirectService;\n      this.authWellKnownService = authWellKnownService;\n      this.popupService = popupService;\n      this.checkAuthService = checkAuthService;\n      this.parService = parService;\n    }\n\n    loginPar(configuration, authOptions) {\n      if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n        this.loggerService.logError(configuration, 'Invalid response type!');\n        return;\n      }\n\n      this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n      const {\n        urlHandler,\n        customParams\n      } = authOptions || {};\n      this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams))).subscribe(response => {\n        this.loggerService.logDebug(configuration, 'par response: ', response);\n        const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n        this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n        if (!url) {\n          this.loggerService.logError(configuration, `Could not create URL with param ${response.requestUri}: '${url}'`);\n          return;\n        }\n\n        if (urlHandler) {\n          urlHandler(url);\n        } else {\n          this.redirectService.redirectTo(url);\n        }\n      });\n    }\n\n    loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions) {\n      const {\n        configId\n      } = configuration;\n\n      if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n        const errorMessage = 'Invalid response type!';\n        this.loggerService.logError(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n      const {\n        customParams\n      } = authOptions || {};\n      return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)), switchMap(response => {\n        this.loggerService.logDebug(configuration, 'par response: ', response);\n        const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n        this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n        if (!url) {\n          const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\n          this.loggerService.logError(configuration, errorMessage);\n          return throwError(() => new Error(errorMessage));\n        }\n\n        this.popupService.openPopUp(url, popupOptions);\n        return this.popupService.result$.pipe(take(1), switchMap(result => {\n          const {\n            userClosed,\n            receivedUrl\n          } = result;\n\n          if (userClosed) {\n            return of({\n              isAuthenticated: false,\n              errorMessage: 'User closed popup',\n              userData: null,\n              idToken: null,\n              accessToken: null,\n              configId\n            });\n          }\n\n          return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n        }));\n      }));\n    }\n\n  }\n\n  ParLoginService.ɵfac = function ParLoginService_Factory(t) {\n    return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n  };\n\n  ParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ParLoginService,\n    factory: ParLoginService.ɵfac\n  });\n  return ParLoginService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PopUpLoginService = /*#__PURE__*/(() => {\n  class PopUpLoginService {\n    constructor(loggerService, responseTypeValidationService, urlService, authWellKnownService, popupService, checkAuthService) {\n      this.loggerService = loggerService;\n      this.responseTypeValidationService = responseTypeValidationService;\n      this.urlService = urlService;\n      this.authWellKnownService = authWellKnownService;\n      this.popupService = popupService;\n      this.checkAuthService = checkAuthService;\n    }\n\n    loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions) {\n      const {\n        configId\n      } = configuration;\n\n      if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n        const errorMessage = 'Invalid response type!';\n        this.loggerService.logError(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n      return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => {\n        return this.urlService.getAuthorizeUrl(configuration, authOptions);\n      }), tap(authUrl => this.popupService.openPopUp(authUrl, popupOptions)), switchMap(() => {\n        return this.popupService.result$.pipe(take(1), switchMap(result => {\n          const {\n            userClosed,\n            receivedUrl\n          } = result;\n\n          if (userClosed) {\n            return of({\n              isAuthenticated: false,\n              errorMessage: 'User closed popup',\n              userData: null,\n              idToken: null,\n              accessToken: null,\n              configId\n            });\n          }\n\n          return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n        }));\n      }));\n    }\n\n  }\n\n  PopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n    return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n  };\n\n  PopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PopUpLoginService,\n    factory: PopUpLoginService.ɵfac\n  });\n  return PopUpLoginService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StandardLoginService = /*#__PURE__*/(() => {\n  class StandardLoginService {\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService) {\n      this.loggerService = loggerService;\n      this.responseTypeValidationService = responseTypeValidationService;\n      this.urlService = urlService;\n      this.redirectService = redirectService;\n      this.authWellKnownService = authWellKnownService;\n    }\n\n    loginStandard(configuration, authOptions) {\n      if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n        this.loggerService.logError(configuration, 'Invalid response type!');\n        return;\n      }\n\n      this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n      this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).subscribe(() => {\n        const {\n          urlHandler\n        } = authOptions || {};\n        this.urlService.getAuthorizeUrl(configuration, authOptions).subscribe(url => {\n          if (!url) {\n            this.loggerService.logError(configuration, 'Could not create URL', url);\n            return;\n          }\n\n          if (urlHandler) {\n            urlHandler(url);\n          } else {\n            this.redirectService.redirectTo(url);\n          }\n        });\n      });\n    }\n\n  }\n\n  StandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n    return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService));\n  };\n\n  StandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StandardLoginService,\n    factory: StandardLoginService.ɵfac\n  });\n  return StandardLoginService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoginService = /*#__PURE__*/(() => {\n  class LoginService {\n    constructor(parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\n      this.parLoginService = parLoginService;\n      this.popUpLoginService = popUpLoginService;\n      this.standardLoginService = standardLoginService;\n      this.storagePersistenceService = storagePersistenceService;\n    }\n\n    login(configuration, authOptions) {\n      const {\n        usePushedAuthorisationRequests\n      } = configuration;\n\n      if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n      }\n\n      if (usePushedAuthorisationRequests) {\n        return this.parLoginService.loginPar(configuration, authOptions);\n      } else {\n        return this.standardLoginService.loginStandard(configuration, authOptions);\n      }\n    }\n\n    loginWithPopUp(configuration, allConfigs, authOptions, popupOptions) {\n      const {\n        usePushedAuthorisationRequests\n      } = configuration;\n\n      if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n      }\n\n      if (usePushedAuthorisationRequests) {\n        return this.parLoginService.loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions);\n      } else {\n        return this.popUpLoginService.loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions);\n      }\n    }\n\n  }\n\n  LoginService.ɵfac = function LoginService_Factory(t) {\n    return new (t || LoginService)(i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService));\n  };\n\n  LoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoginService,\n    factory: LoginService.ɵfac\n  });\n  return LoginService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LogoffRevocationService = /*#__PURE__*/(() => {\n  class LogoffRevocationService {\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService) {\n      this.dataService = dataService;\n      this.storagePersistenceService = storagePersistenceService;\n      this.loggerService = loggerService;\n      this.urlService = urlService;\n      this.checkSessionService = checkSessionService;\n      this.resetAuthDataService = resetAuthDataService;\n      this.redirectService = redirectService;\n    } // Logs out on the server and the local client.\n    // If the server state has changed, check session, then only a local logout.\n\n\n    logoff(config, allConfigs, authOptions) {\n      const {\n        urlHandler,\n        customParams\n      } = authOptions || {};\n      this.loggerService.logDebug(config, 'logoff, remove auth ');\n      const endSessionUrl = this.getEndSessionUrl(config, customParams);\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n\n      if (!endSessionUrl) {\n        this.loggerService.logDebug(config, 'only local login cleaned up, no end_session_endpoint');\n        return;\n      }\n\n      if (this.checkSessionService.serverStateChanged(config)) {\n        this.loggerService.logDebug(config, 'only local login cleaned up, server session has changed');\n      } else if (urlHandler) {\n        urlHandler(endSessionUrl);\n      } else {\n        this.redirectService.redirectTo(endSessionUrl);\n      }\n    }\n\n    logoffLocal(config, allConfigs) {\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      this.checkSessionService.stop();\n    }\n\n    logoffLocalMultiple(allConfigs) {\n      allConfigs.forEach(configuration => this.logoffLocal(configuration, allConfigs));\n    } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n    // only the access token is revoked. Then the logout run.\n\n\n    logoffAndRevokeTokens(config, allConfigs, authOptions) {\n      const {\n        revocationEndpoint\n      } = this.storagePersistenceService.read('authWellKnownEndPoints', config) || {};\n\n      if (!revocationEndpoint) {\n        this.loggerService.logDebug(config, 'revocation endpoint not supported');\n        this.logoff(config, allConfigs, authOptions);\n        return of(null);\n      }\n\n      if (this.storagePersistenceService.getRefreshToken(config)) {\n        return this.revokeRefreshToken(config).pipe(switchMap(result => this.revokeAccessToken(config, result)), catchError(error => {\n          const errorMessage = `revoke token failed`;\n          this.loggerService.logError(config, errorMessage, error);\n          return throwError(() => new Error(errorMessage));\n        }), tap(() => this.logoff(config, allConfigs, authOptions)));\n      } else {\n        return this.revokeAccessToken(config).pipe(catchError(error => {\n          const errorMessage = `revoke accessToken failed`;\n          this.loggerService.logError(config, errorMessage, error);\n          return throwError(() => new Error(errorMessage));\n        }), tap(() => this.logoff(config, allConfigs, authOptions)));\n      }\n    } // https://tools.ietf.org/html/rfc7009\n    // revokes an access token on the STS. If no token is provided, then the token from\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\n    // manage your own tokens. The is a public API.\n\n\n    revokeAccessToken(configuration, accessToken) {\n      const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configuration);\n      const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configuration);\n      return this.sendRevokeRequest(configuration, body);\n    } // https://tools.ietf.org/html/rfc7009\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n    // This makes it possible to manage your own tokens.\n\n\n    revokeRefreshToken(configuration, refreshToken) {\n      const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configuration);\n      const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configuration);\n      return this.sendRevokeRequest(configuration, body);\n    }\n\n    getEndSessionUrl(configuration, customParams) {\n      const idToken = this.storagePersistenceService.getIdToken(configuration);\n      const {\n        customParamsEndSessionRequest\n      } = configuration;\n      const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\n      return this.urlService.createEndSessionUrl(idToken, configuration, mergedParams);\n    }\n\n    sendRevokeRequest(configuration, body) {\n      const url = this.urlService.getRevocationEndpointUrl(configuration);\n      let headers = new HttpHeaders();\n      headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n      return this.dataService.post(url, body, configuration, headers).pipe(retry(2), switchMap(response => {\n        this.loggerService.logDebug(configuration, 'revocation endpoint post response: ', response);\n        return of(response);\n      }), catchError(error => {\n        const errorMessage = `Revocation request failed`;\n        this.loggerService.logError(configuration, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }\n\n  }\n\n  LogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n    return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService));\n  };\n\n  LogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LogoffRevocationService,\n    factory: LogoffRevocationService.ɵfac\n  });\n  return LogoffRevocationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet OidcSecurityService = /*#__PURE__*/(() => {\n  class OidcSecurityService {\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationService, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService, authWellKnownService) {\n      this.checkSessionService = checkSessionService;\n      this.checkAuthService = checkAuthService;\n      this.userService = userService;\n      this.tokenHelperService = tokenHelperService;\n      this.configurationService = configurationService;\n      this.authStateService = authStateService;\n      this.flowsDataService = flowsDataService;\n      this.callbackService = callbackService;\n      this.logoffRevocationService = logoffRevocationService;\n      this.loginService = loginService;\n      this.refreshSessionService = refreshSessionService;\n      this.urlService = urlService;\n      this.authWellKnownService = authWellKnownService;\n      this.isLoading = new BehaviorSubject(true);\n\n      this.finishLoading = () => {\n        this.isLoading.next(false);\n      };\n\n      this.finishLoadingOnError = err => {\n        this.isLoading.next(false);\n        return throwError(() => err);\n      };\n    }\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\n\n\n    get userData$() {\n      return this.userService.userData$;\n    }\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\n\n\n    get isAuthenticated$() {\n      return this.authStateService.authenticated$;\n    }\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\n\n\n    get checkSessionChanged$() {\n      return this.checkSessionService.checkSessionChanged$;\n    }\n    /**\r\n     * Emits on a Security Token Service callback. The observable will never contain a value.\r\n     */\n\n\n    get stsCallback$() {\n      return this.callbackService.stsCallback$;\n    }\n    /**\r\n     * Emits false when the observable, returned by one of the checkAuth() methods, emits a value, or errors. Initial value: true.\r\n     */\n\n\n    get isLoading$() {\n      return this.isLoading.asObservable();\n    }\n\n    preloadAuthWellKnownDocument(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap$1(config => this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config)));\n    }\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\n\n\n    getConfigurations() {\n      return this.configurationService.getAllConfigurations();\n    }\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\n\n\n    getConfiguration(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId);\n    }\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\n\n\n    getUserData(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.userService.getUserDataFromStore(config)));\n    }\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\n\n\n    checkAuth(url, configId) {\n      return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap$1(({\n        allConfigs,\n        currentConfig\n      }) => this.checkAuthService.checkAuth(currentConfig, allConfigs, url)), tap$1(this.finishLoading), catchError$1(this.finishLoadingOnError));\n    }\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\n\n\n    checkAuthMultiple(url) {\n      return this.configurationService.getOpenIDConfigurations().pipe(switchMap$1(({\n        allConfigs\n      }) => this.checkAuthService.checkAuthMultiple(allConfigs, url)), tap$1(this.finishLoading), catchError$1(this.finishLoadingOnError));\n    }\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\n\n\n    isAuthenticated(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.authStateService.isAuthenticated(config)));\n    }\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\n\n\n    checkAuthIncludingServer(configId) {\n      return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap$1(({\n        allConfigs,\n        currentConfig\n      }) => this.checkAuthService.checkAuthIncludingServer(currentConfig, allConfigs)), tap$1(this.finishLoading), catchError$1(this.finishLoadingOnError));\n    }\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\n\n\n    getAccessToken(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.authStateService.getAccessToken(config)));\n    }\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\n\n\n    getIdToken(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.authStateService.getIdToken(config)));\n    }\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\n\n\n    getRefreshToken(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.authStateService.getRefreshToken(config)));\n    }\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\n\n\n    getAuthenticationResult(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.authStateService.getAuthenticationResult(config)));\n    }\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\n\n\n    getPayloadFromIdToken(encode = false, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => {\n        const token = this.authStateService.getIdToken(config);\n        return this.tokenHelperService.getPayloadFromToken(token, encode, config);\n      }));\n    }\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\n\n\n    setState(state, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.flowsDataService.setAuthStateControl(state, config)));\n    }\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\n\n\n    getState(configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.flowsDataService.getAuthStateControl(config)));\n    }\n    /**\r\n     * Redirects the user to the Security Token Service to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\n\n\n    authorize(configId, authOptions) {\n      this.configurationService.getOpenIDConfiguration(configId).subscribe(config => this.loginService.login(config, authOptions));\n    }\n    /**\r\n     * Opens the Security Token Service in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\n\n\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\n      return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap$1(({\n        allConfigs,\n        currentConfig\n      }) => this.loginService.loginWithPopUp(currentConfig, allConfigs, authOptions, popupOptions)));\n    }\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\n\n\n    forceRefreshSession(customParams, configId) {\n      return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap$1(({\n        allConfigs,\n        currentConfig\n      }) => this.refreshSessionService.userForceRefreshSession(currentConfig, allConfigs, customParams)));\n    }\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\n\n\n    logoffAndRevokeTokens(configId, authOptions) {\n      return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap$1(({\n        allConfigs,\n        currentConfig\n      }) => this.logoffRevocationService.logoffAndRevokeTokens(currentConfig, allConfigs, authOptions)));\n    }\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\n\n\n    logoff(configId, authOptions) {\n      this.configurationService.getOpenIDConfigurations(configId).subscribe(({\n        allConfigs,\n        currentConfig\n      }) => this.logoffRevocationService.logoff(currentConfig, allConfigs, authOptions));\n    }\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\n\n\n    logoffLocal(configId) {\n      this.configurationService.getOpenIDConfigurations(configId).subscribe(({\n        allConfigs,\n        currentConfig\n      }) => this.logoffRevocationService.logoffLocal(currentConfig, allConfigs));\n    }\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\n\n\n    logoffLocalMultiple() {\n      this.configurationService.getOpenIDConfigurations().subscribe(({\n        allConfigs\n      }) => this.logoffRevocationService.logoffLocalMultiple(allConfigs));\n    }\n    /**\r\n     * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\n\n\n    revokeAccessToken(accessToken, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap$1(config => this.logoffRevocationService.revokeAccessToken(config, accessToken)));\n    }\n    /**\r\n     * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\n\n\n    revokeRefreshToken(refreshToken, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap$1(config => this.logoffRevocationService.revokeRefreshToken(config, refreshToken)));\n    }\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\n\n\n    getEndSessionUrl(customParams, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(map$1(config => this.logoffRevocationService.getEndSessionUrl(config, customParams)));\n    }\n    /**\r\n     * Creates the authorize URL based on your flow\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the authorize URL or null\r\n     */\n\n\n    getAuthorizeUrl(customParams, configId) {\n      return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap$1(config => this.urlService.getAuthorizeUrl(config, customParams ? {\n        customParams: customParams\n      } : undefined)));\n    }\n\n  }\n\n  OidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n    return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService));\n  };\n\n  OidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OidcSecurityService,\n    factory: OidcSecurityService.ɵfac\n  });\n  return OidcSecurityService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DefaultSessionStorageService = /*#__PURE__*/(() => {\n  class DefaultSessionStorageService {\n    read(key) {\n      return sessionStorage.getItem(key);\n    }\n\n    write(key, value) {\n      sessionStorage.setItem(key, value);\n    }\n\n    remove(key) {\n      sessionStorage.removeItem(key);\n    }\n\n    clear() {\n      sessionStorage.clear();\n    }\n\n  }\n\n  DefaultSessionStorageService.ɵfac = function DefaultSessionStorageService_Factory(t) {\n    return new (t || DefaultSessionStorageService)();\n  };\n\n  DefaultSessionStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultSessionStorageService,\n    factory: DefaultSessionStorageService.ɵfac\n  });\n  return DefaultSessionStorageService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\nlet AuthModule = /*#__PURE__*/(() => {\n  class AuthModule {\n    static forRoot(passedConfig) {\n      return {\n        ngModule: AuthModule,\n        providers: [// Make the PASSED_CONFIG available through injection\n        {\n          provide: PASSED_CONFIG,\n          useValue: passedConfig\n        }, // Create the loader: Either the one getting passed or a static one\n        (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || {\n          provide: StsConfigLoader,\n          useFactory: createStaticLoader,\n          deps: [PASSED_CONFIG]\n        }, ConfigurationService, PublicEventsService, FlowHelper, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JwtWindowCryptoService, CurrentUrlService, ClosestMatchingRouteService, DefaultSessionStorageService, BrowserStorageService, CryptoService, LoggerService, {\n          provide: AbstractSecurityStorage,\n          useClass: DefaultSessionStorageService\n        }, {\n          provide: AbstractLoggerService,\n          useClass: ConsoleLoggerService\n        }]\n      };\n    }\n\n  }\n\n  AuthModule.ɵfac = function AuthModule_Factory(t) {\n    return new (t || AuthModule)();\n  };\n\n  AuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AuthModule\n  });\n  AuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, HttpClientModule]\n  });\n  return AuthModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AutoLoginAllRoutesGuard = /*#__PURE__*/(() => {\n  class AutoLoginAllRoutesGuard {\n    constructor(autoLoginService, checkAuthService, loginService, configurationService, router) {\n      this.autoLoginService = autoLoginService;\n      this.checkAuthService = checkAuthService;\n      this.loginService = loginService;\n      this.configurationService = configurationService;\n      this.router = router;\n    }\n\n    canLoad() {\n      var _a, _b;\n\n      return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\n    }\n\n    canActivate(route, state) {\n      return this.checkAuth(state.url);\n    }\n\n    canActivateChild(route, state) {\n      return this.checkAuth(state.url);\n    }\n\n    checkAuth(url) {\n      return this.configurationService.getOpenIDConfiguration().pipe(switchMap(config => {\n        const allconfigs = this.configurationService.getAllConfigurations();\n        return this.checkAuthService.checkAuth(config, allconfigs).pipe(take(1), map(({\n          isAuthenticated\n        }) => {\n          if (isAuthenticated) {\n            this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n          }\n\n          if (!isAuthenticated) {\n            this.autoLoginService.saveRedirectRoute(config, url);\n            this.loginService.login(config);\n          }\n\n          return isAuthenticated;\n        }));\n      }));\n    }\n\n  }\n\n  AutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n    return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n  };\n\n  AutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AutoLoginAllRoutesGuard,\n    factory: AutoLoginAllRoutesGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return AutoLoginAllRoutesGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AutoLoginPartialRoutesGuard = /*#__PURE__*/(() => {\n  class AutoLoginPartialRoutesGuard {\n    constructor(autoLoginService, authStateService, loginService, configurationService, router) {\n      this.autoLoginService = autoLoginService;\n      this.authStateService = authStateService;\n      this.loginService = loginService;\n      this.configurationService = configurationService;\n      this.router = router;\n    }\n\n    canLoad() {\n      var _a, _b;\n\n      return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\n    }\n\n    canActivate(route, state) {\n      return this.checkAuth(state.url);\n    }\n\n    canActivateChild(route, state) {\n      return this.checkAuth(state.url);\n    }\n\n    checkAuth(url) {\n      return this.configurationService.getOpenIDConfiguration().pipe(map(configuration => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configuration);\n\n        if (isAuthenticated) {\n          this.autoLoginService.checkSavedRedirectRouteAndNavigate(configuration);\n        }\n\n        if (!isAuthenticated) {\n          this.autoLoginService.saveRedirectRoute(configuration, url);\n          this.loginService.login(configuration);\n        }\n\n        return isAuthenticated;\n      }));\n    }\n\n  }\n\n  AutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n    return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n  };\n\n  AutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AutoLoginPartialRoutesGuard,\n    factory: AutoLoginPartialRoutesGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return AutoLoginPartialRoutesGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthInterceptor = /*#__PURE__*/(() => {\n  class AuthInterceptor {\n    constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {\n      this.authStateService = authStateService;\n      this.configurationService = configurationService;\n      this.loggerService = loggerService;\n      this.closestMatchingRouteService = closestMatchingRouteService;\n    }\n\n    intercept(req, next) {\n      if (!this.configurationService.hasAtLeastOneConfig()) {\n        return next.handle(req);\n      }\n\n      const allConfigurations = this.configurationService.getAllConfigurations();\n      const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n      const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\n\n      if (allRoutesConfiguredFlat.length === 0) {\n        this.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);\n        return next.handle(req);\n      }\n\n      const {\n        matchingConfig,\n        matchingRoute\n      } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);\n\n      if (!matchingConfig) {\n        this.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);\n        return next.handle(req);\n      }\n\n      this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);\n      const token = this.authStateService.getAccessToken(matchingConfig);\n\n      if (!token) {\n        this.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n        return next.handle(req);\n      }\n\n      this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n      req = req.clone({\n        headers: req.headers.set('Authorization', 'Bearer ' + token)\n      });\n      return next.handle(req);\n    }\n\n  }\n\n  AuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n    return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n  };\n\n  AuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthInterceptor,\n    factory: AuthInterceptor.ɵfac\n  });\n  return AuthInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractLoggerService, AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, ConfigurationService, EventTypes, LogLevel, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, ValidationResult, createStaticLoader }; //# sourceMappingURL=angular-auth-oidc-client.mjs.map","map":null,"metadata":{},"sourceType":"module"}